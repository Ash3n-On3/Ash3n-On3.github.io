<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hook Framework</title>
      <link href="2021/03/15/Hook%E6%A1%86%E6%9E%B6/"/>
      <url>2021/03/15/Hook%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>截获消息，获得控制权。<span id="more"></span></p><p>HOOK框架是一种Android逆向技术。在系统没有调用该函数之前，Hook就先捕获该消息，Hook函数先得到控制权，这时Hook函数既可以修改程序执行逻辑，改变参数返回值，还可以强制结束消息的传递。本文介绍常用的两种。</p><h1 id="Frida"><a href="#Frida" class="headerlink" title="Frida"></a>Frida</h1><p>Frida是基于JavaScript和python的，可以实现对android程序进行动态调试的工具包，可以用于下列用途：</p><ul><li>访问进程的内存</li><li>应用程序运行时覆盖功能</li><li>从导入的类调用函数</li><li>动态Hook跟踪、拦截函数</li><li>在堆上查找对象实例并使用这些对象实例</li></ul><p>Frida的本质是给二进制文件插桩，用安卓应用举例：在手机上运行frida_server并且转发端口到PC端，PC端又利用python代码与server进行通信，并用JavaScript对于正在执行的进程进行注入，达到内存访问的目的。如图：</p><img src="https://z3.ax1x.com/2021/03/25/6LUVsI.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LUVsI.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom: 67%;" /><p>本文对示例的两个apk分别进行java层和native层的hook调试。</p><h2 id="Java层"><a href="#Java层" class="headerlink" title="Java层"></a>Java层</h2><h3 id="1-手机端环境配置"><a href="#1-手机端环境配置" class="headerlink" title="1.手机端环境配置"></a>1.手机端环境配置</h3><ul><li>下载<a href="https://github.com/frida/frida/releases">frida_server</a>并push至手机中</li><li>adb shell中运行，并转发端口(默认端口为27042)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb forward tcp:27042 tcp:27042</span><br></pre></td></tr></table></figure><h3 id="2-Java-代码分析"><a href="#2-Java-代码分析" class="headerlink" title="2.Java 代码分析"></a>2.Java 代码分析</h3><p>demo中需要分析的代码段如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In MainActivity:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View arg6)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(arg6.getId()) &#123;</span><br><span class="line"><span class="comment">//Button 1</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">2131230720</span>: &#123;</span><br><span class="line">      Toast.makeText(<span class="keyword">this</span>.getApplication(), <span class="keyword">new</span> StringBuilder(String.valueOf(Utils.getCalc(<span class="number">2000</span>, <span class="number">5000</span>))).toString(), <span class="number">1</span>).show();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//Button 2</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">2131230721</span>: &#123;</span><br><span class="line">      Toast.makeText(<span class="keyword">this</span>.getApplication(), Utils.getMoney().getInfo(), <span class="number">1</span>).show();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//Button 3</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">2131230722</span>: &#123;</span><br><span class="line">      Toast.makeText(<span class="keyword">this</span>.getApplication(), Utils.test(<span class="number">0x7CB8</span>), <span class="number">1</span>).show();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//Button 4</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">2131230723</span>: &#123;</span><br><span class="line">      Toast.makeText(<span class="keyword">this</span>.getApplication(), Utils.test(), <span class="number">1</span>).show();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//Button 5</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">2131230724</span>: &#123;</span><br><span class="line">      Toast.makeText(<span class="keyword">this</span>.getApplication(), Utils.test(), <span class="number">1</span>).show();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中五个Button分别对应了如下五种函数类型。其Java代码及JavaScript注入脚本如下：</p><p><strong>Button 1:普通方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCalc</span><span class="params">(<span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg1 + arg2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>👇</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Java.perform(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//通过Java.use()找到需要hook的java类为变量初始化</span></span><br><span class="line">    <span class="keyword">var</span> utils = Java.use(<span class="string">&#x27;com.frida.test.Utils&#x27;</span>);</span><br><span class="line"><span class="comment">//为util类中的getCalc方法编写hook脚本：参数为a,b</span></span><br><span class="line">    utils.getCalc.implementation = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="comment">//log方式输出</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hook Start...&quot;</span>);</span><br><span class="line"><span class="comment">//终端方式输出，分别输出Java层中给getCalc函数传入的两个参数</span></span><br><span class="line">send(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">    send(<span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">send(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> num=<span class="built_in">arguments</span>[<span class="number">0</span>]+<span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line">send(<span class="string">&quot;返回值:&quot;</span>);</span><br><span class="line">send(num);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.getCalc(<span class="built_in">arguments</span>[<span class="number">0</span>],<span class="built_in">arguments</span>[<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>Button 2:构造方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Money</span><span class="params">(<span class="keyword">int</span> arg1, String arg2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.num = arg1;</span><br><span class="line">    <span class="keyword">this</span>.name = arg2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>👇</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Java.perform(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> money = Java.use(<span class="string">&#x27;com.frida.test.Money&#x27;</span>);</span><br><span class="line"><span class="comment">//&quot;$init&quot;表示money类的构造函数</span></span><br><span class="line">    money.$init.implementation = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hook Start...&quot;</span>);</span><br><span class="line">send(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">send(<span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">    send(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line"><span class="comment">//原传入参数为:100,&quot;RMB&quot;</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.$init(<span class="number">10000</span>, <span class="string">&quot;Dollor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>Button 3:重载方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test</span><span class="params">(<span class="keyword">int</span> arg2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Test string 2:&quot;</span> + arg2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;This is a test string&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>👇</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Java.perform(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> utils = Java.use(<span class="string">&#x27;com.frida.test.Utils&#x27;</span>);</span><br><span class="line"><span class="comment">//绑定参数类型为(int)的test重载函数</span></span><br><span class="line">    utils.test.overload(<span class="string">&quot;int&quot;</span>).implementation = <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Hook Start...&quot;</span>);</span><br><span class="line">send(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">    send(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;3.1415926&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>Button4、5</strong>在java层中调用了相同的函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;This is a test string&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是通过注入不同的Javascrip脚本实现如下的不同功能。</p><p><strong>构造对象参数</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Java.perform(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//此处构造两个新对象</span></span><br><span class="line"><span class="keyword">var</span> utils = Java.use(<span class="string">&#x27;com.frida.test.Utils&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> money = Java.use(<span class="string">&#x27;com.frida.test.Money&#x27;</span>);</span><br><span class="line"><span class="comment">//test函数作为载体</span></span><br><span class="line">  utils.test.overload().implementation = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    send(<span class="string">&quot;Hook Start...&quot;</span>);</span><br><span class="line"><span class="comment">//劫持程序执行新对象的构造函数</span></span><br><span class="line"><span class="keyword">var</span> mon = money.$new(<span class="number">2000</span>,<span class="string">&#x27;港币&#x27;</span>);</span><br><span class="line">send(mon.getInfo());</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.test(<span class="number">800</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>修改对象属性</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Java.perform(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> utils = Java.use(<span class="string">&#x27;com.frida.test.Utils&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> money = Java.use(<span class="string">&#x27;com.frida.test.Money&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="class"><span class="keyword">class</span> </span>= Java.use(<span class="string">&#x27;java.lang.Class&#x27;</span>);</span><br><span class="line">  utils.test.overload().implementation = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  send(<span class="string">&quot;Hook Start...&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> mon = money.$new(<span class="number">200</span>,<span class="string">&#x27;港币&#x27;</span>);</span><br><span class="line">send(mon.getInfo());</span><br><span class="line"><span class="comment">//将变量绑定为money对象的num属性</span></span><br><span class="line"><span class="keyword">var</span> numid= Java.cast(mon.getClass(),<span class="class"><span class="keyword">class</span>).<span class="title">getDeclaredField</span>(&#x27;<span class="title">num</span>&#x27;)</span>;</span><br><span class="line"><span class="comment">//将变量设为可修改</span></span><br><span class="line">numid.setAccessible(<span class="literal">true</span>);</span><br><span class="line">  send(numid.get(mon));</span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line">  numid.setInt(mon, <span class="number">1000</span>);</span><br><span class="line">  send(mon.getInfo());</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.test(<span class="number">800</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上述JavaScript脚本均需要插入到python代码中以运行使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">jscode=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">此处插入js代码，用三引号包围</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">message</span>(<span class="params">message, data</span>):</span></span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">&quot;type&quot;</span>] == <span class="string">&#x27;send&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[*] &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(message[<span class="string">&#x27;payload&#x27;</span>]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line">process = frida.get_remote_device().attach(<span class="string">&#x27;com.frida.test&#x27;</span>)</span><br><span class="line">script= process.create_script(jscode)</span><br><span class="line">script.on(<span class="string">&quot;message&quot;</span>, message)</span><br><span class="line">script.load()</span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure><h2 id="Native层"><a href="#Native层" class="headerlink" title="Native层"></a>Native层</h2><p>so层代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> __fastcall Java_com_example_fridaso_FridaSoDefine_FridaSo(<span class="built_in">int</span> a1, <span class="built_in">int</span> a2, <span class="built_in">int</span> a3, <span class="built_in">int</span> a4，<span class="built_in">int</span> a5)</span><br><span class="line">&#123;</span><br><span class="line">switch(a5):</span><br><span class="line">case <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">return</span> a4 + a3;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">case <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">return</span> a3 - a4;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">case <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">return</span> a4 * a3;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">case <span class="number">1</span>:</span><br><span class="line">  <span class="keyword">return</span> a3 / a4;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">default:</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Javascript脚本：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//setImmediate包围，可防止超时报错</span></span><br><span class="line">setImmediate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    send(<span class="string">&quot;start&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历模块找基址</span></span><br><span class="line">    Process.enumerateModules(&#123;</span><br><span class="line">        onMatch: <span class="function"><span class="keyword">function</span> (<span class="params">exp</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (exp.name == <span class="string">&#x27;libdemo.so&#x27;</span>) &#123;</span><br><span class="line">                send(<span class="string">&#x27;enumerateModules find&#x27;</span>);</span><br><span class="line">                send(exp.name + <span class="string">&quot;|&quot;</span> + exp.base + <span class="string">&quot;|&quot;</span> + exp.size + <span class="string">&quot;|&quot;</span> + exp.path);</span><br><span class="line">                send(exp);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;stop&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        onComplete: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            send(<span class="string">&#x27;enumerateModules stop&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//hook导出函数</span></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">exports</span> = Module.enumerateExportsSync(<span class="string">&quot;libdemo.so&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="built_in">exports</span>.length;i++)&#123;</span><br><span class="line">        send(<span class="string">&quot;name:&quot;</span>+<span class="built_in">exports</span>[i].name+<span class="string">&quot;  address:&quot;</span>+<span class="built_in">exports</span>[i].address);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过模块名直接查找基址</span></span><br><span class="line">    <span class="keyword">var</span> baseSOFile = Module.findBaseAddress(<span class="string">&quot;libdemo.so&quot;</span>);</span><br><span class="line">    <span class="comment">//&quot;Interceptor.attach&quot;获取进程，此处若为thumb汇编则需要改成0x1270+1</span></span><br><span class="line">    Interceptor.attach(baseSOFile.add(<span class="number">0x00001270</span>),&#123;</span><br><span class="line">        onEnter: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line"><span class="comment">//参数1为JNIEnv *</span></span><br><span class="line">            <span class="built_in">console</span>.log(Memory.readCString(args[<span class="number">0</span>]));</span><br><span class="line"><span class="comment">//参数2为jclass</span></span><br><span class="line">            <span class="built_in">console</span>.log(Memory.readUtf16String(args[<span class="number">3</span>]));</span><br><span class="line">            <span class="built_in">console</span>.log(args[<span class="number">2</span>]);</span><br><span class="line">            <span class="built_in">console</span>.log(args[<span class="number">3</span>]);</span><br><span class="line">            <span class="built_in">console</span>.log(args[<span class="number">4</span>]);</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave: <span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过包名类名函数名找到基址获取程序进程</span></span><br><span class="line">Interceptor.attach(Module.findExportByName(<span class="string">&quot;libfridaso.so&quot;</span>,<span class="string">&quot;Java_com_example_fridaso_FridaSoDefine_FridaSo&quot;</span>),&#123;</span><br><span class="line">        <span class="comment">//onEnter在函数执行前执行，args是函参</span></span><br><span class="line">onEnter: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">            send(<span class="string">&quot;Hook start&quot;</span>);</span><br><span class="line">            send(<span class="string">&quot;args[2]=&quot;</span> + args[<span class="number">2</span>]);</span><br><span class="line">            send(<span class="string">&quot;args[3]=&quot;</span> + args[<span class="number">3</span>]);</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="comment">//onLeave在函数执行结束后执行，retval是返回值</span></span><br><span class="line">        onLeave: <span class="function"><span class="keyword">function</span>(<span class="params">retval</span>)</span>&#123;</span><br><span class="line">            send(<span class="string">&quot;return:&quot;</span>+retval); </span><br><span class="line">            retval.replace(<span class="number">0</span>); <span class="comment">//替换返回值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="Xposed-Framework"><a href="#Xposed-Framework" class="headerlink" title="Xposed Framework"></a>Xposed Framework</h1><h2 id="原理简述"><a href="#原理简述" class="headerlink" title="原理简述"></a><strong>原理简述</strong></h2><p>Xposed框架通过安装模块来实现需要的功能。所谓模块是指一类特殊的app，此类app通过修改Zygote来实现一些设计内核以及高权限的功能，由Xposed管理。其中，Zygote是Android的内核，每个APP均由Zygote fork出的虚拟机来运行，而Xposed框架中的模块可以重写并替换Zygote的执行文件app_process，即可从一开始就修改整个进程。</p><p>详细原理参见<a href="https://www.freebuf.com/articles/terminal/56453.html">链接</a>。</p><h2 id="使用过程"><a href="#使用过程" class="headerlink" title="使用过程"></a>使用过程</h2><h3 id="手机端"><a href="#手机端" class="headerlink" title="手机端"></a>手机端</h3><p>1.手机root后直接安装<a href="http://xposed.appkg.com/nav">xpose installer</a> ，需要注意android5.0以下和以上安装的是不同版本。</p><p>2.重启后提示安装完成</p><p><img src="https://z3.ax1x.com/2021/03/25/6LUZLt.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LUZLt.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h3 id="PC端"><a href="#PC端" class="headerlink" title="PC端"></a>PC端</h3><p>1.在Android Studio中新建空白工程(No Activity)，将库文件拖入libs目录。</p><p><img src="https://z3.ax1x.com/2021/03/25/6LUpdK.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LUpdK.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>2.在Java项目的第一个包里新建class。</p><p><img src="https://z3.ax1x.com/2021/03/25/6LUPiD.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LUPiD.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.xp;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XC_MethodHook;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedBridge;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedHelpers;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_LoadPackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">hook</span> <span class="keyword">implements</span> <span class="title">IXposedHookLoadPackage</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam loadPackageParam)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(loadPackageParam.packageName.equals(<span class="string">&quot;包名&quot;</span>))&#123;</span><br><span class="line">      XposedHelpers.findAndHookMethod(<span class="string">&quot;包名.类名&quot;</span>, loadPackageParam.classLoader,</span><br><span class="line">        <span class="string">&quot;hook函数名&quot;</span>, String.class, String.class, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line"><span class="comment">//执行被hook函数前运行</span></span><br><span class="line">          <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.beforeHookedMethod(param);</span><br><span class="line">            XposedBridge.log(<span class="string">&quot;Arg1: &quot;</span> + param.args[<span class="number">0</span>]);</span><br><span class="line">            XposedBridge.log(<span class="string">&quot;Arg2: &quot;</span> + param.args[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//XposedBridge.log(&quot;Arg3: &quot; + param.args[2]);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印堆栈信息</span></span><br><span class="line">            StackTraceElement[] wodelogs = <span class="keyword">new</span> Throwable(<span class="string">&quot;wodelog&quot;</span>).getStackTrace();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;wodelogs.length;i++)&#123;</span><br><span class="line">                XposedBridge.log(<span class="string">&quot;查看堆栈:&quot;</span>+wodelogs[i].toString());</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line"><span class="comment">//执行被hook函数后运行(返回前)</span></span><br><span class="line">          <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.afterHookedMethod(param);</span><br><span class="line">XposedBridge.log(<span class="string">&quot;Result before modified: &quot;</span> + param);</span><br><span class="line">            param.setResult(<span class="keyword">true</span>); <span class="comment">// 函数返回值修改为true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.创建assets文件夹，新建文件xposed_init，写入“包名+类名”，模块从此处寻找程序入口。</p><p><img src="https://z3.ax1x.com/2021/03/25/6LU9IO.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LU9IO.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>4.修改清单文件AndroidManifest.xml，在<application>标签之间添加如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 添加标识 --&gt;</span></span><br><span class="line"> &lt;meta-data</span><br><span class="line">     android:name=&quot;xposedmodule&quot;</span><br><span class="line">     android:value=&quot;true&quot;/&gt;</span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- 载入Hook模块之后显示的信息 --&gt;</span></span><br><span class="line"> &lt;meta-data</span><br><span class="line">     android:name=&quot;xposeddescription&quot;</span><br><span class="line">     android:value=&quot;Xposed Proxy For HOOK&quot;/&gt;</span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- 规定jar包的版本信息 --&gt;</span></span><br><span class="line"> &lt;meta-data</span><br><span class="line">     android:name=&quot;xposedminversion&quot;</span><br><span class="line">     android:value=&quot;54&quot;/&gt;</span><br></pre></td></tr></table></figure><p>👇</p><img src="https://z3.ax1x.com/2021/03/25/6LUiJe.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LUiJe.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:80%;" /><p>5.修改build.gradle(app)，添加sourceSets段落，修改fileTree为compileOnly</p><img src="https://z3.ax1x.com/2021/03/25/6LUFRH.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LUFRH.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:67%;" /><p>6.构造运行，在虚拟机中查看，在installer中勾选模块</p><p><img src="https://z3.ax1x.com/2021/03/25/6LUkzd.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LUkzd.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>7.重启后在installer中查看日志，安装完成</p><p><img src="https://z3.ax1x.com/2021/03/25/6LUEQA.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LUEQA.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>]]></content>
      
      
      
        <tags>
            
            <tag> AndroidRe </tag>
            
            <tag> Summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Protection</title>
      <link href="2021/03/08/Android%20Protection/"/>
      <url>2021/03/08/Android%20Protection/</url>
      
        <content type="html"><![CDATA[<p>关于APK包的保护以及代码的反调试方法。<span id="more"></span></p><h1 id="APK保护"><a href="#APK保护" class="headerlink" title="APK保护"></a>APK保护</h1><h2 id="Java代码混淆"><a href="#Java代码混淆" class="headerlink" title="Java代码混淆"></a>Java代码混淆</h2><p>通常为了提高代码可读性，开发者会给各个标识赋予相应的意义，包名类名都会经过相应的命名。但是当程序被打包时，不需要考虑可读性，因为包名类名或者标识符只需要能准确寻址即可，于是开发者会对可执行文件的源代码进行混淆，这样可以一定程度的增加逆向过程中所需的时间。</p><p><img src="https://z3.ax1x.com/2021/03/25/6LYZLV.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LYZLV.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>低可读性可以劝退一部分逆向者，但是本质上来说，整个代码的逻辑并没有改变，因此并不能一劳永逸地解决代码保护的问题。</p><h2 id="资源文件混淆"><a href="#资源文件混淆" class="headerlink" title="资源文件混淆"></a>资源文件混淆</h2><p>类似代码混淆，降低资源id和资源文件名的可读性。</p><h2 id="签名验证"><a href="#签名验证" class="headerlink" title="签名验证"></a>签名验证</h2><p>某些apk文件解压后，发现里面存在MANIFEST.MF文件，这就是apk的签名文件。</p><p>签名文件中保存着apk文件的信息摘要并进行了加密，如果通过逆向对apk进行重新打包，会使得签名文件与原文件不一致，无法通过签名校验。</p><p>签名验证方式很多，以下例子是被定义在native层的三个签名相关函数，人送爱称“签名三兄弟”。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getPackageName()</span><br><span class="line">getPackageManage()</span><br><span class="line">getPackageInfo()</span><br></pre></td></tr></table></figure><p>签名验证可以通过修改程序逻辑进行绕过，实际情况实际分析。</p><h1 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h1><h2 id="关键文件检测"><a href="#关键文件检测" class="headerlink" title="关键文件检测"></a>关键文件检测</h2><p>遍历**/data/local/tmp<strong>路径，查找是否存在</strong>android_server<strong>，</strong>android_server64**这样的文件。如果存在则杀死当前进程。</p><h2 id="调试端口检测"><a href="#调试端口检测" class="headerlink" title="调试端口检测"></a>调试端口检测</h2><p>一些调试器在调试安卓程序时会占用默认的端口，例如IDA使用的端口：<strong>23946</strong>。检验占用这些端口的进程即可轻易判断程序是否被调试。</p><p>但换成非默认端口即可绕过。</p><h2 id="进程名称检测"><a href="#进程名称检测" class="headerlink" title="进程名称检测"></a>进程名称检测</h2><p>Android系统中(其实Linux也是)，每个进程运行时都会生成一个对应的文件夹，路径为**/proc/pid/<strong>，其<a href="https://blog.csdn.net/zdwzzu2006/article/details/7747977">目录</a>下的</strong>status**文件用于记录进程状态。而status文件中的Tracerid字段，又用于记录当前进程的调试进程pid。</p><p>检测时只需读取此处的pid判断是否为空，如果不为空再查询此pid对应的是什么进程。如果是android_server这样的与调试相关进程，则直接杀死当前进程阻止调试。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">coursecheck</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> bufsize = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">char</span> filename[bufsize];</span><br><span class="line">    <span class="keyword">char</span> line[bufsize];</span><br><span class="line">    <span class="keyword">char</span> name[bufsize];</span><br><span class="line">    <span class="keyword">char</span> nameline[bufsize];</span><br><span class="line">    <span class="keyword">int</span> pid = getpid();</span><br><span class="line">    <span class="comment">//先读取Tracepid的值</span></span><br><span class="line">    <span class="built_in">sprintf</span>(filename, <span class="string">&quot;/proc/%d/status&quot;</span>, pid);</span><br><span class="line">    FILE *fd=fopen(filename,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">while</span>(fgets(line,bufsize,fd))</span><br><span class="line">&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strstr</span>(line,<span class="string">&quot;TracerPid&quot;</span>)!=<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> statue =atoi(&amp;line[<span class="number">10</span>]);</span><br><span class="line">                <span class="keyword">if</span>(statue!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">                    <span class="built_in">sprintf</span>(name,<span class="string">&quot;/proc/%d/cmdline&quot;</span>,statue);</span><br><span class="line">                    FILE *fdname=fopen(name,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span>(fdname!= <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">                        <span class="keyword">while</span>(fgets(nameline,bufsize,fdname))</span><br><span class="line">&#123;</span><br><span class="line">                            <span class="keyword">if</span>(<span class="built_in">strstr</span>(nameline,<span class="string">&quot;android_server&quot;</span>)!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">                                <span class="keyword">int</span> ret=kill(pid,SIGKILL);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    fclose(fdname);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="轮询检测"><a href="#轮询检测" class="headerlink" title="轮询检测"></a>轮询检测</h2><p>循环检测当前进程状态文件，即 ，判断tracerid字段是否为0，若不为0则判定进程处于被debug状态，进而关闭进程。</p><p><img src="https://z3.ax1x.com/2021/03/25/6LtCm6.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LtCm6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h2 id="Self-Debugging"><a href="#Self-Debugging" class="headerlink" title="Self-Debugging"></a>Self-Debugging</h2><p>当前进程fork()得到子进程后，子进程对父进程进行debug，由于父进程被占用(进程同一时间只能被一个进程attach)，使得其他程序无法直接对父进程进行debug。</p><p>解决方法：通过debug子进程来间接debug父进程。</p><h2 id="模拟器检测"><a href="#模拟器检测" class="headerlink" title="模拟器检测"></a>模拟器检测</h2><p>根据模拟器的特征，程序可以判断自身是否运行于模拟器中。特征值大致有下面这些：</p><ol><li>Device ID - 设备序列号</li><li>电话号码</li><li>IMSI识别码</li><li>运营商名称</li><li>QEMU相关的二进制文件</li><li>CPU信息</li></ol><p>除此之外的<a href="https://bbs.pediy.com/thread-225717.html">模拟器检测方法</a>还有很多。</p><h2 id="Java层反调试"><a href="#Java层反调试" class="headerlink" title="Java层反调试"></a>Java层反调试</h2><h3 id="0x00-Debug条件"><a href="#0x00-Debug条件" class="headerlink" title="0x00.Debug条件"></a>0x00.Debug条件</h3><ul><li><p>apk中的AndroidMainfest.xml中，application标签下有该属性：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Android:debuggable=true</span><br></pre></td></tr></table></figure></li><li><p>设备可调试，即拥有如下属性：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ro.debugable=1</span><br></pre></td></tr></table></figure><p>  该属性又位于boot.img镜像中的/default.prop文件中，前者在设备开机前由ramdisk 挂载。因此可以修改boot.img从而修改ro.debugable属性使得设备全局可调试。<a href="https://www.cnblogs.com/codex/p/12250647.html">该项修改</a>可通过Magisk及其模块MagiskHide Props Config实现。</p></li></ul><h3 id="0x01-isDebuggerConnected"><a href="#0x01-isDebuggerConnected" class="headerlink" title="0x01.isDebuggerConnected()"></a>0x01.isDebuggerConnected()</h3><p>Android SDK中的android.os.debug类提供了一个isDebuggerConnected方法，该方法用于判断JDWP调试器是否正在工作。</p><p><img src="https://z3.ax1x.com/2021/03/25/6LYmZT.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LYmZT.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>可通过修改smali代码进行绕过。</p><h3 id="0x02-时间戳检测"><a href="#0x02-时间戳检测" class="headerlink" title="0x02.时间戳检测"></a>0x02.时间戳检测</h3><p>正常情况下程序运行时取两个时间戳，两者差值较小。但若是在debug状态下，时间差值会超出正常值，若排除程序卡顿已经bug的情况下可以断定app处于debug状态。Exp：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jint <span class="title">anti_time</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> pid = getpid();</span><br><span class="line"> struct timeval t1;</span><br><span class="line"> struct timeval t2;</span><br><span class="line"> struct timezone tz;</span><br><span class="line"> gettimeofday(&amp;t1, &amp;tz);</span><br><span class="line"> gettimeofday(&amp;t2, &amp;tz);</span><br><span class="line"> <span class="keyword">int</span> timeoff = (t2.tv_sec) - (t1.tv_sec);</span><br><span class="line"> LOGD(<span class="string">&quot;time %d&quot;</span>,timeoff);</span><br><span class="line"> <span class="keyword">if</span> (timeoff &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> ret = kill(pid, SIGKILL);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x03-断点检测"><a href="#0x03-断点检测" class="headerlink" title="0x03.断点检测"></a>0x03.断点检测</h3><p>程序运行过程会将elf文件(使用so的情况下)导入导入内存中，如果存在断点，内存中也会改变相应的指令，留下thumb或者arm的断点指令的机器码。利用指针遍历内存中elf文件判断有无上述机器码，即可判断有无断点，进而判断是否处于debug。Exp：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jint <span class="title">anti_breakpoint</span><span class="params">()</span></span>&#123;</span><br><span class="line">Elf32_Ehdr *elfhdr;</span><br><span class="line">Elf32_Phdr *pht;</span><br><span class="line">unsigned <span class="keyword">int</span> size, base, offset,phtable;</span><br><span class="line"><span class="keyword">int</span> n, i,j;</span><br><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line"><span class="comment">//从maps中读取elf文件在内存中的起始地址</span></span><br><span class="line">base = GetLibAddr();</span><br><span class="line"><span class="keyword">if</span>(base == <span class="number">0</span>)&#123;</span><br><span class="line">LOGD(<span class="string">&quot;find base error/n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">elfhdr = (Elf32_Ehdr *) base;</span><br><span class="line">phtable = elfhdr-&gt;e_phoff + base;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;elfhdr-&gt;e_phnum;i++)&#123;</span><br><span class="line">pht = (Elf32_Phdr*)(phtable+i*sizeof(Elf32_Phdr));</span><br><span class="line">    <span class="keyword">if</span>(pht-&gt;p_flags&amp;<span class="number">1</span>)&#123;</span><br><span class="line">    offset = pht-&gt;p_vaddr + base + sizeof(Elf32_Ehdr) + sizeof(Elf32_Phdr)*elfhdr-&gt;e_phnum;</span><br><span class="line">        LOGD(<span class="string">&quot;offset:%#x ,len:%#x&quot;</span>,offset,pht-&gt;p_memsz);</span><br><span class="line">        p = (<span class="keyword">char</span>*)offset;</span><br><span class="line">        size = pht-&gt;p_memsz;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>,n=<span class="number">0</span>;j&lt;size;++j,++p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*p == <span class="number">0x10</span> &amp;&amp; *(p+<span class="number">1</span>) == <span class="number">0xde</span>)&#123;</span><br><span class="line">        n++;</span><br><span class="line">                LOGD(<span class="string">&quot;### find thumb bpt %#x /n&quot;</span>,p);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(*p == <span class="number">0xf0</span> &amp;&amp; *(p+<span class="number">1</span>) == <span class="number">0xf7</span> &amp;&amp; *(p+<span class="number">2</span>) == <span class="number">0x00</span> &amp;&amp; *(p+<span class="number">3</span>) == <span class="number">0xa0</span>)&#123;</span><br><span class="line">                n++;</span><br><span class="line">                LOGD(<span class="string">&quot;### find thumb2 bpt %#x /n&quot;</span>,p);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(*p == <span class="number">0x01</span> &amp;&amp; *(p+<span class="number">1</span>) == <span class="number">0x00</span> &amp;&amp; *(p+<span class="number">2</span>) == <span class="number">0x9f</span> &amp;&amp; *(p+<span class="number">3</span>) == <span class="number">0xef</span>)&#123;</span><br><span class="line">                n++;</span><br><span class="line">                LOGD(<span class="string">&quot;### find arm bpt %#x /n&quot;</span>,p);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LOGD(<span class="string">&quot;### find breakpoint num: %d/n&quot;</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> AndroidRe </tag>
            
            <tag> Summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apk 动调</title>
      <link href="2021/03/01/APK%E5%8A%A8%E8%B0%83/"/>
      <url>2021/03/01/APK%E5%8A%A8%E8%B0%83/</url>
      
        <content type="html"><![CDATA[<p>Java层与Native层的动调调试。<span id="more"></span></p><h1 id="DDMS-java层"><a href="#DDMS-java层" class="headerlink" title="DDMS(java层)"></a>DDMS(java层)</h1><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><img src="https://z3.ax1x.com/2021/03/25/6L8TOK.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6L8TOK.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom: 47%;" /><h2 id="插桩-log输出"><a href="#插桩-log输出" class="headerlink" title="插桩-log输出"></a>插桩-log输出</h2><ol><li>利用AndroidKiller修改apk包，在需要插桩的代码处右键log输出，填入调试时需要输出的字符串。</li><li>打包安装到设备。</li><li>ddms中找到程序对应的activity，过滤找到输出信息。</li><li>根据输出信息的时间戳找到上下文，得到方法调用层次。</li></ol><h2 id="栈跟踪-stacktrace"><a href="#栈跟踪-stacktrace" class="headerlink" title="栈跟踪-stacktrace"></a>栈跟踪-stacktrace</h2><ol><li>利用AndroidKiller修改apk包，在需要插桩处右键stacktrace，填入调试时需要输出的字符串。</li><li>安装打开，用ddms过滤输出信息。</li><li>根据输出信息的时间戳找到上下文，自下而上得到方法调用层次。</li></ol><img src="https://z3.ax1x.com/2021/03/25/6L85S1.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6L85S1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom: 67%;" /><h2 id="方法分析"><a href="#方法分析" class="headerlink" title="方法分析"></a>方法分析</h2><ol><li>DDMS处打开方法分析并限制分析的方法数。</li><li>点击ok后，立即在设备上实现需要分析的功能。</li><li>功能实现后立即点击停止方法分析。</li><li>等待方法分析窗口打开。</li><li>任意方法均可通过下拉项查看上层(parents)和下层(Children)的调用方法。</li></ol><p><img src="https://z3.ax1x.com/2021/03/25/6L8IQx.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6L8IQx.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom: 43%;" /><img src="https://z3.ax1x.com/2021/03/25/6L8oy6.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6L8oy6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom: 58%;" /></p><h1 id="Android-Studio-Smalide-java层"><a href="#Android-Studio-Smalide-java层" class="headerlink" title="Android Studio + Smalide(java层)"></a>Android Studio + Smalide(java层)</h1><h2 id="远程调试"><a href="#远程调试" class="headerlink" title="远程调试"></a>远程调试</h2><ol><li>在AndroidKiller中打开apk文件，用AS导入该工程文件夹</li><li>在smali文件中设置调试断点</li><li>在“运行-编辑配置”中新建“remote”类型配置，设置好调试器名称和端口</li><li>连接设备，打开需要调试的程序，用“adb shell ps”命令找到需要调试的进程</li><li>用“adb forward tcp:10001 jdwp:3523”命令远程连接，其中”tcp:”后填入调试端口号，”jdwp”后填入需要调试进程的pid</li><li>在工具栏处选择远程调试配置，点击爬虫icon进行调试</li></ol><p><img src="https://z3.ax1x.com/2021/03/25/6L8HeO.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6L8HeO.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><img src="https://z3.ax1x.com/2021/03/25/6L8bwD.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6L8bwD.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:47%;" /><h1 id="IDA-Pro-Native层"><a href="#IDA-Pro-Native层" class="headerlink" title="IDA Pro(Native层)"></a>IDA Pro(Native层)</h1><h2 id="远程调试-1"><a href="#远程调试-1" class="headerlink" title="远程调试"></a>远程调试</h2><p>将android_server(64) push到设备中，chmod赋予权限并运行。</p><p><img src="https://z3.ax1x.com/2021/03/25/6L8qTe.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6L8qTe.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在terminal中用adb进行端口转发。默认端口<strong>23946</strong>。</p><p><img src="https://z3.ax1x.com/2021/03/25/6L82o4.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6L82o4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>利用命令使程序挂起，此时可在设备中看见“Warnning”窗口。</p><blockquote><p>adb shell am start -D -n 包名/包名+类名</p></blockquote><img src="https://z3.ax1x.com/2021/03/25/6L8gwF.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6L8gwF.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:67%;" /><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/81bf07f6-3978-4d13-aa30-7b76c868192d/Screenshot_20210317-170013.png" class="lazyload" data-srcset="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/81bf07f6-3978-4d13-aa30-7b76c868192d/Screenshot_20210317-170013.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/81bf07f6-3978-4d13-aa30-7b76c868192d/Screenshot_20210317-170013.png"></p><p>打开ddms可以发现被挂起的进程名之前出现红虫虫。</p><p><img src="https://z3.ax1x.com/2021/03/25/6L8yLT.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6L8yLT.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>打开IDA进行attach，选择进程，进入调试窗口。</p><p><img src="https://z3.ax1x.com/2021/03/25/6L8ceU.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6L8ceU.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://z3.ax1x.com/2021/03/25/6L8syV.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6L8syV.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>勾选三个调试器选项（程序入口点，线程启动终止，库加载卸载），F9运行，此时标题显示“running”。</p><p><img src="https://z3.ax1x.com/2021/03/25/6L8WFJ.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6L8WFJ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>释放程序，此时在ddms中发现红虫虫变绿虫虫，此时程序中的提示窗口消失，程序正常运行。</p><p><img src="https://z3.ax1x.com/2021/03/25/6L8fY9.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6L8fY9.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>在IDA的模块窗口搜索，若未发现目标库则继续运行，随后即可发现目标库被加载到IDA，开始调试。</p><img src="https://z3.ax1x.com/2021/03/25/6L8hWR.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6L8hWR.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:50%;" /><p>Command List：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./data/user/tmp/as</span><br><span class="line">adb forward tcp:23946 tcp:23946</span><br><span class="line">adb shell am start -D -n 包名/包名+类名</span><br><span class="line">jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=pid</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> AndroidRe </tag>
            
            <tag> Summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NDK开发</title>
      <link href="2021/02/27/NDK%E5%BC%80%E5%8F%91/"/>
      <url>2021/02/27/NDK%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>用C/C++开发Android<span id="more"></span></p><p>Android工程一般由java语言编写，但是可以通过NDK调用native方法来执行C/C++的代码，后者代码中的标识符需要在工程中进行注册，以便在java被一一对应地找到并正确调用。下面介绍关于native方法的开发过程。</p><h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><h3 id="编写-java"><a href="#编写-java" class="headerlink" title="编写.java"></a>编写.java</h3><p>在java文件中声明需要用到的native函数，无需编写方法体。</p><p><img src="https://z3.ax1x.com/2021/03/25/6LQGEd.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LQGEd.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>声明后插入如下代码，以便运行时加载native库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.loadLibrary(<span class="string">&quot;strjni&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="生成-h"><a href="#生成-h" class="headerlink" title="生成.h"></a>生成.h</h3><p>在src文件夹运行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javah -jni com.example.ndktest.MainActivity</span><br></pre></td></tr></table></figure><p>在工程目录新建文件夹”jni”，将src文件夹下生成的.h重命名后移动到此处。</p><p><img src="https://z3.ax1x.com/2021/03/25/6LQJUA.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LQJUA.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h3 id="编写mk文件"><a href="#编写mk文件" class="headerlink" title="编写mk文件"></a>编写mk文件</h3><p>在jni文件夹新建两个makefile文件，此类文件用于描述编译的相关配置。文件名及内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Android.mk</span></span><br><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span>   </span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span>  </span><br><span class="line">LOCAL_MODULE    := strjni  <span class="comment">#模块名称  </span></span><br><span class="line">LOCAL_SRC_FILES := strjni.c <span class="comment">#源文件  .c或者.cpp</span></span><br><span class="line">LOCAL_ARM_MODE := arm       <span class="comment">#编译后的指令集 ARM指令</span></span><br><span class="line">LOCAL_LDLIBS += -llog       <span class="comment">#依赖库    </span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SHARED_LIBRARY)</span> <span class="comment">#指定编译文件的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Application.mk</span></span><br><span class="line">APP_ABI := armeabi-v7a</span><br></pre></td></tr></table></figure><h3 id="编写-c，编译"><a href="#编写-c，编译" class="headerlink" title="编写.c，编译"></a>编写.c，编译</h3><p>根据.h中的声明，在.c文件中编写native函数的函数体。详细编写分为静态注册与动态注册。</p><p>在jni目录下执行如下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ndk<span class="literal">-build</span></span><br></pre></td></tr></table></figure><h3 id="运行调试"><a href="#运行调试" class="headerlink" title="运行调试"></a>运行调试</h3><p>构建工程，连接AVD并且运行调试。</p><h2 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h2><p>通过 JNIEXPORT 和 JNICALL 两个宏定义声明，程序加载so时会根据上面的宏定义声明链接到对应的native函数。</p><h3 id="Exp："><a href="#Exp：" class="headerlink" title="Exp："></a>Exp：</h3><p>在Java code中声明如下函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">get_str</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">get_strstatic_str</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">get_string_from_c</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>用 <strong>javah -jni 包名+类名</strong>命令生成如下.h文件：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;jni.h&gt;</span><br><span class="line"></span><br><span class="line">#ifndef _Included_com_example_jinstudy_MainActivity</span><br><span class="line">#define _Included_com_example_jinstudy_MainActivity</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">#endif</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_example_jinstudy_MainActivity</span></span><br><span class="line"><span class="comment"> * Method:    get_str</span></span><br><span class="line"><span class="comment"> * Signature: ()Ljava/lang/String;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_example_jinstudy_MainActivity_get_str</span><br><span class="line">  (JNIEnv *, jobject);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_example_jinstudy_MainActivity</span></span><br><span class="line"><span class="comment"> * Method:    get_strstatic_str</span></span><br><span class="line"><span class="comment"> * Signature: ()Ljava/lang/String;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_example_jinstudy_MainActivity_get_strstatic_str</span><br><span class="line">  (JNIEnv *, jobject);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_example_jinstudy_MainActivity</span></span><br><span class="line"><span class="comment"> * Method:    get_string_from_c</span></span><br><span class="line"><span class="comment"> * Signature: ()Ljava/lang/String;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_example_jinstudy_MainActivity_get_string_from_c</span><br><span class="line">  (JNIEnv *, jobject);</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>我们发现原本Java中的String类型，变成了C中的jstring类型，这是两种语言在数据结构上的映射。详细对应情况如下：</p><p><img src="https://z3.ax1x.com/2021/03/25/6LQY4I.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LQY4I.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>引入上述.h，编写如下.c文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;JNIstudy.h&gt;</span></span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_example_jinstudy_MainActivity_get_str_from_c</span><br><span class="line">  (JNIEnv *env, jobject obj)&#123;</span><br><span class="line"><span class="comment">//类型转换 NewStringUTF(env，字符串)</span></span><br><span class="line"> jstring str= (*env)-&gt;NewStringUTF(env, <span class="string">&quot;Test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用java层普通字段</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_example_jinstudy_MainActivity_get_str</span><br><span class="line">  (JNIEnv *env, jobject obj)&#123;</span><br><span class="line"><span class="comment">//1.获取类</span></span><br><span class="line"><span class="comment">//FindClass:第一个env，第二个：字段所在类的路径（点换成斜杠）</span></span><br><span class="line">jclass    _jclass = (*env)-&gt;FindClass(env,<span class="string">&quot;com/example/jinstudy/MainActivity&quot;</span>);</span><br><span class="line"><span class="comment">//2.获取字段ID</span></span><br><span class="line"><span class="comment">//GetFieldID:第一个env，第二个FindClass的返回值，第三个java层字段的名称，第四个java层字段的签名</span></span><br><span class="line"> jfieldID  _jfieldID = (*env)-&gt;GetFieldID(env, _jclass, <span class="string">&quot;ZD&quot;</span>, <span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line"> <span class="comment">//3.获取字段</span></span><br><span class="line"> <span class="comment">//GetObjectField:第一个env，第二个obj，第三个GetFieldID的返回值</span></span><br><span class="line"> jobject   str= (*env)-&gt;GetObjectField(env, obj, _jfieldID);</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用java层静态字段</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_example_jinstudy_MainActivity_get_static_str</span><br><span class="line">  (JNIEnv *env, jobject obj)&#123;</span><br><span class="line"><span class="comment">//1.获取类：FindClass（）</span></span><br><span class="line">jclass _jclass = (*env)-&gt;FindClass(env,<span class="string">&quot;com/example/jinstudy/MainActivity&quot;</span>);</span><br><span class="line"><span class="comment">//2.获取静态字段ID</span></span><br><span class="line">jfieldID  _jfieldID= (*env)-&gt;GetStaticFieldID(env, _jclass, <span class="string">&quot;ZD1&quot;</span>,<span class="string">&quot;Ljava/lang/String;&quot;</span>);</span><br><span class="line"><span class="comment">//3.获取静态字段</span></span><br><span class="line"><span class="comment">//GetStaticObjectField:第一个env，第二个是类,既FindClass的返回值，第三个参数GetStaticFieldID的返回值</span></span><br><span class="line">jobject  str= (*env)-&gt;GetStaticObjectField(env, _jclass, _jfieldID);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意的是：</strong></p><ol><li><p>通常在我们编写native函数时，此类函数都会自带两个参数，分别为<em>JNIEnv *<em>和</em>jobject</em>，紧接着才是该函数在Java层中声明的参数列表。</p></li><li><p>我们通常需要返回一个<em>jobject</em>类型的对象，这就需要用到<strong>GetStaticObjectField</strong>方法，其参数分别是<em>JNIEnv*</em>,<em>jclass,jfiledID</em>。这里的JNIEnv<em>以及本节中后文的JNIEnv</em>均和native函数传入的第一个参数是一样的。</p></li><li><p>jfiledID对象将Java层的字段类型映射到C中，其需要通过<strong>GetStaticFieldID</strong>方法获取，而此方法的参数为<em>JNIEnv*</em>,<em>jclass,string,string</em>。<em>string</em>类型的第一个参数需要传入的是字段在Java层中的名称，第二个参数则是该参数的完整类型名称并以’;’结尾。</p></li><li><p>jclass则需要使用<strong>FindClass</strong>方法获取，其参数为<em>JNIEnv*<em>，</em>string</em>。<em>string</em>类型参数需要传入的是函数所在类的路径名，可以理解成将’.’替换成’/‘的包名+类名。</p></li><li><p>其实静态注册的代码编写的要点就是，需要的获取什么样的类型，就在jni.h中寻找能返回该类型的对应方法，再补全此方法的参数。本质是一个递归补全参数的过程😂。</p></li></ol><h2 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h2><p>通过 RegisterNatives函数由编程者完成 native函数与so中函数的绑定，使得程序可以通过这个映射表找到相应的函数了。</p><h3 id="Exp"><a href="#Exp" class="headerlink" title="Exp:"></a>Exp:</h3><p>在Java code中声明如下加减乘除函数:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> number1,<span class="keyword">double</span> number2)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">double</span> <span class="title">sub</span><span class="params">(<span class="keyword">double</span> number1,<span class="keyword">double</span> number2)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">double</span> <span class="title">mul</span><span class="params">(<span class="keyword">double</span> number1,<span class="keyword">double</span> number2)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">double</span> <span class="title">div</span><span class="params">(<span class="keyword">double</span> number1,<span class="keyword">double</span> number2)</span></span>;</span><br></pre></td></tr></table></figure><p>引入jni.h后直接编写对应的.c文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="function">jdouble <span class="title">addc</span><span class="params">(JNIEnv *env, jobject obj, jdouble a, jdouble b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">jdouble <span class="title">subc</span><span class="params">(JNIEnv *env, jobject obj, jdouble a, jdouble b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a-b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">jdouble <span class="title">mulc</span><span class="params">(JNIEnv *env, jobject obj, jdouble a, jdouble b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">jdouble <span class="title">divc</span><span class="params">(JNIEnv *env, jobject obj, jdouble a, jdouble b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a/b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明native方法结构体</span></span><br><span class="line">JNINativeMethod nm[]=&#123;</span><br><span class="line"><span class="comment">//参数：需绑定的java层函数名,参数返回值类型,需绑定的native函数指针</span></span><br><span class="line">&#123;<span class="string">&quot;add&quot;</span>,<span class="string">&quot;(DD)D&quot;</span>,(<span class="keyword">void</span>*)addc&#125;,</span><br><span class="line">&#123;<span class="string">&quot;sub&quot;</span>,<span class="string">&quot;(DD)D&quot;</span>,(<span class="keyword">void</span>*)subc&#125;,</span><br><span class="line">&#123;<span class="string">&quot;mul&quot;</span>,<span class="string">&quot;(DD)D&quot;</span>,(<span class="keyword">void</span>*)mulc&#125;,</span><br><span class="line">&#123;<span class="string">&quot;div&quot;</span>,<span class="string">&quot;(DD)D&quot;</span>,(<span class="keyword">void</span>*)divc&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态注册</span></span><br><span class="line"><span class="function">JNIEXPORT jint JNICALL <span class="title">JNI_OnLoad</span><span class="params">(JavaVM* vm, <span class="keyword">void</span>* reserved)</span></span>&#123;</span><br><span class="line">JNIEnv* env;</span><br><span class="line"><span class="keyword">if</span>( (*vm)-&gt;GetEnv(vm, (<span class="keyword">void</span>**)&amp;env, JNI_VERSION_1_4)!=JNI_OK)&#123;</span><br><span class="line"> <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">&#125;</span><br><span class="line">jclass jc = (*env)-&gt;FindClass(env,<span class="string">&quot;com/example/calcu/MainActivity&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>((*env)-&gt;RegisterNatives(env, jc, nm,<span class="keyword">sizeof</span>(nm)/<span class="keyword">sizeof</span>(nm[<span class="number">0</span>]))!=JNI_OK)&#123;</span><br><span class="line"><span class="keyword">return</span> JNI_ERR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//固定返回值</span></span><br><span class="line"><span class="keyword">return</span> JNI_VERSION_1_4;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意：</strong></p><ol><li><p>编写函数体的过程和静态注册差异不大</p></li><li><p>由于没有生成.h文件对函数进行声明，因此我们需要将所有函数整合为一个<em>JNINativeMethod</em>类型的结构体。其属性分别为函数再Java层中的字段名(string)，参数和返回值类型(string)，其中参数写在括号内，返回值写在括号外，最后一个参数是Native方法的函数指针(void *)。</p></li><li><p>对上述结构体用RegisterNatives方法进行注册，补全相应的参数后，写入<strong>JNI_OnLoad</strong>函数体中，该函数是动态注册是Native方法的入口。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> AndroidRe </tag>
            
            <tag> Summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dalvik字节码</title>
      <link href="2021/02/21/Dalvik%E5%AD%97%E8%8A%82%E7%A0%81/"/>
      <url>2021/02/21/Dalvik%E5%AD%97%E8%8A%82%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>看懂Dalvik字节码，看懂Smali文件。<span id="more"></span></p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>存储变量≤32位，用1个寄存器</p><p>存储变量64位，用2个相邻寄存器</p><h2 id="寄存器命名法"><a href="#寄存器命名法" class="headerlink" title="寄存器命名法"></a>寄存器命名法</h2><h3 id="v命名法"><a href="#v命名法" class="headerlink" title="v命名法"></a>v命名法</h3><p>局部变量：M个  使用寄存器：v0~vM-1</p><p>传入参数：N个  使用寄存器：vM~vM+N-1</p><p><img src="https://img-blog.csdn.net/20160731141440713" class="lazyload" data-srcset="https://img-blog.csdn.net/20160731141440713" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h3 id="p命名法"><a href="#p命名法" class="headerlink" title="p命名法"></a>p命名法</h3><p>局部变量：M个  使用寄存器：v0~vM-1</p><p>传入参数：N个  使用寄存器：p0~pN-1</p><p><img src="https://img-blog.csdn.net/20160731142057192" class="lazyload" data-srcset="https://img-blog.csdn.net/20160731142057192" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://z3.ax1x.com/2021/03/25/6LK2on.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LK2on.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h2 id="smali数据类型"><a href="#smali数据类型" class="headerlink" title="smali数据类型"></a>smali数据类型</h2><p><img src="https://z3.ax1x.com/2021/03/25/6LKgds.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LKgds.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h2 id="字段与函数分析"><a href="#字段与函数分析" class="headerlink" title="字段与函数分析"></a>字段与函数分析</h2><h3 id="字段格式"><a href="#字段格式" class="headerlink" title="字段格式"></a>字段格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lpackage/name/ObjectName;-&gt;FieldName:Ljava/lang/String;</span><br></pre></td></tr></table></figure><p>分析为java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Lpackage.name</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectName</span></span>&#123;</span><br><span class="line">String FieldName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数格式"><a href="#函数格式" class="headerlink" title="函数格式"></a>函数格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lpackage/name/ObjectName;-&gt;MethodName(III)Z</span><br></pre></td></tr></table></figure><p>分析为java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Lpackage.name</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectName</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">MethodName</span><span class="params">(<span class="keyword">int</span> ,<span class="keyword">int</span> ,<span class="keyword">int</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dalvik指令格式"><a href="#Dalvik指令格式" class="headerlink" title="Dalvik指令格式"></a>Dalvik指令格式</h2><blockquote><p>格式：基础字节码-名称后缀/字节码后缀  目的寄存器  源寄存器</p></blockquote><blockquote><p>exp：       move    - wide     /     from16           vAA     ,  vBBBB</p></blockquote><ul><li>其中move为基础字节码，opcode</li><li>wide为名称后缀,标识指令操作的数据宽度为64位。</li><li>from16为字节码后缀,标识源为一个16位的寄存器引用变量</li><li>vAA为目的寄存器,它始终在源的前面，取值范围为v0~v255</li><li>vBBBB为源寄存器，取值范围为v0~v65535</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> AndroidRe </tag>
            
            <tag> Summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android基础</title>
      <link href="2021/02/12/Android%E5%9F%BA%E7%A1%80/"/>
      <url>2021/02/12/Android%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>补充一些关于Android的系统知识。<span id="more"></span></p><h2 id="APK包结构"><a href="#APK包结构" class="headerlink" title="APK包结构"></a>APK包结构</h2><table><thead><tr><th>Filename</th><th>Property</th></tr></thead><tbody><tr><td>assets</td><td>静态资源（图片，配置文件，html5离线资源）任意深度子目录</td></tr><tr><td>res</td><td>程序资源（图片，图标，字符串）拥有对应资源id，关联代码R.java</td></tr><tr><td>lib</td><td>依赖库（当前app用到的so）</td></tr><tr><td>META-INF</td><td>证书签名文件</td></tr><tr><td>.dex</td><td>可执行文件（方法数&gt;2¹⁶时分包）</td></tr><tr><td>AndroidManifest.xml</td><td>项目的系统清单（配置、四大组件的声明）</td></tr><tr><td>resources.arsc</td><td>资源索引表</td></tr></tbody></table><h2 id="Android打包流程"><a href="#Android打包流程" class="headerlink" title="Android打包流程"></a>Android打包流程</h2><p><img src="https://z3.ax1x.com/2021/03/25/6LmyL9.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LmyL9.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:56%;" /><img src="https://z3.ax1x.com/2021/03/25/6LmrM4.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LmrM4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" style="zoom:50%;" /></p><p>1.资源→源码</p><p>2.接口→源码</p><p>3.源码→字节码</p><p>4.字节码→可执行</p><p>5.可执行→apk</p><p>6.apk签名</p><p>7.apk对齐压缩</p><h2 id="APK安装流程"><a href="#APK安装流程" class="headerlink" title="APK安装流程"></a>APK安装流程</h2><p><img src="https://z3.ax1x.com/2021/03/25/6LmBzF.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LmBzF.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p>1.在/data/app创建以apk包名命名的文件夹，并将apk解压至此</p><p>2.在/data/data创建以apk包名命名的文件夹，解析AndroidManifest.xml并上述文件夹写入应用数据</p><p>3.优化dex文件，保存于”/data/dalvik-cache/profiles/“+apk包名</p><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><table><thead><tr><th>类型</th><th>运行</th><th>机制</th><th>特点</th></tr></thead><tbody><tr><td>java虚拟机</td><td>Java字节码(.class)</td><td>略</td><td>基于栈架构</td></tr><tr><td>Dalvik虚拟机</td><td>DEX字节码（.odex）</td><td>jit编译机制</td><td>基于寄存器架构（≤Android 5.0）</td></tr><tr><td>ART虚拟机</td><td>DEX字节码（.oat）</td><td>aot编译机制</td><td>基于寄存器架构（&gt;Android 5.0）</td></tr></tbody></table><p><img src="https://z3.ax1x.com/2021/03/25/6LmssJ.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6LmssJ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h2 id="Android四大组件"><a href="#Android四大组件" class="headerlink" title="Android四大组件"></a>Android四大组件</h2><h3 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h3><table><thead><tr><th>Name</th><th align="center">What for</th></tr></thead><tbody><tr><td>活动(Activity)</td><td align="center">表现功能，可视化的指令操作窗口</td></tr><tr><td>服务(Services)</td><td align="center">长期后台执行，无交互</td></tr><tr><td>广播接收者(Broadcast Recive)</td><td align="center">接收其他应用程序的广播信息</td></tr><tr><td>内容提供者(Content Provider)</td><td align="center">数据集，由多个应用程序共享使用</td></tr></tbody></table><h2 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h2><p><img src="https://z3.ax1x.com/2021/03/25/6Lm0RU.png" class="lazyload" data-srcset="https://z3.ax1x.com/2021/03/25/6Lm0RU.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p>]]></content>
      
      
      
        <tags>
            
            <tag> AndroidRe </tag>
            
            <tag> Summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Re</title>
      <link href="2020/10/30/Android_Re/"/>
      <url>2020/10/30/Android_Re/</url>
      
        <content type="html"><![CDATA[<p>​        安卓逆向入门入门。<span id="more"></span>最近可算开始学安卓逆向了，先刷刷jarvis oj上的题康康。</p><h2 id="0x00-Smail"><a href="#0x00-Smail" class="headerlink" title="0x00 . Smail"></a>0x00 . Smail</h2><p>​        题目只给了一个.smail文件。smail是Davlik虚拟机的寄存器语言，相当于pc平台的汇编语言，可以看出个大概逻辑。</p><p>​        不过当然可以借助<strong>Smail2java</strong>工具，将其转换成.java文件。</p><p><img src="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102214537.png" class="lazyload" data-srcset="https://raw.githubusercontent.com/ash3n-on3/For-blog-photos/master/img/20201102214537.png" srcset="data:image/png;base64,iVBORw0KGgoAA